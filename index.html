<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Space Survivor - ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</title>
    <style>
  html, body {
    width: 100%;
    height: 100%;
    overflow: auto;
    font-size: 16px;
    box-sizing: border-box;
  }
  canvas {
    max-width: 100%;
    height: auto;
    display: block;
  }
  #gameContainer, #mainMenu, #instructions, #fireControls, #mobileItemButtons {
    max-width: 100vw;
    overflow-x: auto;
    box-sizing: border-box;
    word-break: break-word;
  }
  .menu-button, .mobile-item-button {
    font-size: 1rem;
    padding: 12px;
  }
  @media (max-width: 480px) {
    .menu-button, .mobile-item-button {
      font-size: 0.9rem;
      padding: 10px;
    }
    #fireControls {
    position: fixed;
    bottom: 40px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    #mobileItemButtons {
      right: 10px;
      bottom: 100px;
    }
  }
    #fireBtn {
      width: 56px;
      height: 56px;
      font-size: 16px;
    }
  }
  #fullscreenBtn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 100;
    padding: 10px 15px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    border: none;
    border-radius: 8px;
    font-size: 14px;
  }
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
        }
        
        canvas {
            display: block;
            border: 2px solid #00ff00;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #00ff00;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 0 0 20px #ff0000;
            display: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
        }
        
        #rankingList {
            margin: 20px 0;
            text-align: left;
            color: #00ff00;
            font-size: 16px;
        }
        
        .ranking-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 10px;
            border: 1px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .ranking-item.new-record {
            color: #ffff00;
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
            animation: pulse 1s infinite;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            color: #00ff00;
            text-align: center;
        }
        
        #titleScreen h1 {
            font-size: 4rem;
            margin: 0;
            text-shadow: 0 0 30px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #titleScreen h2 {
            font-size: 1.5rem;
            margin: 10px 0 30px 0;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
        }
        
        #gameModeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 35;
            color: #00ff00;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .mode-btn {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid;
            color: #ffffff;
            padding: 20px;
            margin: 10px 0;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 500px;
        }
        
        .mode-btn.classic {
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .mode-btn.defense {
            border-color: #ff8800;
            color: #ff8800;
        }
        
        .mode-btn.turnbased {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .mode-btn.strategy {
            border-color: #ff00ff;
            color: #ff00ff;
        }
        
        .mode-btn:hover {
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mode-name {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .mode-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        
        #earthHealth {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 10;
            color: #ff8800;
            font-size: 18px;
            text-shadow: 0 0 10px #ff8800;
            display: none;
        }
        
        #turnInfo {
            position: absolute;
            top: 120px;
            left: 20px;
            z-index: 10;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            display: none;
        }
        
        #effectsLog {
            position: absolute;
            top: 160px;
            left: 20px;
            z-index: 10;
            color: #ffff00;
            font-size: 14px;
            text-shadow: 0 0 10px #ffff00;
            display: none;
            max-width: 300px;
        }
        
        #inventoryUI {
            position: absolute;
            top: 220px;
            left: 20px;
            z-index: 10;
            color: #ff8800;
            font-size: 14px;
            text-shadow: 0 0 10px #ff8800;
            display: none;
            max-width: 300px;
        }
        
        .inventory-item {
            background: rgba(255, 136, 0, 0.1);
            border: 1px solid #ff8800;
            padding: 8px 12px;
            margin: 3px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .inventory-item:hover {
            background: rgba(255, 136, 0, 0.2);
            transform: scale(1.02);
        }
        
        .inventory-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .inventory-item.disabled:hover {
            background: rgba(255, 136, 0, 0.1);
            transform: none;
        }
        
        .item-name {
            font-weight: bold;
            color: #ff8800;
        }
        
        .item-count {
            color: #ffff00;
            font-size: 12px;
            background: rgba(255, 255, 0, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid #ffff00;
        }
        
        .item-hotkey {
            color: #00ff00;
            font-size: 10px;
            opacity: 0.7;
            margin-left: 5px;
        }
        
        #commLog {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            color: #00ffaa;
            font-size: 12px;
            text-shadow: 0 0 10px #00ffaa;
            display: none;
            max-width: 350px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            padding: 10px;
            border-radius: 5px;
        }
        
        .comm-message {
            margin: 3px 0;
            padding: 2px 5px;
            border-left: 2px solid #00ffaa;
            background: rgba(0, 255, 170, 0.1);
            animation: fadeInComm 0.5s ease-in;
        }
        
        .comm-urgent {
            color: #ff4400;
            border-left-color: #ff4400;
            background: rgba(255, 68, 0, 0.2);
            text-shadow: 0 0 10px #ff4400;
        }
        
        .comm-warning {
            color: #ffaa00;
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.2);
            text-shadow: 0 0 10px #ffaa00;
        }
        
        @keyframes fadeInComm {
            0% { opacity: 0; transform: translateX(20px); }
            100% { opacity: 1; transform: translateX(0); }
        }
        
        .effect-item {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .effect-name {
            font-weight: bold;
        }
        
        .effect-duration {
            color: #00ff00;
            font-size: 12px;
        }
        
        #helpButton {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 15px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            display: none;
        }
        
        #helpButton:hover {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(1.05);
            text-shadow: 0 0 10px #00ff00;
        }
        
        .earth-damage-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0000;
            animation: damageFlash 0.5s ease-out;
            pointer-events: none;
            z-index: 15;
        }
        
        @keyframes damageFlash {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
        }
        
        .menu-button {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 15px 30px;
            margin: 10px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .menu-button:hover {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(1.05);
            text-shadow: 0 0 10px #00ff00;
        }
        
        .difficulty-btn {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid;
            color: #ffffff;
            padding: 20px;
            margin: 5px 0;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .difficulty-btn.easy {
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .difficulty-btn.normal {
            border-color: #ffff00;
            color: #ffff00;
        }
        
        .difficulty-btn.hard {
            border-color: #ff8800;
            color: #ff8800;
        }
        
        .difficulty-btn.expert {
            border-color: #ff4400;
            color: #ff4400;
        }
        
        .difficulty-btn.nightmare {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .difficulty-btn:hover {
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .diff-name {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .diff-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        
        #difficultyScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 35;
            color: #00ff00;
            padding: 20px;
            box-sizing: border-box;
        }
        
        #instructionsScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 35;
            color: #00ff00;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        .instructions-content {
            max-width: 800px;
            margin: 0 auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .instructions-content h2 {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .weapon-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .weapon-item {
            border: 1px solid #00ff00;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .weapon-icon {
            width: 40px;
            height: 40px;
            border: 2px solid;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .weapon-name {
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .weapon-desc {
            font-size: 12px;
            opacity: 0.8;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes mapEffectFade {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1.0);
            }
        }
        
        @media (max-width: 768px) {
            #titleScreen h1 {
                font-size: 2.5rem;
            }
            
            #titleScreen h2 {
                font-size: 1.2rem;
            }
            
            .menu-button {
                padding: 12px 25px;
                font-size: 16px;
            }
            
            .instructions-content {
                font-size: 12px;
            }
            
            .weapon-grid {
                grid-template-columns: 1fr;
            }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 14px;
            opacity: 0.7;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 40px;
            left: 20px;
            display: none;
        }
        
        #fireControls {
            position: absolute;
            bottom: 40px;
            right: 20px;
            display: none;
        }
        
        .control-btn {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            user-select: none;
            touch-action: manipulation;
            font-family: 'Courier New', monospace;
        }
        
        .control-btn:active {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(0.95);
        }
        
        #dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            margin-bottom: 20px;
        }
        
        #fireBtn  {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background-color: rgba(255, 80, 80, 0.9);
    color: white;
    font-size: 18px;
    font-weight: bold;
    border: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
  }
        
        #fireBtn:active {
            background: rgba(255, 255, 0, 0.4);
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            #fireControls {
                display: block;
            }
            
            #instructions {
                display: none;
            }
            
            #ui {
                font-size: 16px;
            }
            
            body {
                touch-action: none;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
        }
        
        .wireframe {
            stroke: #00ff00;
            fill: none;
            stroke-width: 2;
        }
        
        .enemy {
            stroke: #ff4444;
            fill: none;
            stroke-width: 2;
        }
        
        .bullet {
            stroke: #ffff00;
            fill: #ffff00;
            stroke-width: 1;
        }
        
        .explosion {
            stroke: #ff8800;
            fill: none;
            stroke-width: 3;
        }
    </style>
</head>
<body style="margin:0; padding:0; overflow:auto; touch-action:manipulation; -webkit-overflow-scrolling: touch;">
    <div id="gameContainer">
        <div id="titleScreen">
            <h1>SPACE SURVIVOR</h1>
            <h2>ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ  ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</h2>
            <button class="menu-button" onclick="game.showGameModeSelect()">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
            <button class="menu-button" onclick="game.showInstructions()">æ“ä½œèª¬æ˜</button>
        </div>
        
        <div id="gameModeScreen">
            <div class="instructions-content" style="text-align: center; max-width: 600px;">
                <h2 style="color: #00ffff; margin-bottom: 30px;">ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é¸æŠ</h2>
                
                <div class="mode-grid" style="display: grid; gap: 15px; margin: 30px 0;">
                    <button class="mode-btn classic" onclick="game.selectGameMode('classic')">
                        <span class="mode-name">ã‚¯ãƒ©ã‚·ãƒƒã‚¯</span>
                        <span class="mode-desc">å¾“æ¥ã®ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚²ãƒ¼ãƒ  - æ•µã‚’å€’ã—ã¦ã‚¹ã‚³ã‚¢ã‚’ç¨¼ã</span>
                    </button>
                    
                    <button class="mode-btn defense" onclick="game.selectGameMode('defense')">
                        <span class="mode-name">åœ°çƒé˜²è¡›</span>
                        <span class="mode-desc">æ•µãŒç”»é¢ä¸‹éƒ¨ã«åˆ°é”ã™ã‚‹ã¨åœ°çƒãŒãƒ€ãƒ¡ãƒ¼ã‚¸ - åœ°çƒã‚’å®ˆã‚ŠæŠœã‘</span>
                    </button>
                    
                    <button class="mode-btn turnbased" onclick="game.selectGameMode('turnbased')">
                        <span class="mode-name">ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹</span>
                        <span class="mode-desc">è‡ªæ©ŸãŒå‹•ãã¨æ•µã‚‚ä¸‹ã«å‘ã‹ã£ã¦ç§»å‹• - æˆ¦ç•¥çš„ãªç§»å‹•ãŒé‡è¦</span>
                    </button>
                    
                    <button class="mode-btn strategy" onclick="game.selectGameMode('strategy')">
                        <span class="mode-name">ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼</span>
                        <span class="mode-desc">åœ°çƒé˜²è¡› + ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ - ç©¶æ¥µã®æˆ¦ç•¥ãƒ¢ãƒ¼ãƒ‰</span>
                    </button>
                </div>
                
                <button class="menu-button" onclick="game.hideGameModeSelect()">æˆ»ã‚‹</button>
            </div>
        </div>
        
        <div id="difficultyScreen" style="display: none;">
            <div class="instructions-content" style="text-align: center; max-width: 600px;">
                <h2 style="color: #00ffff; margin-bottom: 30px;">é›£æ˜“åº¦é¸æŠ</h2>
                
                <div class="difficulty-grid" style="display: grid; gap: 15px; margin: 30px 0;">
                    <button class="difficulty-btn easy" onclick="game.startGameWithDifficulty('easy')">
                        <span class="diff-name">EASY</span>
                        <span class="diff-desc">åˆå¿ƒè€…å‘ã‘ - ã‚¢ã‚¤ãƒ†ãƒ å¤šã‚ã€æ•µå°‘ãªã‚</span>
                    </button>
                    
                    <button class="difficulty-btn normal" onclick="game.startGameWithDifficulty('normal')">
                        <span class="diff-name">NORMAL</span>
                        <span class="diff-desc">æ¨™æº–çš„ãªé›£æ˜“åº¦ - ãƒãƒ©ãƒ³ã‚¹é‡è¦–</span>
                    </button>
                    
                    <button class="difficulty-btn hard" onclick="game.startGameWithDifficulty('hard')">
                        <span class="diff-name">HARD</span>
                        <span class="diff-desc">ä¸Šç´šè€…å‘ã‘ - æ•µå¤šã‚ã€ã‚¢ã‚¤ãƒ†ãƒ å°‘ãªã‚</span>
                    </button>
                    
                    <button class="difficulty-btn expert" onclick="game.startGameWithDifficulty('expert')">
                        <span class="diff-name">EXPERT</span>
                        <span class="diff-desc">ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ - é«˜é€Ÿæ•µã€ã‚¢ã‚¤ãƒ†ãƒ æ¿€æ¸›</span>
                    </button>
                    
                    <button class="difficulty-btn nightmare" onclick="game.startGameWithDifficulty('nightmare')">
                        <span class="diff-name">NIGHTMARE</span>
                        <span class="diff-desc">æ‚ªå¤¢ç´š - æœ€é«˜é›£æ˜“åº¦ã€ç”Ÿå­˜ãŒå›°é›£</span>
                    </button>
                </div>
                
                <button class="menu-button" onclick="game.hideDifficultySelect()">æˆ»ã‚‹</button>
            </div>
        </div>
        
        <div id="instructionsScreen">
            <div class="instructions-content">
                <h2>ğŸ® æ“ä½œæ–¹æ³•</h2>
                <p><strong>PC:</strong> çŸ¢å°ã‚­ãƒ¼ï¼šç§»å‹• | ã‚¹ãƒšãƒ¼ã‚¹ï¼šå°„æ’ƒ | ESCï¼šãƒãƒ¼ã‚º</p>
                <p><strong>ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼:</strong> Qã‚­ãƒ¼ï¼šã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ä½¿ç”¨</p>
                <p><strong>ãƒ¢ãƒã‚¤ãƒ«:</strong> ç”»é¢ä¸‹ã®ãƒœã‚¿ãƒ³ã§æ“ä½œ</p>
                
                <h2>ğŸ¯ ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰</h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff00; color: #00ff00;">C</div>
                        <div class="weapon-name" style="color: #00ff00;">ã‚¯ãƒ©ã‚·ãƒƒã‚¯</div>
                        <div class="weapon-desc">å¾“æ¥ã®ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã€‚æ•µã‚’å€’ã—ã¦ã‚¹ã‚³ã‚¢ã‚’ç¨¼ãã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff8800; color: #ff8800;">D</div>
                        <div class="weapon-name" style="color: #ff8800;">åœ°çƒé˜²è¡›</div>
                        <div class="weapon-desc">æ•µãŒç”»é¢ä¸‹éƒ¨ã«åˆ°é”ã™ã‚‹ã¨åœ°çƒãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚åœ°çƒHPãŒ0ã«ãªã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">T</div>
                        <div class="weapon-name" style="color: #00ffff;">ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹</div>
                        <div class="weapon-desc">è‡ªæ©ŸãŒå‹•ãã¨æ•µã‚‚ä¸‹ã«å‘ã‹ã£ã¦ç§»å‹•ã€‚æˆ¦ç•¥çš„ãªç§»å‹•ãŒé‡è¦ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">S</div>
                        <div class="weapon-name" style="color: #ff00ff;">ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼</div>
                        <div class="weapon-desc">åœ°çƒé˜²è¡›ã¨ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ã‚’çµ„ã¿åˆã‚ã›ãŸç©¶æ¥µã®æˆ¦ç•¥ãƒ¢ãƒ¼ãƒ‰ã€‚</div>
                    </div>
                </div>
                
                <h2>âš”ï¸ æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ </h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">|</div>
                        <div class="weapon-name" style="color: #ffff00;">åŸºæœ¬å°„æ’ƒ</div>
                        <div class="weapon-desc">æœ€å¤§3é€£å°„ã¾ã§å¼·åŒ–å¯èƒ½ã€‚åŸºæœ¬ã¨ãªã‚‹æ­¦å™¨ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff8800; color: #ff8800;">|||</div>
                        <div class="weapon-name" style="color: #ff8800;">æ‹¡æ•£å°„æ’ƒ</div>
                        <div class="weapon-desc">æ‰‡çŠ¶ã«å¤šæ•°ã®å¼¾ã‚’ç™ºå°„ã€‚åºƒç¯„å›²æ”»æ’ƒã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">â”</div>
                        <div class="weapon-name" style="color: #00ffff;">ãƒ¬ãƒ¼ã‚¶ãƒ¼</div>
                        <div class="weapon-desc">ç”»é¢ã‚’è²«é€šã™ã‚‹å¼·åŠ›ãªãƒ“ãƒ¼ãƒ æ”»æ’ƒã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff0000; color: #ff0000;">â—†</div>
                        <div class="weapon-name" style="color: #ff0000;">ãƒŸã‚µã‚¤ãƒ«</div>
                        <div class="weapon-desc">çˆ†ç™ºç¯„å›²ãƒ€ãƒ¡ãƒ¼ã‚¸ä»˜ãã®é‡ç«å™¨ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff88; color: #00ff88;">â—‹</div>
                        <div class="weapon-name" style="color: #00ff88;">è»Œé“å¼¾</div>
                        <div class="weapon-desc">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨ã‚Šã‚’å›è»¢ã™ã‚‹é˜²å¾¡å…¼æ”»æ’ƒã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff00; color: #00ff00;">â†’</div>
                        <div class="weapon-name" style="color: #00ff00;">è²«é€šå¼¾</div>
                        <div class="weapon-desc">è¤‡æ•°ã®æ•µã‚’è²«é€šã™ã‚‹å¼¾ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">â—</div>
                        <div class="weapon-name" style="color: #ff00ff;">è¿½å°¾å¼¾</div>
                        <div class="weapon-desc">æ•µã‚’è‡ªå‹•ã§è¿½ã„ã‹ã‘ã‚‹å¼¾ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #8800ff; color: #8800ff;">âŠ•</div>
                        <div class="weapon-name" style="color: #8800ff;">ãƒãƒªã‚¢</div>
                        <div class="weapon-desc">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨å›²ã«é˜²å¾¡å¼¾ã‚’é…ç½®ã€‚</div>
                    </div>
                </div>
                
                <h2>âš¡ ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼å°‚ç”¨ã‚¢ã‚¤ãƒ†ãƒ </h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">â„</div>
                        <div class="weapon-name" style="color: #00ffff;">æ•µå…¨ä½“å‡çµ</div>
                        <div class="weapon-desc">3ã‚¿ãƒ¼ãƒ³ã®é–“ã€å…¨ã¦ã®æ•µã®è¡Œå‹•ã‚’åœæ­¢ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">â°</div>
                        <div class="weapon-name" style="color: #ffff00;">æ™‚é–“æ¸›é€Ÿ</div>
                        <div class="weapon-desc">5ã‚¿ãƒ¼ãƒ³ã®é–“ã€æ•µã®ç§»å‹•é€Ÿåº¦ã‚’å¤§å¹…ã«æ¸›å°‘ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">ğŸ›¡</div>
                        <div class="weapon-name" style="color: #00ffff;">å…¨ä½“ã‚·ãƒ¼ãƒ«ãƒ‰</div>
                        <div class="weapon-desc">10ã‚¿ãƒ¼ãƒ³ã®é–“ã€å…¨ã¦ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡åŠ¹åŒ–ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">2X</div>
                        <div class="weapon-name" style="color: #ffff00;">ã‚¹ã‚³ã‚¢2å€</div>
                        <div class="weapon-desc">10ã‚¿ãƒ¼ãƒ³ã®é–“ã€ç²å¾—ã‚¹ã‚³ã‚¢ãŒ2å€ã«ãªã‚‹ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff8800; color: #ff8800;">âš¡</div>
                        <div class="weapon-name" style="color: #ff8800;">é€£å°„å¼·åŒ–</div>
                        <div class="weapon-desc">5ã‚¿ãƒ¼ãƒ³ã®é–“ã€å…¨æ­¦å™¨ã®ç™ºå°„é–“éš”ãŒçŸ­ç¸®ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">â˜…</div>
                        <div class="weapon-name" style="color: #ff00ff;">ç„¡æ•µçŠ¶æ…‹</div>
                        <div class="weapon-desc">3ã‚¿ãƒ¼ãƒ³ã®é–“ã€æ•µã¨ã®æ¥è§¦ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡åŠ¹åŒ–ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff0000; color: #ff0000;">ğŸ’¥</div>
                        <div class="weapon-name" style="color: #ff0000;">ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³</div>
                        <div class="weapon-desc">ç”»é¢ä¸Šã®å…¨ã¦ã®æ•µã‚’å³åº§ã«ç ´å£Šã™ã‚‹ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">ğŸŒ€</div>
                        <div class="weapon-name" style="color: #ff00ff;">æ™‚ç©ºæ­ªæ›²</div>
                        <div class="weapon-desc">å…¨ã¦ã®æ•µã‚’éå»ã®ä½ç½®ã«æˆ»ã™ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">âš¡</div>
                        <div class="weapon-name" style="color: #ffff00;">é›·æ’ƒ</div>
                        <div class="weapon-desc">ãƒ©ãƒ³ãƒ€ãƒ ãªæ•µ5ä½“ã«å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff00; color: #00ff00;">+</div>
                        <div class="weapon-name" style="color: #00ff00;">åœ°çƒå›å¾©</div>
                        <div class="weapon-desc">åœ°çƒHPã‚’30å›å¾©ï¼ˆåœ°çƒé˜²è¡›ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff4400; color: #ff4400;">âš¡</div>
                        <div class="weapon-name" style="color: #ff4400;">ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ </div>
                        <div class="weapon-desc">4ã‚¿ãƒ¼ãƒ³ã®é–“ã€æ•µã«ç¶™ç¶šçš„ãªãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #8800ff; color: #8800ff;">ğŸ”®</div>
                        <div class="weapon-name" style="color: #8800ff;">ç£åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</div>
                        <div class="weapon-desc">6ã‚¿ãƒ¼ãƒ³ã®é–“ã€æ•µã‚’ç”»é¢ä¸­å¤®ã«å¼•ãå¯„ã›ã‚‹ã€‚</div>
                    </div>
                </div>
                
                <h2>ğŸ ãã®ä»–ã®ã‚¢ã‚¤ãƒ†ãƒ </h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">â—¯</div>
                        <div class="weapon-name" style="color: #00ffff;">ã‚·ãƒ¼ãƒ«ãƒ‰</div>
                        <div class="weapon-desc">ä¸€å®šæ™‚é–“ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡åŠ¹åŒ–ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff0080; color: #ff0080;">â™¥</div>
                        <div class="weapon-name" style="color: #ff0080;">ãƒ©ã‚¤ãƒ•</div>
                        <div class="weapon-desc">æ®‹æ©Ÿã‚’1ã¤å›å¾©ã€‚</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #88ff00; color: #88ff00;">â‡’</div>
                        <div class="weapon-name" style="color: #88ff00;">ã‚¹ãƒ”ãƒ¼ãƒ‰</div>
                        <div class="weapon-desc">ç§»å‹•é€Ÿåº¦ã‚’æ°¸ç¶šçš„ã«å‘ä¸Šã€‚</div>
                    </div>
                </div>
                
                <h2>ğŸ‘¾ æ•µã®ç¨®é¡</h2>
                <p><span style="color: #ff4444;">â–  é€šå¸¸æ•µ</span> - 100ç‚¹ | <span style="color: #ff0000;">â–  é«˜é€Ÿæ•µ</span> - 200ç‚¹ | <span style="color: #ffaa00;">â–  é‡è£…æ•µ</span> - 300ç‚¹</p>
                <p><span style="color: #ff8800;">â–  å°„æ’ƒæ•µ</span> - 250ç‚¹ | <span style="color: #ff6600;">â–  ã‚¸ã‚°ã‚¶ã‚°æ•µ</span> - 150ç‚¹</p>
                
                <button class="menu-button" onclick="game.hideInstructions()">æˆ»ã‚‹</button>
            </div>
        </div>
        
        <div id="ui">
            <div>ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
            <div>ãƒ©ã‚¤ãƒ•: <span id="lives">3</span></div>
            <div>ãƒ¬ãƒ™ãƒ«: <span id="level">1</span></div>
        </div>
        
        <div id="earthHealth">
            åœ°çƒHP: <span id="earthHp">100</span>
            <div id="dayInfo" style="margin-top: 5px; display: none;">
                <span id="currentDay">DAY 1</span> | ç›®æ¨™: <span id="dayTarget">5,000</span>
            </div>
        </div>
        
        <div id="turnInfo">
            <div>ã‚¿ãƒ¼ãƒ³: <span id="turnCount">1</span></div>
        </div>
        
        <div id="effectsLog">
            <div style="font-weight: bold; margin-bottom: 5px;">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŠ¹æœ:</div>
            <div id="effectsList"></div>
        </div>
        
        <div id="inventoryUI">
            <div style="font-weight: bold; margin-bottom: 5px;">æ‰‹æŒã¡ã‚¢ã‚¤ãƒ†ãƒ :</div>
            <div id="inventoryList"></div>
        </div>
        
        <div id="commLog">
            <div style="font-weight: bold; margin-bottom: 5px; color: #00ffaa;">ğŸ›°ï¸ é˜²è¡›å¸ä»¤éƒ¨é€šä¿¡</div>
            <div id="commMessages"></div>
        </div>
        
        <button id="helpButton" onclick="game.showInstructions()">æ“ä½œèª¬æ˜</button>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameOver">
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <p>æœ€çµ‚ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
            <p>é›£æ˜“åº¦: <span id="finalDifficulty">NORMAL</span></p>
            <div id="rankingList">
                <h3 style="text-align: center; color: #00ffff; margin-bottom: 15px;">ğŸ† ãƒã‚¤ã‚¹ã‚³ã‚¢ ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
                <div id="rankingItems"></div>
            </div>
            <div style="margin-top: 20px;">
                <button class="menu-button" onclick="game.restartSameDifficulty()" style="margin: 5px;">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
                <button class="menu-button" onclick="game.backToTitle()" style="margin: 5px;">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
            </div>
            <p style="margin-top: 15px; font-size: 14px; opacity: 0.7;">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ | ESC: ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</p>
        </div>
        
        <div id="returnToBaseScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; justify-content: center; align-items: center; z-index: 40; color: #00ff00; text-align: center; padding: 20px; box-sizing: border-box;">
            <div style="max-width: 700px;">
                <h1 style="font-size: 2.5rem; margin: 0 0 20px 0; text-shadow: 0 0 30px #00ff00; animation: pulse 2s infinite;">ğŸ›°ï¸ æœ¬éƒ¨å¸°é‚„ ğŸ›°ï¸</h1>
                <h2 id="dayCompleteTitle" style="font-size: 1.5rem; margin: 0 0 30px 0; color: #00ffff; text-shadow: 0 0 20px #00ffff;">DAY 1 ã‚¯ãƒªã‚¢ï¼</h2>
                
                <div style="margin: 30px 0; padding: 20px; border: 2px solid #00ff00; background: rgba(0, 255, 0, 0.1); border-radius: 10px;">
                    <p style="font-size: 1.2rem; margin: 10px 0;">ç¾åœ¨ã‚¹ã‚³ã‚¢: <span id="returnScore" style="color: #ffff00;">0</span></p>
                    <p style="font-size: 1.2rem; margin: 10px 0;">åœ°çƒHP: <span id="returnEarthHp" style="color: #00ff88;">100</span></p>
                    <p style="font-size: 1rem; margin: 15px 0; color: #00ffff;">ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã¯æ¬¡ã®DAYã«ç¶™ç¶šã•ã‚Œã¾ã™</p>
                </div>
                
                <div id="congratsMessage" style="margin: 30px 0; padding: 25px; border: 2px solid #ffff00; background: rgba(255, 255, 0, 0.1); border-radius: 10px; min-height: 120px; display: flex; align-items: center; justify-content: center;">
                    <p id="congratsText" style="font-size: 1.1rem; margin: 0; color: #ffff00; line-height: 1.6;"></p>
                </div>
                
                <div style="margin-top: 40px;">
                    <button class="menu-button" onclick="game.proceedToNextDay()" style="margin: 10px; background: rgba(0, 255, 255, 0.2); border-color: #00ffff; color: #00ffff;">æ¬¡ã®DAYã«é€²ã‚€</button>
                    <button class="menu-button" onclick="game.backToTitle()" style="margin: 10px;">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
                </div>
                
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.7;">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼: æ¬¡ã®DAYã«é€²ã‚€ | ESC: ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</p>
            </div>
        </div>
        
        <div id="endingScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; justify-content: center; align-items: center; z-index: 40; color: #00ff00; text-align: center; padding: 20px; box-sizing: border-box;">
            <div style="max-width: 600px;">
                <h1 style="font-size: 3rem; margin: 0 0 20px 0; text-shadow: 0 0 30px #00ff00; animation: pulse 2s infinite;">ğŸŒ åœ°çƒé˜²è¡›å®Œäº† ğŸŒ</h1>
                <h2 style="font-size: 1.5rem; margin: 0 0 30px 0; color: #00ffff; text-shadow: 0 0 20px #00ffff;">DAY 3 ã‚¯ãƒªã‚¢ï¼</h2>
                
                <div style="margin: 30px 0; padding: 20px; border: 2px solid #00ff00; background: rgba(0, 255, 0, 0.1); border-radius: 10px;">
                    <p style="font-size: 1.2rem; margin: 10px 0;">æœ€çµ‚ã‚¹ã‚³ã‚¢: <span id="endingScore" style="color: #ffff00;">0</span></p>
                    <p style="font-size: 1.2rem; margin: 10px 0;">é›£æ˜“åº¦: <span id="endingDifficulty" style="color: #ff8800;">NORMAL</span></p>
                    <p style="font-size: 1rem; margin: 15px 0; color: #00ffff;">ã‚ãªãŸã®å‹‡æ•¢ãªæˆ¦ã„ã«ã‚ˆã‚Šã€åœ°çƒã¯æ•‘ã‚ã‚Œã¾ã—ãŸï¼</p>
                </div>
                
                <div style="margin: 30px 0;">
                    <p style="font-size: 1rem; margin: 10px 0; opacity: 0.8;">é˜²è¡›ã‚¯ãƒ«ãƒ¼ã®çš†æ§˜ã€ãŠç–²ã‚Œæ§˜ã§ã—ãŸã€‚</p>
                    <p style="font-size: 1rem; margin: 10px 0; opacity: 0.8;">åœ°çƒã®å¹³å’Œã¯å®ˆã‚‰ã‚Œã¾ã—ãŸãŒã€å®‡å®™ã®è„…å¨ã¯ç¶šãã¾ã™...</p>
                </div>
                
                <div style="margin-top: 40px;">
                    <button class="menu-button" onclick="game.startEndlessMode()" style="margin: 10px; background: rgba(255, 255, 0, 0.2); border-color: #ffff00; color: #ffff00;">ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ã«æŒ‘æˆ¦</button>
                    <button class="menu-button" onclick="game.restartSameDifficulty()" style="margin: 10px;">DAY 1ã‹ã‚‰ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
                    <button class="menu-button" onclick="game.backToTitle()" style="margin: 10px;">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
                </div>
                
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.7;">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼: ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ | ESC: ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</p>
            </div>
        </div>
        
        <div id="instructions">
            çŸ¢å°ã‚­ãƒ¼: ç§»å‹• | ã‚¹ãƒšãƒ¼ã‚¹: å°„æ’ƒ | ESC: ãƒãƒ¼ã‚º
        </div>
        
        <div id="mobileControls">
            <div id="dpad">
                <div></div>
                <button class="control-btn" data-key="ArrowUp">â†‘</button>
                <div></div>
                <button class="control-btn" data-key="ArrowLeft">â†</button>
                <div></div>
                <button class="control-btn" data-key="ArrowRight">â†’</button>
                <div></div>
                <button class="control-btn" data-key="ArrowDown">â†“</button>
                <div></div>
            </div>
        </div>
        
        <div id="fireControls">
            <button id="fireBtn" class="control-btn" data-key="Space">å°„æ’ƒ</button>
        </div>
    </div>

    <script>
        class WireframeShooter {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth - 4;
                this.canvas.height = window.innerHeight - 4;
                
                this.gameState = 'title'; // title, playing, paused, gameOver
                this.gameMode = 'classic'; // classic, defense, turnbased, strategy
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.difficulty = 'normal';
                this.difficultySettings = this.getDifficultySettings('normal');
                
                // ã‚°ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
                this.gridSize = 40;
                this.gridWidth = Math.floor(this.canvas.width / this.gridSize);
                this.gridHeight = Math.floor(this.canvas.height / this.gridSize);
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ç”¨
                this.earthHealth = 100;
                this.maxEarthHealth = 100;
                
                // DAYã‚·ã‚¹ãƒ†ãƒ ï¼ˆåœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ï¼‰
                this.currentDay = 1;
                this.dayTargetScores = {
                    1: 5000,   // DAY1ã‚¯ãƒªã‚¢æ¡ä»¶
                    2: 15000,  // DAY2ã‚¯ãƒªã‚¢æ¡ä»¶
                    3: 30000   // DAY3ã‚¯ãƒªã‚¢æ¡ä»¶ï¼ˆã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
                };
                this.dayCleared = false;
                this.endlessMode = false;
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ç”¨
                this.turnCount = 1;
                this.playerMoved = false;
                this.enemyTurnSkip = {}; // æ™‚é–“æ¸›é€ŸåŠ¹æœç”¨ã®æ•µã‚¿ãƒ¼ãƒ³ã‚¹ã‚­ãƒƒãƒ—ç®¡ç†
                
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 100,
                    width: 40,
                    height: 30,
                    speed: this.isMobile() ? 4 : 5,
                    shield: false,
                    shieldTime: 0,
                    // ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
                    gridX: Math.floor(this.gridWidth / 2),
                    gridY: this.gridHeight - 3
                };
                
                // æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ 
                this.weapons = {
                    basicShot: { level: 1, maxLevel: 5, lastShot: 0, cooldown: 150 },
                    spreadShot: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 200 },
                    laser: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 300 },
                    missile: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 800 },
                    orbit: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 100 },
                    piercing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 250 },
                    homing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 400 },
                    barrier: { level: 0, maxLevel: 3, lastShot: 0, cooldown: 1000 }
                };
                
                this.orbitingBullets = [];
                this.barrierBullets = [];
                
                this.bullets = [];
                this.enemies = [];
                this.explosions = [];
                this.stars = [];
                this.earthSurface = [];
                this.powerups = [];
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ç‰¹æ®Šã‚¢ã‚¤ãƒ†ãƒ 
                this.mapEffects = {
                    freeze: { active: false, duration: 0 },
                    slowTime: { active: false, duration: 0 },
                    shield: { active: false, duration: 0 },
                    doubleScore: { active: false, duration: 0 },
                    rapidFire: { active: false, duration: 0 },
                    invincible: { active: false, duration: 0 },
                    magneticField: { active: false, duration: 0 },
                    energyStorm: { active: false, duration: 0 }
                };
                
                this.gridItems = []; // ã‚°ãƒªãƒƒãƒ‰ã«é…ç½®ã•ã‚Œã‚‹ç‰¹æ®Šã‚¢ã‚¤ãƒ†ãƒ 
                
                // æ‰‹æŒã¡ã‚¢ã‚¤ãƒ†ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
                this.inventory = {
                    explosion: 0  // ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ã®æ‰€æŒæ•°
                };
                
                // é€šä¿¡ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ ï¼ˆåœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
                this.currentCommMessage = null;
                this.lastCommTime = 0;
                this.commMessageId = 0;
                
                this.keys = {};
                this.lastShot = 0;
                this.shotCooldown = this.isMobile() ? 200 : 150;
                
                this.initializeStars();
                this.initializeEarthSurface();
                this.setupEventListeners();
                this.setupMobileControls();
                this.setupAudio();
                this.loadRankings();
                this.gameLoop();
            }
            
            getDifficultySettings(difficulty) {
                const settings = {
                    easy: {
                        enemySpawnRate: 0.015,
                        enemySpeedMultiplier: 0.7,
                        powerupSpawnRate: 0.012,
                        enemyHealthMultiplier: 0.8,
                        playerLives: 5,
                        defenseSpeedMultiplier: 0.4
                    },
                    normal: {
                        enemySpawnRate: 0.02,
                        enemySpeedMultiplier: 1.0,
                        powerupSpawnRate: 0.008,
                        enemyHealthMultiplier: 1.0,
                        playerLives: 3,
                        defenseSpeedMultiplier: 0.6
                    },
                    hard: {
                        enemySpawnRate: 0.028,
                        enemySpeedMultiplier: 1.3,
                        powerupSpawnRate: 0.005,
                        enemyHealthMultiplier: 1.2,
                        playerLives: 3,
                        defenseSpeedMultiplier: 0.8
                    },
                    expert: {
                        enemySpawnRate: 0.035,
                        enemySpeedMultiplier: 1.6,
                        powerupSpawnRate: 0.003,
                        enemyHealthMultiplier: 1.5,
                        playerLives: 2,
                        defenseSpeedMultiplier: 1.0
                    },
                    nightmare: {
                        enemySpawnRate: 0.045,
                        enemySpeedMultiplier: 2.0,
                        powerupSpawnRate: 0.002,
                        enemyHealthMultiplier: 2.0,
                        playerLives: 1,
                        defenseSpeedMultiplier: 1.2
                    }
                };
                return settings[difficulty] || settings.normal;
            }
            
            showGameModeSelect() {
                document.getElementById('gameModeScreen').style.display = 'flex';
            }
            
            hideGameModeSelect() {
                document.getElementById('gameModeScreen').style.display = 'none';
            }
            
            selectGameMode(mode) {
                this.gameMode = mode;
                document.getElementById('gameModeScreen').style.display = 'none';
                this.showDifficultySelect();
            }
            
            showDifficultySelect() {
                document.getElementById('difficultyScreen').style.display = 'flex';
            }
            
            hideDifficultySelect() {
                document.getElementById('difficultyScreen').style.display = 'none';
            }
            
            startGameWithDifficulty(difficulty) {
                this.difficulty = difficulty;
                this.difficultySettings = this.getDifficultySettings(difficulty);
                this.gameState = 'playing';
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('difficultyScreen').style.display = 'none';
                
                // UIè¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
                this.updateUIVisibility();
                
                // BGMé–‹å§‹
                this.startBGM();
                
                this.restart();
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯åˆæœŸã‚¢ã‚¤ãƒ†ãƒ ã‚’é…ç½®
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.spawnInitialGridItems();
                    // é›£æ˜“åº¦ã«å¿œã˜ã¦åˆæœŸã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä»˜ä¸
                    this.giveInitialInventoryItems();
                }
            }
            
            updateUIVisibility() {
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€åœ°çƒHPã‚’è¡¨ç¤º
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    document.getElementById('earthHealth').style.display = 'block';
                    
                    // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€DAYæƒ…å ±ã‚‚è¡¨ç¤º
                    if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                        document.getElementById('dayInfo').style.display = 'block';
                    } else {
                        document.getElementById('dayInfo').style.display = 'none';
                    }
                } else {
                    document.getElementById('earthHealth').style.display = 'none';
                    document.getElementById('dayInfo').style.display = 'none';
                }
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚¿ãƒ¼ãƒ³æƒ…å ±ã‚’è¡¨ç¤º
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    document.getElementById('turnInfo').style.display = 'block';
                    document.getElementById('effectsLog').style.display = 'block';
                    document.getElementById('inventoryUI').style.display = 'block';
                } else {
                    document.getElementById('turnInfo').style.display = 'none';
                    document.getElementById('effectsLog').style.display = 'none';
                    document.getElementById('inventoryUI').style.display = 'none';
                }
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€é€šä¿¡ãƒ­ã‚°ã‚’è¡¨ç¤º
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    document.getElementById('commLog').style.display = 'block';
                    // åˆæœŸé€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
                    this.addCommMessage('é˜²è¡›å¸ä»¤éƒ¨ã‚ˆã‚Šã€åœ°çƒé˜²è¡›ä½œæˆ¦ã‚’é–‹å§‹ã—ã¾ã™', 'normal');
                    this.addCommMessage('æ•µã®ä¾µæ”»ã‚’é˜»æ­¢ã—ã€åœ°çƒã‚’å®ˆã‚ŠæŠœã„ã¦ãã ã•ã„', 'normal');
                } else {
                    document.getElementById('commLog').style.display = 'none';
                }
                
                // ã‚²ãƒ¼ãƒ ä¸­ã¯æ“ä½œèª¬æ˜ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                if (this.gameState === 'playing') {
                    document.getElementById('helpButton').style.display = 'block';
                } else {
                    document.getElementById('helpButton').style.display = 'none';
                }
            }
            
            startGame() {
                this.gameState = 'playing';
                document.getElementById('titleScreen').style.display = 'none';
                this.restart();
            }
            
            showInstructions() {
                if (this.gameState === 'playing') this.gameState = 'paused';
                document.getElementById('instructionsScreen').style.display = 'block';
                // ã‚²ãƒ¼ãƒ ä¸­ã®å ´åˆã¯ä¸€æ™‚åœæ­¢
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                }
            }
            
            hideInstructions() {
                document.getElementById('instructionsScreen').style.display = 'none';
                // ã‚²ãƒ¼ãƒ ãŒä¸€æ™‚åœæ­¢ä¸­ã ã£ãŸå ´åˆã¯å†é–‹
                if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                }
            }
            
            isMobile() {
                return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            
applyActiveEffects() {
    // ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—å‡¦ç†
    if (this.mapEffects.rapidFire && this.mapEffects.rapidFire.active) {
        this.player.speed = this.isMobile() ? 6 : 7;
    } else {
        this.player.speed = this.isMobile() ? 4 : 5;
    }

    // ç„¡æ•µçŠ¶æ…‹ãƒ•ãƒ©ã‚°
    this.player.invincible = this.mapEffects.invincible && this.mapEffects.invincible.active;
}


    setupAudio() {
                this.audioContext = null;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.setupBGM();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            setupBGM() {
                if (!this.audioContext) return;
                
                this.bgmPlaying = false;
                this.bgmGainNode = null;
                this.bgmOscillators = [];
                
                // ç¥ç§˜çš„ãªå®‡å®™ã®ã‚¢ãƒ«ãƒšã‚¸ã‚ªãƒ‘ã‚¿ãƒ¼ãƒ³
                // Cãƒã‚¤ãƒŠãƒ¼ãƒšãƒ³ã‚¿ãƒˆãƒ‹ãƒƒã‚¯ + æµ®éŠæ„Ÿã®ã‚ã‚‹éŸ³ç¨‹
                this.arpeggioPattern = [
                    { note: 'C4', freq: 261.63 },
                    { note: 'Eb4', freq: 311.13 },
                    { note: 'F4', freq: 349.23 },
                    { note: 'G4', freq: 392.00 },
                    { note: 'Bb4', freq: 466.16 },
                    { note: 'C5', freq: 523.25 },
                    { note: 'Eb5', freq: 622.25 },
                    { note: 'F5', freq: 698.46 },
                    { note: 'G5', freq: 783.99 },
                    { note: 'Bb5', freq: 932.33 },
                    { note: 'C6', freq: 1046.50 }
                ];
                
                // å’ŒéŸ³é€²è¡Œï¼ˆç¥ç§˜çš„ãªéŸ¿ãï¼‰
                this.chordProgression = [
                    [261.63, 311.13, 392.00], // Cm
                    [293.66, 349.23, 440.00], // Dm
                    [311.13, 392.00, 466.16], // Eb
                    [349.23, 440.00, 523.25], // F
                    [392.00, 466.16, 587.33], // G
                    [466.16, 587.33, 698.46], // Bb
                    [523.25, 659.25, 783.99], // C
                    [392.00, 493.88, 587.33]  // G7
                ];
                
                this.currentArpeggioIndex = 0;
                this.currentChordIndex = 0;
                this.arpeggioTimer = 0;
                this.chordTimer = 0;
            }
            
            startBGM() {
                if (!this.audioContext || this.bgmPlaying) return;
                
                try {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.bgmPlaying = true;
                    this.bgmGainNode = this.audioContext.createGain();
                    this.bgmGainNode.connect(this.audioContext.destination);
                    this.bgmGainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    
                    this.playArpeggio();
                    this.playChords();
                    
                } catch (e) {
                    console.log('BGM start failed');
                }
            }
            
            stopBGM() {
                if (!this.bgmPlaying) return;
                
                this.bgmPlaying = false;
                
                // å…¨ã¦ã®ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’åœæ­¢
                this.bgmOscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒæ—¢ã«åœæ­¢ã—ã¦ã„ã‚‹å ´åˆ
                    }
                });
                this.bgmOscillators = [];
                
                if (this.bgmGainNode) {
                    this.bgmGainNode.disconnect();
                    this.bgmGainNode = null;
                }
                
                clearTimeout(this.arpeggioTimer);
                clearTimeout(this.chordTimer);
            }
            
            playArpeggio() {
                if (!this.bgmPlaying || !this.audioContext) return;
                
                try {
                    // ä¸è¦å‰‡ãªéŸ³éšé¸æŠã§æµ®éŠæ„Ÿã‚’æ¼”å‡º
                    let note;
                    const rand = Math.random();
                    
                    if (rand < 0.4) {
                        // 40%ã®ç¢ºç‡ã§é †æ¬¡é€²è¡Œ
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                        this.currentArpeggioIndex = (this.currentArpeggioIndex + 1) % this.arpeggioPattern.length;
                    } else if (rand < 0.7) {
                        // 30%ã®ç¢ºç‡ã§å¤§ããã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆä¸Šæ˜‡ï¼‰
                        const jumpSize = 3 + Math.floor(Math.random() * 4); // 3-6éŸ³ç¨‹ã‚¸ãƒ£ãƒ³ãƒ—
                        this.currentArpeggioIndex = (this.currentArpeggioIndex + jumpSize) % this.arpeggioPattern.length;
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                    } else if (rand < 0.85) {
                        // 15%ã®ç¢ºç‡ã§ä¸‹é™ã‚¸ãƒ£ãƒ³ãƒ—
                        const jumpSize = 2 + Math.floor(Math.random() * 3); // 2-4éŸ³ç¨‹ä¸‹é™
                        this.currentArpeggioIndex = (this.currentArpeggioIndex - jumpSize + this.arpeggioPattern.length) % this.arpeggioPattern.length;
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                    } else {
                        // 15%ã®ç¢ºç‡ã§å®Œå…¨ã«ãƒ©ãƒ³ãƒ€ãƒ ãªéŸ³ç¨‹
                        this.currentArpeggioIndex = Math.floor(Math.random() * this.arpeggioPattern.length);
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                    }
                    
                    // ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ«ãƒšã‚¸ã‚ªéŸ³
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.bgmGainNode);
                    
                    // å¾®ç´°ãªãƒ”ãƒƒãƒãƒ™ãƒ³ãƒ‰ã§æµ®éŠæ„Ÿã‚’è¿½åŠ 
                    const pitchVariation = 1 + (Math.random() - 0.5) * 0.02; // Â±1%ã®ãƒ”ãƒƒãƒå¤‰å‹•
                    oscillator.frequency.setValueAtTime(note.freq * pitchVariation, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã§æŸ”ã‚‰ã‹ã„éŸ³è‰²
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(2000 + Math.random() * 1000, this.audioContext.currentTime);
                    filterNode.Q.setValueAtTime(0.5 + Math.random() * 1, this.audioContext.currentTime);
                    
                    // ä¸è¦å‰‡ãªã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ã§æµ®éŠæ„Ÿã‚’æ¼”å‡º
                    const attackTime = 0.05 + Math.random() * 0.15; // 0.05-0.2ç§’ã®ã‚¢ã‚¿ãƒƒã‚¯
                    const sustainTime = 0.8 + Math.random() * 0.8; // 0.8-1.6ç§’ã®ã‚µã‚¹ãƒ†ã‚£ãƒ³
                    const peakGain = 0.2 + Math.random() * 0.2; // 0.2-0.4ã®ãƒ”ãƒ¼ã‚¯ã‚²ã‚¤ãƒ³
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(peakGain, this.audioContext.currentTime + attackTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + attackTime + sustainTime);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + attackTime + sustainTime);
                    
                    this.bgmOscillators.push(oscillator);
                    
                    // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Šä¸‹ã®ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ï¼ˆç…Œã³ã‚„ã‹ã•ã‚’æ¼”å‡ºï¼‰
                    if (Math.random() > 0.4) {
                        const harmonyOsc = this.audioContext.createOscillator();
                        const harmonyGain = this.audioContext.createGain();
                        const harmonyFilter = this.audioContext.createBiquadFilter();
                        
                        harmonyOsc.connect(harmonyFilter);
                        harmonyFilter.connect(harmonyGain);
                        harmonyGain.connect(this.bgmGainNode);
                        
                        // ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Šä¸‹ã‚’é¸æŠ
                        const octaveMultiplier = Math.random() > 0.5 ? 2 : 0.5;
                        harmonyOsc.frequency.setValueAtTime(note.freq * octaveMultiplier * pitchVariation, this.audioContext.currentTime);
                        harmonyOsc.type = Math.random() > 0.5 ? 'triangle' : 'sine';
                        
                        harmonyFilter.type = 'lowpass';
                        harmonyFilter.frequency.setValueAtTime(2500 + Math.random() * 1500, this.audioContext.currentTime);
                        
                        const harmonyGainValue = 0.08 + Math.random() * 0.12;
                        harmonyGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        harmonyGain.gain.linearRampToValueAtTime(harmonyGainValue, this.audioContext.currentTime + 0.1 + Math.random() * 0.2);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6 + Math.random() * 0.8);
                        
                        const harmonyDelay = Math.random() * 0.3; // 0-0.3ç§’ã®é…å»¶
                        harmonyOsc.start(this.audioContext.currentTime + harmonyDelay);
                        harmonyOsc.stop(this.audioContext.currentTime + harmonyDelay + 0.6 + Math.random() * 0.8);
                        
                        this.bgmOscillators.push(harmonyOsc);
                    }
                    
                    // ä¸è¦å‰‡ãªé–“éš”ã§ã‚¢ãƒ«ãƒšã‚¸ã‚ªã‚’æ¼”å¥ï¼ˆæµ®éŠæ„Ÿã‚’å¼·åŒ–ï¼‰
                    const baseDelay = 150 + Math.random() * 200; // 150-350ms
                    const rhythmVariation = Math.random() > 0.8 ? Math.random() * 300 : 0; // 20%ã®ç¢ºç‡ã§å¤§ããªé–“éš”
                    const nextDelay = baseDelay + rhythmVariation;
                    
                    this.arpeggioTimer = setTimeout(() => this.playArpeggio(), nextDelay);
                    
                } catch (e) {
                    console.log('Arpeggio playback failed');
                }
            }
            
            playChords() {
                if (!this.bgmPlaying || !this.audioContext) return;
                
                try {
                    const chord = this.chordProgression[this.currentChordIndex];
                    
                    chord.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        const filterNode = this.audioContext.createBiquadFilter();
                        
                        oscillator.connect(filterNode);
                        filterNode.connect(gainNode);
                        gainNode.connect(this.bgmGainNode);
                        
                        oscillator.frequency.setValueAtTime(freq * 0.5, this.audioContext.currentTime); // ä½éŸ³åŸŸ
                        oscillator.type = 'sawtooth';
                        
                        // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã§æš–ã‹ã„éŸ³è‰²
                        filterNode.type = 'lowpass';
                        filterNode.frequency.setValueAtTime(800 + index * 200, this.audioContext.currentTime);
                        filterNode.Q.setValueAtTime(0.5, this.audioContext.currentTime);
                        
                        // é•·ã„ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼ˆãƒ‘ãƒƒãƒ‰çš„ãªéŸ¿ãï¼‰
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.08, this.audioContext.currentTime + 0.5);
                        gainNode.gain.linearRampToValueAtTime(0.06, this.audioContext.currentTime + 3.0);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 4.0);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 4.0);
                        
                        this.bgmOscillators.push(oscillator);
                    });
                    
                    // ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆåŠ¹æœéŸ³ï¼ˆå®‡å®™ã®ç¥ç§˜æ„Ÿï¼‰
                    if (Math.random() > 0.7) {
                        const ambientOsc = this.audioContext.createOscillator();
                        const ambientGain = this.audioContext.createGain();
                        const ambientFilter = this.audioContext.createBiquadFilter();
                        
                        ambientOsc.connect(ambientFilter);
                        ambientFilter.connect(ambientGain);
                        ambientGain.connect(this.bgmGainNode);
                        
                        ambientOsc.frequency.setValueAtTime(100 + Math.random() * 200, this.audioContext.currentTime);
                        ambientOsc.type = 'sine';
                        
                        ambientFilter.type = 'highpass';
                        ambientFilter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        
                        ambientGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        ambientGain.gain.linearRampToValueAtTime(0.03, this.audioContext.currentTime + 1.0);
                        ambientGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 3.0);
                        
                        ambientOsc.start(this.audioContext.currentTime + 0.5);
                        ambientOsc.stop(this.audioContext.currentTime + 3.0);
                        
                        this.bgmOscillators.push(ambientOsc);
                    }
                    
                    // æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¸
                    this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
                    
                    // ã‚³ãƒ¼ãƒ‰é€²è¡Œã®é–“éš”
                    this.chordTimer = setTimeout(() => this.playChords(), 4000);
                    
                } catch (e) {
                    console.log('Chord playback failed');
                }
            }
            

            
            loadRankings() {
                try {
                    const saved = localStorage.getItem('spaceShooterRankings');
                    this.rankings = saved ? JSON.parse(saved) : {
                        classic: [],
                        defense: [],
                        turnbased: [],
                        strategy: []
                    };
                    
                    // æ—§å½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ–°å½¢å¼ã«å¤‰æ›
                    if (Array.isArray(this.rankings)) {
                        const oldRankings = this.rankings;
                        this.rankings = {
                            classic: oldRankings.filter(r => r.gameMode === 'classic' || !r.gameMode),
                            defense: [],
                            turnbased: [],
                            strategy: []
                        };
                        this.saveRankings();
                    }
                } catch (e) {
                    this.rankings = {
                        classic: [],
                        defense: [],
                        turnbased: [],
                        strategy: []
                    };
                }
            }
            
            saveRankings() {
                try {
                    localStorage.setItem('spaceShooterRankings', JSON.stringify(this.rankings));
                } catch (e) {
                    console.log('Failed to save rankings');
                }
            }
            
            addToRanking(score, difficulty, gameMode) {
                const newRecord = {
                    score: score,
                    difficulty: difficulty,
                    gameMode: gameMode,
                    date: new Date().toLocaleDateString('ja-JP')
                };
                
                // è©²å½“ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«è¿½åŠ 
                if (!this.rankings[gameMode]) {
                    this.rankings[gameMode] = [];
                }
                
                this.rankings[gameMode].push(newRecord);
                this.rankings[gameMode].sort((a, b) => b.score - a.score);
                this.rankings[gameMode] = this.rankings[gameMode].slice(0, 10); // ãƒˆãƒƒãƒ—10ã®ã¿ä¿æŒ
                
                this.saveRankings();
                return this.rankings[gameMode].findIndex(r => r === newRecord);
            }
            
            displayRankings(newRecordIndex = -1) {
                const rankingItems = document.getElementById('rankingItems');
                rankingItems.innerHTML = '';
                
                const currentRankings = this.rankings[this.gameMode] || [];
                
                if (currentRankings.length === 0) {
                    rankingItems.innerHTML = '<div style="text-align: center; color: #666;">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                    return;
                }
                
                currentRankings.forEach((record, index) => {
                    const item = document.createElement('div');
                    item.className = 'ranking-item';
                    if (index === newRecordIndex) {
                        item.classList.add('new-record');
                    }
                    
                    const difficultyColors = {
                        easy: '#00ff00',
                        normal: '#ffff00',
                        hard: '#ff8800',
                        expert: '#ff4400',
                        nightmare: '#ff0000'
                    };
                    
                    const difficultyNames = {
                        easy: 'EASY',
                        normal: 'NORMAL',
                        hard: 'HARD',
                        expert: 'EXPERT',
                        nightmare: 'NIGHTMARE'
                    };
                    
                    item.innerHTML = `
                        <span>${index + 1}. ${record.score.toLocaleString()}ç‚¹</span>
                        <span style="color: ${difficultyColors[record.difficulty] || '#ffffff'}">
                            ${difficultyNames[record.difficulty] || record.difficulty.toUpperCase()}
                        </span>
                    `;
                    
                    rankingItems.appendChild(item);
                });
            }
            
            playBeep(frequency = 440, duration = 100, type = 'sine') {
                if (!this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (e) {
                    console.log('Audio playback failed');
                }
            }
            
            initializeStars() {
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 2 + 1
                    });
                }
            }
            
            initializeEarthSurface() {
                const segments = 20;
                const segmentWidth = this.canvas.width / segments;
                
                for (let i = 0; i <= segments; i++) {
                    this.earthSurface.push({
                        x: i * segmentWidth,
                        y: this.canvas.height - 50 + Math.sin(i * 0.5) * 20, // æ³¢çŠ¶ã®åœ°å½¢ã‚’å¾©æ´»
                        buildings: Math.random() < 0.4, // ãƒ©ãƒ³ãƒ€ãƒ ã«å»ºç‰©ã‚’é…ç½®ï¼ˆ40%ã®ç¢ºç‡ï¼‰
                        buildingHeight: Math.random() * 30 + 20 // å»ºç‰©ã®é«˜ã•ã‚‚ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
                    });
                }
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    if (e.code === 'Escape') {
                        if (this.gameState === 'gameOver' || this.gameState === 'ending' || this.gameState === 'returnToBase') {
                            this.backToTitle();
                        } else {
                            this.togglePause();
                        }
                    }
                    
                    if (e.code === 'Space') {
                        if (this.gameState === 'gameOver') {
                            this.restartSameDifficulty();
                        } else if (this.gameState === 'ending') {
                            this.startEndlessMode();
                        } else if (this.gameState === 'returnToBase') {
                            this.proceedToNextDay();
                        }
                    }
                    
                    // æ‰‹æŒã¡ã‚¢ã‚¤ãƒ†ãƒ ã®ä½¿ç”¨ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
                    if (this.gameState === 'playing' && (this.gameMode === 'turnbased' || this.gameMode === 'strategy')) {
                        if (e.code === 'KeyQ') {
                            this.useInventoryItem('explosion');
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth - 4;
                    this.canvas.height = window.innerHeight - 4;
                });
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                });
            }
            
            setupMobileControls() {
                const controlButtons = document.querySelectorAll('.control-btn');
                
                controlButtons.forEach(button => {
                    const key = button.getAttribute('data-key');
                    
                    // ã‚¿ãƒƒãƒé–‹å§‹
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys[key] = true;
                        
                        // ãƒ¢ãƒã‚¤ãƒ«ã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æœ‰åŠ¹åŒ–
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                        
                        if (key === 'Space' && this.gameState === 'gameOver') {
                            this.restartSameDifficulty();
                        }
                    });
                    
                    // ã‚¿ãƒƒãƒçµ‚äº†
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                    
                    // ã‚¿ãƒƒãƒã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    button.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                    
                    // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã®ãƒ†ã‚¹ãƒˆç”¨ï¼‰
                    button.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.keys[key] = true;
                        
                        if (key === 'Space' && this.gameState === 'gameOver') {
                            this.restartSameDifficulty();
                        }
                    });
                    
                    button.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                    
                    button.addEventListener('mouseleave', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                });
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                // ãƒ•ãƒ¬ãƒ¼ãƒ æ¯ã®ãƒ’ãƒƒãƒˆçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.enemies.forEach(enemy => {
                    enemy.hitThisFrame = false;
                });
                
                this.updatePlayer();
                this.applyActiveEffects && this.applyActiveEffects();
                this.updateBullets();
                this.updateEnemies();
                this.updateExplosions();
                this.updateStars();
                this.updatePowerups();
                this.updateGridItems();
                this.updateMapEffects();
                this.spawnEnemies();
                this.spawnPowerups();
                this.checkCollisions();
                this.updateLevel();
            }
            
            updatePlayer() {
                let moved = false;
                let shot = false;
                
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    // ã‚°ãƒªãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ã®ç§»å‹•ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
                    if (!this.playerMoved) {
                        if (this.keys['ArrowLeft'] && this.player.gridX > 0) {
                            this.player.gridX--;
                            this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                            moved = true;
                            this.keys['ArrowLeft'] = false; // ã‚­ãƒ¼å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
                        }
                        if (this.keys['ArrowRight'] && this.player.gridX < this.gridWidth - 1) {
                            this.player.gridX++;
                            this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                            moved = true;
                            this.keys['ArrowRight'] = false;
                        }
                        if (this.keys['ArrowUp'] && this.player.gridY > 0) {
                            this.player.gridY--;
                            this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                            moved = true;
                            this.keys['ArrowUp'] = false;
                        }
                        if (this.keys['ArrowDown'] && this.player.gridY < this.gridHeight - 2) {
                            this.player.gridY++;
                            this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                            moved = true;
                            this.keys['ArrowDown'] = false;
                        }
                        
                        if (this.keys['Space']) {
                            this.shootAllWeapons();
                            shot = true;
                            this.keys['Space'] = false;
                        }
                        
                        // ç§»å‹•ã¾ãŸã¯å°„æ’ƒã—ãŸå ´åˆã®å‡¦ç†
                        if (moved || shot) {
                            this.playerMoved = true;
                            // æ•µã®è¡Œå‹•ã‚’å®Ÿè¡Œ
                            this.processEnemyTurnMovement();
                            // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æŒç¶šæ™‚é–“ã‚’æ¸›ã‚‰ã™ï¼ˆã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ï¼‰
                            this.updateTurnBasedEffects();
                        }
                    }
                } else {
                    // é€šå¸¸ã®ç§»å‹•ï¼ˆã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ»åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ï¼‰
                    if (this.keys['ArrowLeft'] && this.player.x > 0) {
                        this.player.x -= this.player.speed;
                    }
                    if (this.keys['ArrowRight'] && this.player.x < this.canvas.width - this.player.width) {
                        this.player.x += this.player.speed;
                    }
                    if (this.keys['ArrowUp'] && this.player.y > 0) {
                        this.player.y -= this.player.speed;
                    }
                    if (this.keys['ArrowDown'] && this.player.y < this.canvas.height - this.player.height - 60) {
                        this.player.y += this.player.speed;
                    }
                    
                    if (this.keys['Space']) {
                        this.shootAllWeapons();
                    }
                }
                
                // ã‚·ãƒ¼ãƒ«ãƒ‰æ™‚é–“ã®æ›´æ–°
                if (this.player.shield && this.player.shieldTime > 0) {
                    this.player.shieldTime--;
                    if (this.player.shieldTime <= 0) {
                        this.player.shield = false;
                    }
                }
            }
            
            processEnemyTurnMovement() {
                // æ•µã¯2ã‚¿ãƒ¼ãƒ³ã«1å›ã®ã¿è¡Œå‹•ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã‚¿ãƒ¼ãƒ³ï¼šæ•µ1ã‚¿ãƒ¼ãƒ³ï¼‰
                const shouldEnemyAct = this.turnCount % 2 === 0;
                
                // å‡çµåŠ¹æœä¸­ã§ã‚‚æ•µã®è¡Œå‹•ã¯åœæ­¢ã™ã‚‹ãŒã€ã‚¿ãƒ¼ãƒ³ã¯é€²è¡Œã™ã‚‹
                if (!this.mapEffects.freeze.active && shouldEnemyAct) {
                    // æ•µã‚’é€†é †ã§å‡¦ç†ï¼ˆå‰Šé™¤æ™‚ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãšã‚Œã‚’é˜²ãï¼‰
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        
                        // æ™‚é–“æ¸›é€ŸåŠ¹æœï¼šã•ã‚‰ã«è¡Œå‹•é »åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆ4ã‚¿ãƒ¼ãƒ³ã«1å›ï¼‰
                        if (this.mapEffects.slowTime.active) {
                            if (!this.enemyTurnSkip[i]) {
                                this.enemyTurnSkip[i] = 0;
                            }
                            this.enemyTurnSkip[i]++;
                            
                            // 4ã‚¿ãƒ¼ãƒ³ã«1å›ã®ã¿ç§»å‹•ã‚’è¨±å¯
                            if (this.enemyTurnSkip[i] % 4 !== 0) {
                                continue; // ã“ã®ã‚¿ãƒ¼ãƒ³ã¯ç§»å‹•ã—ãªã„
                            }
                        }
                        
                        if (enemy.type === 'enemy_bullet') {
                            // æ•µã®å¼¾ã¯ä¸‹ã«å‘ã‹ã£ã¦ç§»å‹•
                            if (enemy.gridY !== undefined) {
                                enemy.gridY++;
                                enemy.y = enemy.gridY * this.gridSize + this.gridSize/2 - enemy.height/2;
                            } else {
                                enemy.y += this.gridSize; // ã‚°ãƒªãƒƒãƒ‰1ã¤åˆ†ç§»å‹•
                            }
                        } else {
                            // é€šå¸¸ã®æ•µã¯ã‚°ãƒªãƒƒãƒ‰1ã¤åˆ†ä¸‹ã«ç§»å‹•
                            if (enemy.gridY !== undefined) {
                                const newGridY = enemy.gridY + 1;
                                let newGridX = enemy.gridX;
                                
                                // ã‚¸ã‚°ã‚¶ã‚°æ•µã®ç‰¹æ®Šç§»å‹•ï¼ˆç¢ºç‡ã‚’ä¸‹ã’ã¦å‡¦ç†è² è·è»½æ¸›ï¼‰
                                if (enemy.type === 'zigzag' && Math.random() < 0.3) {
                                    const direction = Math.random() < 0.5 ? -1 : 1;
                                    const candidateGridX = enemy.gridX + direction;
                                    if (candidateGridX >= 0 && candidateGridX < this.gridWidth) {
                                        // ç°¡å˜ãªé‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ï¼‰
                                        let occupied = false;
                                        for (let j = 0; j < this.enemies.length; j++) {
                                            if (j !== i && this.enemies[j].gridX === candidateGridX && this.enemies[j].gridY === newGridY) {
                                                occupied = true;
                                                break;
                                            }
                                        }
                                        if (!occupied) {
                                            newGridX = candidateGridX;
                                        }
                                    }
                                }
                                
                                // ç§»å‹•å…ˆã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡ç•¥åŒ–ï¼‰
                                let canMove = true;
                                for (let j = 0; j < this.enemies.length; j++) {
                                    if (j !== i && this.enemies[j].gridX === newGridX && this.enemies[j].gridY === newGridY) {
                                        canMove = false;
                                        break;
                                    }
                                }
                                
                                if (canMove) {
                                    enemy.gridY = newGridY;
                                    enemy.gridX = newGridX;
                                    enemy.x = enemy.gridX * this.gridSize + this.gridSize/2 - enemy.width/2;
                                    enemy.y = enemy.gridY * this.gridSize + this.gridSize/2 - enemy.height/2;
                                }
                            } else {
                                enemy.y += this.gridSize; // ã‚°ãƒªãƒƒãƒ‰1ã¤åˆ†ç§»å‹•
                            }
                            
                            // å°„æ’ƒæ•µã®æ”»æ’ƒï¼ˆç¢ºç‡ã‚’ä¸‹ã’ã¦å‡¦ç†è² è·è»½æ¸›ï¼‰
                            if (enemy.type === 'shooter' && Math.random() < 0.2) {
                                this.enemyShoot(enemy);
                            }
                        }
                    }
                }
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã®æ–°ã—ã„æ•µã®å‡ºç¾ï¼ˆæ•µãŒè¡Œå‹•ã™ã‚‹ã‚¿ãƒ¼ãƒ³ã®ã¿ï¼‰
                if (shouldEnemyAct) {
                    this.spawnTurnBasedEnemies();
                }
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ï¼ˆæ¯ã‚¿ãƒ¼ãƒ³åˆ¤å®šï¼‰
                this.spawnTurnBasedItems();
                
                // ã‚¿ãƒ¼ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—åŠ ã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.turnCount++;
                this.playerMoved = false;
            }
            
            spawnTurnBasedEnemies() {
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã®æ•µå‡ºç¾ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•å¾Œï¼‰
                const baseSpawnRate = 0.3; // åŸºæœ¬30%ã®å‡ºç¾ç‡
                const levelBonus = this.level * 0.02; // ãƒ¬ãƒ™ãƒ«ãƒœãƒ¼ãƒŠã‚¹ï¼ˆæ§ãˆã‚ã«ï¼‰
                const spawnRate = Math.min(baseSpawnRate + levelBonus, 0.6); // æœ€å¤§60%ã¾ã§
                
                // 1ã‚¿ãƒ¼ãƒ³ã«æœ€å¤§2ä½“ã¾ã§å‡ºç¾
                const maxEnemies = Math.min(1 + Math.floor(this.level / 5), 2);
                
                // åˆ©ç”¨å¯èƒ½ãªã‚°ãƒªãƒƒãƒ‰ä½ç½®ã‚’äº‹å‰ã«è¨ˆç®—
                const availablePositions = [];
                for (let y = 0; y < 3; y++) { // ä¸Šéƒ¨3è¡Œã®ã¿
                    for (let x = 0; x < this.gridWidth; x++) {
                        if (!this.isGridOccupiedByEnemy(x, y)) {
                            availablePositions.push({ x, y });
                        }
                    }
                }
                
                // åˆ©ç”¨å¯èƒ½ãªä½ç½®ãŒãªã„å ´åˆã¯æ—©æœŸçµ‚äº†
                if (availablePositions.length === 0) {
                    return;
                }
                
                let currentSpawnRate = spawnRate;
                for (let spawn = 0; spawn < maxEnemies && availablePositions.length > 0; spawn++) {
                    if (Math.random() < currentSpawnRate) {
                        const enemyType = this.getRandomEnemyType();
                        const enemyData = this.getEnemyData(enemyType);
                        
                        // ãƒ©ãƒ³ãƒ€ãƒ ã«ä½ç½®ã‚’é¸æŠ
                        const positionIndex = Math.floor(Math.random() * availablePositions.length);
                        const position = availablePositions[positionIndex];
                        
                        // é¸æŠã—ãŸä½ç½®ã‚’åˆ©ç”¨å¯èƒ½ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
                        availablePositions.splice(positionIndex, 1);
                        
                        let enemy = {
                            x: position.x * this.gridSize + this.gridSize/2 - enemyData.width/2,
                            y: position.y * this.gridSize + this.gridSize/2 - enemyData.height/2,
                            width: enemyData.width,
                            height: enemyData.height,
                            speed: enemyData.speed,
                            type: enemyType,
                            health: Math.ceil(enemyData.health * this.difficultySettings.enemyHealthMultiplier),
                            lastShot: 0,
                            shootCooldown: enemyData.shootCooldown || 0,
                            gridX: position.x,
                            gridY: position.y
                        };
                        
                        this.enemies.push(enemy);
                        
                        // ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã®é€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                        if (this.gameMode === 'strategy' && Math.random() < 0.1) {
                            const enemyMessages = {
                                heavy: 'é‡è£…ç”²å‹æ•µæ©Ÿã‚’ç¢ºèªï¼',
                                shooter: 'å°„æ’ƒå‹æ•µæ©Ÿæ¥è¿‘ä¸­ï¼',
                                fast: 'é«˜é€Ÿå‹æ•µæ©Ÿã‚’æ¢çŸ¥ï¼',
                                zigzag: 'ä¸è¦å‰‡æ©Ÿå‹•å‹æ•µæ©Ÿã‚’ç¢ºèª'
                            };
                            
                            if (enemyMessages[enemyType]) {
                                this.addCommMessage(enemyMessages[enemyType], 'warning');
                            }
                        }
                    }
                    
                    // è¤‡æ•°æ•µå‡ºç¾æ™‚ã¯ç¢ºç‡ã‚’ä¸‹ã’ã‚‹
                    currentSpawnRate *= 0.7;
                }
            }
            
            shootAllWeapons() {
                const now = Date.now();
                const centerX = this.player.x + this.player.width / 2;
                const centerY = this.player.y;
                
                // é€£å°„å¼·åŒ–åŠ¹æœ
                const cooldownMultiplier = this.mapEffects.rapidFire.active ? 0.3 : 1;
                
                // åŸºæœ¬å°„æ’ƒ
                if (this.weapons.basicShot.level > 0 && now - this.weapons.basicShot.lastShot > this.weapons.basicShot.cooldown * cooldownMultiplier) {
                    this.shootBasic(centerX, centerY);
                    this.weapons.basicShot.lastShot = now;
                }
                
                // æ‹¡æ•£å°„æ’ƒ
                if (this.weapons.spreadShot.level > 0 && now - this.weapons.spreadShot.lastShot > this.weapons.spreadShot.cooldown * cooldownMultiplier) {
                    this.shootSpread(centerX, centerY);
                    this.weapons.spreadShot.lastShot = now;
                }
                
                // ãƒ¬ãƒ¼ã‚¶ãƒ¼
                if (this.weapons.laser.level > 0 && now - this.weapons.laser.lastShot > this.weapons.laser.cooldown * cooldownMultiplier) {
                    this.shootLaser(centerX, centerY);
                    this.weapons.laser.lastShot = now;
                }
                
                // ãƒŸã‚µã‚¤ãƒ«
                if (this.weapons.missile.level > 0 && now - this.weapons.missile.lastShot > this.weapons.missile.cooldown * cooldownMultiplier) {
                    this.shootMissile(centerX, centerY);
                    this.weapons.missile.lastShot = now;
                }
                
                // è»Œé“å¼¾
                if (this.weapons.orbit.level > 0 && now - this.weapons.orbit.lastShot > this.weapons.orbit.cooldown * cooldownMultiplier) {
                    this.shootOrbit();
                    this.weapons.orbit.lastShot = now;
                }
                
                // è²«é€šå¼¾
                if (this.weapons.piercing.level > 0 && now - this.weapons.piercing.lastShot > this.weapons.piercing.cooldown * cooldownMultiplier) {
                    this.shootPiercing(centerX, centerY);
                    this.weapons.piercing.lastShot = now;
                }
                
                // è¿½å°¾å¼¾
                if (this.weapons.homing.level > 0 && now - this.weapons.homing.lastShot > this.weapons.homing.cooldown * cooldownMultiplier) {
                    this.shootHoming(centerX, centerY);
                    this.weapons.homing.lastShot = now;
                }
                
                // ãƒãƒªã‚¢
                if (this.weapons.barrier.level > 0 && now - this.weapons.barrier.lastShot > this.weapons.barrier.cooldown * cooldownMultiplier) {
                    this.shootBarrier();
                    this.weapons.barrier.lastShot = now;
                }
            }
            
            shootBasic(x, y) {
                const level = this.weapons.basicShot.level;
                const bulletCount = Math.min(level, 3);
                
                for (let i = 0; i < bulletCount; i++) {
                    const offsetX = (i - (bulletCount - 1) / 2) * 15;
                    this.bullets.push({
                        x: x + offsetX,
                        y: y,
                        speed: 8 + level,
                        width: 3 + level,
                        height: 10 + level * 2,
                        damage: level,
                        type: 'basic',
                        color: '#ffff00'
                    });
                }
                this.playBeep(800, 50, 'square');
            }
            
            shootSpread(x, y) {
                const level = this.weapons.spreadShot.level;
                const bulletCount = 3 + level * 2;
                const angleSpread = Math.PI / 3;
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = -angleSpread/2 + (angleSpread / (bulletCount - 1)) * i;
                    this.bullets.push({
                        x: x,
                        y: y,
                        speed: 6 + level,
                        width: 4,
                        height: 8,
                        damage: level,
                        type: 'spread',
                        angle: angle,
                        color: '#ff8800'
                    });
                }
                this.playBeep(700, 80, 'sawtooth');
            }
            
            shootLaser(x, y) {
                const level = this.weapons.laser.level;
                this.bullets.push({
                    x: x - 2,
                    y: y,
                    speed: 15,
                    width: 4 + level * 2,
                    height: this.canvas.height,
                    damage: level * 3,
                    type: 'laser',
                    life: 10,
                    color: '#00ffff'
                });
                this.playBeep(1200, 100, 'sine');
            }
            
            shootMissile(x, y) {
                const level = this.weapons.missile.level;
                const missileCount = Math.min(level, 3);
                
                for (let i = 0; i < missileCount; i++) {
                    this.bullets.push({
                        x: x + (i - 1) * 20,
                        y: y,
                        speed: 4,
                        width: 8,
                        height: 16,
                        damage: level * 5,
                        type: 'missile',
                        explosionRadius: 30 + level * 10,
                        color: '#ff0000'
                    });
                }
                this.playBeep(400, 200, 'sawtooth');
            }
            
            shootOrbit() {
                const level = this.weapons.orbit.level;
                if (this.orbitingBullets.length < level * 2) {
                    this.orbitingBullets.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: 50 + level * 10,
                        speed: 0.1,
                        damage: level * 2,
                        size: 6 + level * 2
                    });
                }
            }
            
            shootPiercing(x, y) {
                const level = this.weapons.piercing.level;
                this.bullets.push({
                    x: x,
                    y: y,
                    speed: 10,
                    width: 6,
                    height: 20,
                    damage: level * 2,
                    type: 'piercing',
                    pierceCount: level * 2,
                    color: '#00ff00'
                });
                this.playBeep(900, 60, 'triangle');
            }
            
            shootHoming(x, y) {
                const level = this.weapons.homing.level;
                this.bullets.push({
                    x: x,
                    y: y,
                    speed: 5,
                    width: 8,
                    height: 12,
                    damage: level * 3,
                    type: 'homing',
                    target: null,
                    turnSpeed: 0.1 + level * 0.02,
                    angle: -Math.PI / 2,
                    color: '#ff00ff'
                });
                this.playBeep(600, 100, 'sine');
            }
            
            shootBarrier() {
                const level = this.weapons.barrier.level;
                if (this.barrierBullets.length < level * 4) {
                    for (let i = 0; i < 4; i++) {
                        this.barrierBullets.push({
                            angle: (Math.PI / 2) * i,
                            distance: 60,
                            damage: level,
                            life: 300,
                            size: 8
                        });
                    }
                }
            }
            
            updateBullets() {
                // é€šå¸¸å¼¾ã®æ›´æ–°
                this.bullets = this.bullets.filter(bullet => {
                    if (bullet.type === 'spread') {
                        bullet.x += Math.sin(bullet.angle) * bullet.speed;
                        bullet.y -= Math.cos(bullet.angle) * bullet.speed;
                    } else if (bullet.type === 'laser') {
                        bullet.life--;
                        return bullet.life > 0;
                    } else if (bullet.type === 'homing') {
                        this.updateHomingBullet(bullet);
                    } else {
                        bullet.y -= bullet.speed;
                    }
                    
                    return bullet.y > -bullet.height && bullet.x > -bullet.width && bullet.x < this.canvas.width + bullet.width;
                });
                
                // è»Œé“å¼¾ã®æ›´æ–°
                this.orbitingBullets.forEach(orbit => {
                    orbit.angle += orbit.speed;
                });
                
                // ãƒãƒªã‚¢å¼¾ã®æ›´æ–°
                this.barrierBullets = this.barrierBullets.filter(barrier => {
                    barrier.life--;
                    return barrier.life > 0;
                });
            }
            
            updateHomingBullet(bullet) {
                // æœ€ã‚‚è¿‘ã„æ•µã‚’æ¢ã™
                let closestEnemy = null;
                let closestDistance = Infinity;
                
                this.enemies.forEach(enemy => {
                    const dx = enemy.x + enemy.width/2 - bullet.x;
                    const dy = enemy.y + enemy.height/2 - bullet.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEnemy = enemy;
                    }
                });
                
                if (closestEnemy) {
                    const dx = closestEnemy.x + closestEnemy.width/2 - bullet.x;
                    const dy = closestEnemy.y + closestEnemy.height/2 - bullet.y;
                    const targetAngle = Math.atan2(dx, -dy);
                    
                    // è§’åº¦ã‚’å¾ã€…ã«èª¿æ•´
                    let angleDiff = targetAngle - bullet.angle;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    bullet.angle += angleDiff * bullet.turnSpeed;
                }
                
                bullet.x += Math.sin(bullet.angle) * bullet.speed;
                bullet.y -= Math.cos(bullet.angle) * bullet.speed;
            }
            
            spawnEnemies() {
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ•µã®å‡ºç¾ã‚’åˆ¶é™
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã§ã¯è‡ªå‹•çš„ãªæ•µå‡ºç¾ã¯è¡Œã‚ãªã„
                    // æ•µã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•å¾Œã«ã®ã¿å‡ºç¾ï¼ˆprocessEnemyTurnMovementé–¢æ•°ã§å‡¦ç†ï¼‰
                    return;
                }
                
                if (Math.random() < this.difficultySettings.enemySpawnRate + this.level * 0.005) {
                    const enemyType = this.getRandomEnemyType();
                    const enemyData = this.getEnemyData(enemyType);
                    
                    // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ•µã®é€Ÿåº¦ã‚’èª¿æ•´
                    let speedMultiplier = this.difficultySettings.enemySpeedMultiplier;
                    if (this.gameMode === 'defense') {
                        // ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªé€Ÿåº¦èª¿æ•´ï¼ˆãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å¾ã€…ã«å¢—åŠ ï¼‰
                        const baseSpeed = this.difficultySettings.defenseSpeedMultiplier;
                        const levelBonus = Math.min(this.level * 0.05, 0.3); // æœ€å¤§30%ã¾ã§å¢—åŠ 
                        speedMultiplier = baseSpeed + levelBonus;
                        
                        // ç‰¹æ®Šãªæ•µã‚¿ã‚¤ãƒ—ã®å‡ºç¾æ™‚ã«é€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                        if (Math.random() < 0.1) { // 10%ã®ç¢ºç‡ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                            const enemyMessages = {
                                heavy: 'é‡è£…ç”²å‹æ•µæ©Ÿã‚’ç¢ºèªï¼é›†ä¸­æ”»æ’ƒã‚’æ¨å¥¨',
                                shooter: 'å°„æ’ƒå‹æ•µæ©Ÿæ¥è¿‘ä¸­ï¼å›é¿è¡Œå‹•ã‚’å–ã£ã¦ãã ã•ã„',
                                fast: 'é«˜é€Ÿå‹æ•µæ©Ÿã‚’æ¢çŸ¥ï¼è¿æ’ƒæº–å‚™',
                                zigzag: 'ä¸è¦å‰‡æ©Ÿå‹•å‹æ•µæ©Ÿã‚’ç¢ºèª'
                            };
                            
                            if (enemyMessages[enemyType]) {
                                this.addCommMessage(enemyMessages[enemyType], 'warning');
                            }
                        }
                    }
                    
                    let enemy = {
                        x: Math.random() * (this.canvas.width - enemyData.width),
                        y: -enemyData.height,
                        width: enemyData.width,
                        height: enemyData.height,
                        speed: (enemyData.speed + this.level * 0.2) * speedMultiplier,
                        type: enemyType,
                        health: Math.ceil(enemyData.health * this.difficultySettings.enemyHealthMultiplier),
                        lastShot: 0,
                        shootCooldown: enemyData.shootCooldown || 0
                    };
                    
                    this.enemies.push(enemy);
                }
            }
            
            getRandomEnemyType() {
                const rand = Math.random();
                if (rand < 0.4) return 'normal';
                if (rand < 0.6) return 'fast';
                if (rand < 0.75) return 'heavy';
                if (rand < 0.9) return 'shooter';
                return 'zigzag';
            }
            
            getEnemyData(type) {
                const enemyTypes = {
                    normal: { width: 40, height: 30, speed: 1.5, health: 1, points: 100 },
                    fast: { width: 30, height: 25, speed: 3, health: 1, points: 200 },
                    heavy: { width: 50, height: 40, speed: 0.8, health: 3, points: 300 },
                    shooter: { width: 45, height: 35, speed: 1, health: 2, points: 250, shootCooldown: 1500 },
                    zigzag: { width: 35, height: 28, speed: 2, health: 1, points: 150 }
                };
                return enemyTypes[type] || enemyTypes.normal;
            }
            
            spawnPowerups() {
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯è‡ªå‹•çš„ãªã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ã¯è¡Œã‚ãªã„
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    // ã‚¢ã‚¤ãƒ†ãƒ ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•å¾Œã«ã®ã¿å‡ºç¾ï¼ˆspawnTurnBasedItemsé–¢æ•°ã§å‡¦ç†ï¼‰
                    return;
                } else {
                    // é€šå¸¸ã®ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¹ãƒãƒ¼ãƒ³ï¼ˆã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ»åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ï¼‰
                    if (Math.random() < this.difficultySettings.powerupSpawnRate) {
                        const weaponTypes = Object.keys(this.weapons);
                        const availableWeapons = weaponTypes.filter(weapon => this.weapons[weapon].level < this.weapons[weapon].maxLevel);
                        
                        let type;
                        
                        // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§åœ°çƒHPãŒä½ã„å ´åˆã€åœ°çƒå›å¾©ã‚¢ã‚¤ãƒ†ãƒ ã®å‡ºç¾ç‡ã‚’å¤§å¹…ã«ä¸Šã’ã‚‹
                        if (this.gameMode === 'defense' && this.earthHealth < this.maxEarthHealth) {
                            const healthRatio = this.earthHealth / this.maxEarthHealth;
                            let healEarthChance = 0.15; // åŸºæœ¬15%
                            
                            if (healthRatio < 0.3) {
                                healEarthChance = 0.4; // åœ°çƒHP30%ä»¥ä¸‹ã§40%
                            } else if (healthRatio < 0.6) {
                                healEarthChance = 0.25; // åœ°çƒHP60%ä»¥ä¸‹ã§25%
                            }
                            
                            if (Math.random() < healEarthChance) {
                                type = 'healEarth';
                            }
                        }
                        
                        // åœ°çƒå›å¾©ã‚¢ã‚¤ãƒ†ãƒ ãŒé¸ã°ã‚Œãªã‹ã£ãŸå ´åˆã®é€šå¸¸å‡¦ç†
                        if (!type) {
                            if (availableWeapons.length > 0 && Math.random() < 0.7) {
                                // 70%ã®ç¢ºç‡ã§æ­¦å™¨å¼·åŒ–
                                type = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                            } else {
                                // 30%ã®ç¢ºç‡ã§ãã®ä»–ã®ã‚¢ã‚¤ãƒ†ãƒ 
                                let otherTypes = ['shield', 'life', 'speed'];
                                
                                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§ã¯åœ°çƒå›å¾©ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ ï¼ˆé€šå¸¸ç¢ºç‡ï¼‰
                                if (this.gameMode === 'defense' && this.earthHealth < this.maxEarthHealth) {
                                    otherTypes.push('healEarth');
                                }
                                
                                type = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                            }
                        }
                        
                        this.powerups.push({
                            x: Math.random() * (this.canvas.width - 30),
                            y: -30,
                            width: 30,
                            height: 30,
                            speed: 2,
                            type: type,
                            rotation: 0,
                            pulseTime: 0 // ãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨
                        });
                    }
                }
            }
            

            
            giveInitialInventoryItems() {
                // é›£æ˜“åº¦ã«å¿œã˜ã¦åˆæœŸã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä»˜ä¸
                const explosionCounts = {
                    easy: 5,
                    normal: 3,
                    hard: 2,
                    expert: 1,
                    nightmare: 1
                };
                
                this.inventory.explosion = explosionCounts[this.difficulty] || 3;
                this.updateInventoryUI();
                
                // åˆæœŸã‚¢ã‚¤ãƒ†ãƒ ä»˜ä¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                this.showMapEffect(`ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ x${this.inventory.explosion} æ”¯çµ¦ï¼`, '#ff8800');
            }
            
            spawnInitialGridItems() {
                // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«åˆæœŸã‚¢ã‚¤ãƒ†ãƒ ã‚’2-4å€‹é…ç½®
                const initialItemCount = 2 + Math.floor(Math.random() * 3); // 2-4å€‹
                
                for (let i = 0; i < initialItemCount; i++) {
                    const weaponTypes = Object.keys(this.weapons);
                    const availableWeapons = weaponTypes.filter(weapon => this.weapons[weapon].level < this.weapons[weapon].maxLevel);
                    
                    let type;
                    if (availableWeapons.length > 0 && Math.random() < 0.8) {
                        // 80%ã®ç¢ºç‡ã§æ­¦å™¨å¼·åŒ–
                        type = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    } else {
                        // 20%ã®ç¢ºç‡ã§ãã®ä»–ã®ã‚¢ã‚¤ãƒ†ãƒ 
                        const otherTypes = ['shield', 'life', 'speed'];
                        type = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                    }
                    
                    // ç©ºã„ã¦ã„ã‚‹ã‚°ãƒªãƒƒãƒ‰ä½ç½®ã‚’æ¢ã™
                    let attempts = 0;
                    let gridX, gridY;
                    do {
                        gridX = Math.floor(Math.random() * this.gridWidth);
                        gridY = Math.floor(Math.random() * (this.gridHeight - 5)) + 2; // ä¸Šéƒ¨2è¡Œã¨ä¸‹éƒ¨3è¡Œã‚’é¿ã‘ã‚‹
                        attempts++;
                    } while (this.isGridOccupied(gridX, gridY) && attempts < 50);
                    
                    if (attempts < 50) {
                        this.gridItems.push({
                            gridX: gridX,
                            gridY: gridY,
                            x: gridX * this.gridSize + this.gridSize/2 - 15,
                            y: gridY * this.gridSize + this.gridSize/2 - 15,
                            width: 30,
                            height: 30,
                            type: type,
                            rotation: 0,
                            pulseTime: 0
                        });
                    }
                }
            }
            
            spawnTurnBasedItems() {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¡Œå‹•ã—ãŸå¾Œã«ç¢ºç‡ã§ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾
                if (Math.random() < 0.15) { // 15%ã®ç¢ºç‡ã§ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾
                    const specialItemTypes = [
                        'freeze', 'slowTime', 'mapShield', 'doubleScore', 'rapidFire',
                        'invincible', 'magneticField', 'energyStorm', 'explosion', 'timeWarp',
                        'healEarth', 'barrierWall', 'lightningStrike', 'gravityWell'
                    ];
                    
                    const weaponTypes = Object.keys(this.weapons);
                    const availableWeapons = weaponTypes.filter(weapon => this.weapons[weapon].level < this.weapons[weapon].maxLevel);
                    
                    let type;
                    if (Math.random() < 0.6 && specialItemTypes.length > 0) {
                        // 60%ã®ç¢ºç‡ã§ç‰¹æ®Šã‚¢ã‚¤ãƒ†ãƒ 
                        type = specialItemTypes[Math.floor(Math.random() * specialItemTypes.length)];
                    } else if (availableWeapons.length > 0 && Math.random() < 0.8) {
                        // 32%ã®ç¢ºç‡ã§æ­¦å™¨å¼·åŒ–
                        type = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    } else {
                        // 8%ã®ç¢ºç‡ã§ãã®ä»–ã®ã‚¢ã‚¤ãƒ†ãƒ 
                        const otherTypes = ['shield', 'life', 'speed'];
                        type = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                    }
                    
                    // ç©ºã„ã¦ã„ã‚‹ã‚°ãƒªãƒƒãƒ‰ä½ç½®ã‚’æ¢ã™
                    let attempts = 0;
                    let gridX, gridY;
                    do {
                        gridX = Math.floor(Math.random() * this.gridWidth);
                        gridY = Math.floor(Math.random() * (this.gridHeight - 5)) + 2; // ä¸Šéƒ¨2è¡Œã¨ä¸‹éƒ¨3è¡Œã‚’é¿ã‘ã‚‹
                        attempts++;
                    } while (this.isGridOccupied(gridX, gridY) && attempts < 20);
                    
                    if (attempts < 20) {
                        this.gridItems.push({
                            gridX: gridX,
                            gridY: gridY,
                            x: gridX * this.gridSize + this.gridSize/2 - 15,
                            y: gridY * this.gridSize + this.gridSize/2 - 15,
                            width: 30,
                            height: 30,
                            type: type,
                            rotation: 0,
                            pulseTime: 0
                        });
                    }
                }
            }
            
            isGridOccupied(gridX, gridY) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯
                if (gridX === this.player.gridX && gridY === this.player.gridY) {
                    return true;
                }
                
                // æ•µã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯
                for (let enemy of this.enemies) {
                    if (enemy.gridX === gridX && enemy.gridY === gridY) {
                        return true;
                    }
                }
                
                // æ—¢å­˜ã®ã‚°ãƒªãƒƒãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒã‚§ãƒƒã‚¯
                for (let item of this.gridItems) {
                    if (item.gridX === gridX && item.gridY === gridY) {
                        return true;
                    }
                }
                
                return false;
            }
            
            isGridOccupiedByEnemy(gridX, gridY) {
                // æ•µã®ä½ç½®ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆæ•µã®ã‚¹ãƒãƒ¼ãƒ³æ™‚ã«ä½¿ç”¨ï¼‰
                for (let enemy of this.enemies) {
                    if (enemy.gridX === gridX && enemy.gridY === gridY) {
                        return true;
                    }
                }
                return false;
            }
            

            
            updateEnemies() {
                this.enemies = this.enemies.filter(enemy => {
                    // ãƒãƒƒãƒ—åŠ¹æœã«ã‚ˆã‚‹æ•µã®è¡Œå‹•åˆ¶é™
                    let canMove = true;
                    let speedMultiplier = 1;
                    
                    if (this.mapEffects.freeze.active) {
                        canMove = false;
                    }
                    if (this.mapEffects.slowTime.active) {
                        speedMultiplier = 0.3;
                    }
                    
                    // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ•µã®è‡ªå‹•ç§»å‹•ã‚’åœæ­¢ã€å‡çµåŠ¹æœã‚‚é©ç”¨
                    if ((this.gameMode === 'classic' || this.gameMode === 'defense') && canMove) {
                        // æ•µã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³
                        if (enemy.type === 'zigzag') {
                            enemy.x += Math.sin(enemy.y * 0.02) * 2 * speedMultiplier;
                            if (enemy.x < 0) enemy.x = 0;
                            if (enemy.x > this.canvas.width - enemy.width) enemy.x = this.canvas.width - enemy.width;
                        }
                        
                        enemy.y += enemy.speed * speedMultiplier;
                        
                        // å°„æ’ƒæ•µã®æ”»æ’ƒï¼ˆå‡çµä¸­ã¯æ”»æ’ƒã—ãªã„ï¼‰
                        if (enemy.type === 'shooter' && enemy.shootCooldown && Date.now() - enemy.lastShot > enemy.shootCooldown) {
                            this.enemyShoot(enemy);
                            enemy.lastShot = Date.now();
                        }
                    }
                    
                    // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§æ•µãŒç”»é¢ä¸‹éƒ¨ã«åˆ°é”ã—ãŸå ´åˆ
                    if ((this.gameMode === 'defense' || this.gameMode === 'strategy')) {
                        const bottomBoundary = this.gameMode === 'strategy' || this.gameMode === 'turnbased' ? 
                                             (this.gridHeight - 2) * this.gridSize : this.canvas.height - 60;
                        
                        if (enemy.y + enemy.height >= bottomBoundary) {
                            this.damageEarth(enemy);
                            return false; // æ•µã‚’å‰Šé™¤
                        }
                    }
                    
                    // ç”»é¢å¤–åˆ¤å®š
                    const screenBottom = this.gameMode === 'turnbased' || this.gameMode === 'strategy' ? 
                                       this.gridHeight * this.gridSize : this.canvas.height + enemy.height;
                    
                    return enemy.y < screenBottom;
                });
            }
            
            damageEarth(enemy) {
                const damage = this.getEnemyDamage(enemy.type);
                this.earthHealth -= damage;
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸è¡¨ç¤º
                this.showEarthDamage(damage);
                
                // é€šä¿¡ãƒ­ã‚°ã«ãƒ€ãƒ¡ãƒ¼ã‚¸å ±å‘Šã‚’è¿½åŠ 
                this.addCommMessage(`åœ°çƒã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ HP-${damage} (æ®‹ã‚Š${this.earthHealth})`, 'urgent');
                
                // åœ°çƒHPçŠ¶æ³ã«å¿œã˜ãŸé€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                const healthRatio = this.earthHealth / this.maxEarthHealth;
                if (healthRatio <= 0.2 && healthRatio > 0) {
                    this.addCommMessage('ç·Šæ€¥äº‹æ…‹ï¼åœ°çƒã®é˜²è­·ã‚·ãƒ¼ãƒ«ãƒ‰ãŒé™ç•Œã§ã™ï¼', 'urgent');
                } else if (healthRatio <= 0.5) {
                    this.addCommMessage('è­¦å‘Šï¼šåœ°çƒã®é˜²è­·ã‚·ã‚¹ãƒ†ãƒ ãŒå±é™ºãƒ¬ãƒ™ãƒ«ã§ã™', 'warning');
                } else if (healthRatio <= 0.7) {
                    this.addCommMessage('åœ°çƒã®é˜²è­·ã‚·ã‚¹ãƒ†ãƒ ã«æå‚·ã‚’ç¢ºèª', 'warning');
                }
                
                // åœ°çƒãƒ€ãƒ¡ãƒ¼ã‚¸éŸ³
                this.playBeep(150, 300, 'sawtooth');
                
                if (this.earthHealth <= 0) {
                    this.earthHealth = 0;
                    this.addCommMessage('åœ°çƒé˜²è­·ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨åœæ­¢...ä½œæˆ¦å¤±æ•—', 'urgent');
                    this.gameOver();
                }
            }
            
            getEnemyDamage(enemyType) {
                const damageMap = {
                    normal: 5,
                    fast: 3,
                    heavy: 10,
                    shooter: 7,
                    zigzag: 4,
                    enemy_bullet: 1
                };
                return damageMap[enemyType] || 5;
            }
            
            showEarthDamage(damage) {
                const indicator = document.createElement('div');
                indicator.className = 'earth-damage-indicator';
                indicator.textContent = `-${damage}`;
                document.getElementById('gameContainer').appendChild(indicator);
                
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 500);
            }
            
            enemyShoot(enemy) {
                let bullet = {
                    x: enemy.x + enemy.width/2 - 3,
                    y: enemy.y + enemy.height,
                    width: 6,
                    height: 12,
                    speed: 3,
                    type: 'enemy_bullet',
                    health: 1
                };
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã‚’è¿½åŠ 
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    bullet.gridX = enemy.gridX;
                    bullet.gridY = enemy.gridY + 1;
                    bullet.x = bullet.gridX * this.gridSize + this.gridSize/2 - bullet.width/2;
                    bullet.y = bullet.gridY * this.gridSize + this.gridSize/2 - bullet.height/2;
                }
                
                this.enemies.push(bullet);
                this.playBeep(300, 50, 'square');
            }
            
            updatePowerups() {
                this.powerups = this.powerups.filter(powerup => {
                    powerup.y += powerup.speed;
                    powerup.rotation += 0.03; // å›è»¢é€Ÿåº¦ã‚’å¤§å¹…ã«æ¸›é€Ÿï¼ˆ0.1 â†’ 0.03ï¼‰
                    powerup.pulseTime += 0.15; // ãƒ‘ãƒ«ã‚¹åŠ¹æœç”¨
                    return powerup.y < this.canvas.height + powerup.height;
                });
            }
            
            updateGridItems() {
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.gridItems.forEach(item => {
                        item.rotation += 0.02; // å›è»¢é€Ÿåº¦ã‚’æ¸›é€Ÿï¼ˆ0.05 â†’ 0.02ï¼‰
                        item.pulseTime += 0.08; // ãƒ‘ãƒ«ã‚¹é€Ÿåº¦ã‚‚å°‘ã—æ¸›é€Ÿï¼ˆ0.1 â†’ 0.08ï¼‰
                    });
                }
            }
            
            updateTurnBasedEffects() {
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
                Object.keys(this.mapEffects).forEach(effectName => {
                    const effect = this.mapEffects[effectName];
                    if (effect.active && effect.duration > 0) {
                        effect.duration--;
                        if (effect.duration <= 0) {
                            effect.active = false;
                            // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ çµ‚äº†æ™‚ã®ç‰¹åˆ¥å‡¦ç†
                            if (effectName === 'energyStorm') {
                                this.showMapEffect('ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ çµ‚äº†', '#666666');
                            }
                        }
                    }
                });
                
                // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ ã®ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹å°‚ç”¨ï¼‰
                if (this.mapEffects.energyStorm.active) {
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        if (enemy.type !== 'enemy_bullet' && 
                            enemy.y >= 0 && enemy.y < this.canvas.height &&
                            enemy.x >= 0 && enemy.x < this.canvas.width &&
                            Math.random() < 0.3) {
                            
                            enemy.health -= 1;
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(i, 1);
                                this.playBeep(600, 50, 'triangle');
                            }
                        }
                    }
                }
            }
            
            updateMapEffects() {
                // ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ»åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ¸›ã‚‰ã™ï¼ˆ60FPSã§1ç§’ = 60ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                if (this.gameMode === 'classic' || this.gameMode === 'defense') {
                    Object.keys(this.mapEffects).forEach(effectName => {
                        const effect = this.mapEffects[effectName];
                        if (effect.active && effect.duration > 0) {
                            effect.duration--;
                            if (effect.duration <= 0) {
                                effect.active = false;
                                // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ çµ‚äº†æ™‚ã®ç‰¹åˆ¥å‡¦ç†
                                if (effectName === 'energyStorm') {
                                    this.showMapEffect('ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ çµ‚äº†', '#666666');
                                }
                            }
                        }
                    });
                    
                    // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ ã®ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ¼ãƒ‰ï¼‰
                    if (this.mapEffects.energyStorm.active) {
                        for (let i = this.enemies.length - 1; i >= 0; i--) {
                            const enemy = this.enemies[i];
                            if (enemy.type !== 'enemy_bullet' && 
                                enemy.y >= 0 && enemy.y < this.canvas.height &&
                                enemy.x >= 0 && enemy.x < this.canvas.width &&
                                Math.random() < 0.005) { // ãƒ•ãƒ¬ãƒ¼ãƒ æ¯ãªã®ã§ç¢ºç‡ã‚’ä¸‹ã’ã‚‹
                                
                                enemy.health -= 1;
                                this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                
                                if (enemy.health <= 0) {
                                    this.addScore(enemy.type);
                                    this.enemies.splice(i, 1);
                                    this.playBeep(600, 50, 'triangle');
                                }
                            }
                        }
                    }
                }
            }
            

            

            
            updateExplosions() {
                this.explosions = this.explosions.filter(explosion => {
                    explosion.time++;
                    explosion.radius += 2;
                    return explosion.time < 20;
                });
            }
            
            updateStars() {
                this.stars.forEach(star => {
                    star.y += star.speed;
                    if (star.y > this.canvas.height) {
                        star.y = -5;
                        star.x = Math.random() * this.canvas.width;
                    }
                });
            }
            
            checkCollisions() {
                // å¼¾ã¨æ•µã®è¡çª
                this.bullets.forEach((bullet, bulletIndex) => {
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (this.isColliding(bullet, enemy) && !enemy.hitThisFrame) {
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemy.health -= bullet.damage || 1;
                            enemy.hitThisFrame = true; // é‡è¤‡ãƒ’ãƒƒãƒˆé˜²æ­¢
                            
                            // æ•µã‚’å€’ã—ãŸå ´åˆã®ã‚¹ã‚³ã‚¢åŠ ç®—
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(enemyIndex, 1);
                                this.playBeep(600, 100, 'triangle');
                            } else {
                                this.playBeep(1000, 30, 'sine');
                            }
                            
                            // ãƒŸã‚µã‚¤ãƒ«ã®çˆ†ç™ºãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆç›´æ’ƒå¾Œã«çˆ†ç™ºï¼‰
                            if (bullet.type === 'missile') {
                                this.createMissileExplosion(bullet.x, bullet.y, bullet.explosionRadius, bullet.damage);
                            }
                            
                            // è²«é€šå¼¾ä»¥å¤–ã¯å‰Šé™¤
                            if (bullet.type !== 'piercing' || bullet.pierceCount <= 0) {
                                this.bullets.splice(bulletIndex, 1);
                            } else if (bullet.type === 'piercing') {
                                bullet.pierceCount--;
                            }
                        }
                    });
                });
                
                // è»Œé“å¼¾ã¨æ•µã®è¡çª
                this.orbitingBullets.forEach((orbit, orbitIndex) => {
                    const orbitX = this.player.x + this.player.width/2 + Math.cos(orbit.angle) * orbit.distance;
                    const orbitY = this.player.y + this.player.height/2 + Math.sin(orbit.angle) * orbit.distance;
                    
                    this.enemies.forEach((enemy, enemyIndex) => {
                        const dx = orbitX - (enemy.x + enemy.width/2);
                        const dy = orbitY - (enemy.y + enemy.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < orbit.size + enemy.width/2 && !enemy.hitThisFrame) {
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemy.health -= orbit.damage;
                            enemy.hitThisFrame = true; // é‡è¤‡ãƒ’ãƒƒãƒˆé˜²æ­¢
                            
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(enemyIndex, 1);
                                this.playBeep(600, 100, 'triangle');
                            }
                        }
                    });
                });
                
                // ãƒãƒªã‚¢å¼¾ã¨æ•µã®è¡çª
                this.barrierBullets.forEach((barrier, barrierIndex) => {
                    const barrierX = this.player.x + this.player.width/2 + Math.cos(barrier.angle) * barrier.distance;
                    const barrierY = this.player.y + this.player.height/2 + Math.sin(barrier.angle) * barrier.distance;
                    
                    this.enemies.forEach((enemy, enemyIndex) => {
                        const dx = barrierX - (enemy.x + enemy.width/2);
                        const dy = barrierY - (enemy.y + enemy.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < barrier.size + enemy.width/2 && !enemy.hitThisFrame) {
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemy.health -= barrier.damage;
                            enemy.hitThisFrame = true; // é‡è¤‡ãƒ’ãƒƒãƒˆé˜²æ­¢
                            
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(enemyIndex, 1);
                                this.playBeep(600, 100, 'triangle');
                            }
                        }
                    });
                });
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ•µã®è¡çª
                this.enemies.forEach((enemy, enemyIndex) => {
                    if (this.isColliding(this.player, enemy)) {
                        if (!this.player.shield && !this.mapEffects.shield.active && !this.mapEffects.invincible.active) {
                            this.createExplosion(this.player.x + this.player.width/2, this.player.y + this.player.height/2);
                            this.lives--;
                            this.enemies.splice(enemyIndex, 1);
                            
                            // ãƒ€ãƒ¡ãƒ¼ã‚¸éŸ³ï¼ˆä½éŸ³ã®è­¦å‘ŠéŸ³ï¼‰
                            this.playBeep(200, 300, 'sawtooth');
                            
                            if (this.lives <= 0) {
                                this.gameOver();
                            }
                        } else {
                            // ã‚·ãƒ¼ãƒ«ãƒ‰ã¾ãŸã¯ç„¡æ•µã§é˜²å¾¡
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            this.enemies.splice(enemyIndex, 1);
                            this.playBeep(400, 100, 'triangle');
                        }
                    }
                });
                

                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã®è¡çª
                this.powerups.forEach((powerup, powerupIndex) => {
                    if (this.isColliding(this.player, powerup)) {
                        this.applyPowerup(powerup.type);
                        this.powerups.splice(powerupIndex, 1);
                        
                        // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—å–å¾—éŸ³
                        this.playBeep(800, 100, 'sine');
                        setTimeout(() => this.playBeep(1000, 100, 'sine'), 100);
                    }
                });
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚°ãƒªãƒƒãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ã®è¡çªï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.gridItems.forEach((item, itemIndex) => {
                        if (item.gridX === this.player.gridX && item.gridY === this.player.gridY) {
                            this.applyGridItem(item.type);
                            this.gridItems.splice(itemIndex, 1);
                            
                            // ç‰¹æ®Šã‚¢ã‚¤ãƒ†ãƒ å–å¾—éŸ³
                            this.playBeep(600, 80, 'sine');
                            setTimeout(() => this.playBeep(800, 80, 'sine'), 80);
                            setTimeout(() => this.playBeep(1000, 120, 'sine'), 160);
                        }
                    });
                }
            }
            
            applyPowerup(type) {
                if (this.weapons[type]) {
                    // æ­¦å™¨å¼·åŒ–
                    if (this.weapons[type].level < this.weapons[type].maxLevel) {
                        this.weapons[type].level++;
                        const weaponNames = {
                            basicShot: 'åŸºæœ¬å°„æ’ƒ',
                            spreadShot: 'æ‹¡æ•£å°„æ’ƒ',
                            laser: 'ãƒ¬ãƒ¼ã‚¶ãƒ¼',
                            missile: 'ãƒŸã‚µã‚¤ãƒ«',
                            orbit: 'è»Œé“å¼¾',
                            piercing: 'è²«é€šå¼¾',
                            homing: 'è¿½å°¾å¼¾',
                            barrier: 'ãƒãƒªã‚¢'
                        };
                        this.showMapEffect(`${weaponNames[type] || type} Lv.${this.weapons[type].level}`, '#00ff00');
                        
                        // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§æ­¦å™¨å¼·åŒ–æ™‚ã®é€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                        if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                            this.addCommMessage(`æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ å¼·åŒ–å®Œäº†ï¼š${weaponNames[type]}`, 'normal');
                        }
                    }
                } else {
                    // ãã®ä»–ã®ã‚¢ã‚¤ãƒ†ãƒ 
                    switch (type) {
                        case 'shield':
                            this.player.shield = true;
                            this.player.shieldTime = 300;
                            this.showMapEffect('ã‚·ãƒ¼ãƒ«ãƒ‰å–å¾—ï¼', '#00ffff');
                            this.addCommMessage('é˜²è­·ã‚·ãƒ¼ãƒ«ãƒ‰å±•é–‹å®Œäº†', 'normal');
                            break;
                        case 'life':
                            this.lives++;
                            this.showMapEffect('ãƒ©ã‚¤ãƒ•+1ï¼', '#ff0080');
                            this.addCommMessage('äºˆå‚™æ©Ÿä½“ãŒåˆ°ç€ã—ã¾ã—ãŸ', 'normal');
                            break;
                        case 'speed':
                            this.player.speed = Math.min(this.player.speed + 1, 10);
                            this.showMapEffect('ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ï¼', '#88ff00');
                            this.addCommMessage('æ¨é€²ã‚·ã‚¹ãƒ†ãƒ å¼·åŒ–å®Œäº†', 'normal');
                            break;
                        case 'healEarth':
                            if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                                const oldHealth = this.earthHealth;
                                this.earthHealth = Math.min(this.earthHealth + 30, this.maxEarthHealth);
                                const actualHeal = this.earthHealth - oldHealth;
                                this.showMapEffect('åœ°çƒå›å¾©+30ï¼', '#00ff00');
                                this.addCommMessage(`åœ°çƒé˜²è­·ã‚·ã‚¹ãƒ†ãƒ ä¿®å¾©å®Œäº† HP+${actualHeal}`, 'normal');
                            }
                            break;
                    }
                }
            }
            
            applyGridItem(type) {
                if (this.weapons[type]) {
                    // æ­¦å™¨å¼·åŒ–
                    if (this.weapons[type].level < this.weapons[type].maxLevel) {
                        this.weapons[type].level++;
                        const weaponNames = {
                            basicShot: 'åŸºæœ¬å°„æ’ƒ',
                            spreadShot: 'æ‹¡æ•£å°„æ’ƒ',
                            laser: 'ãƒ¬ãƒ¼ã‚¶ãƒ¼',
                            missile: 'ãƒŸã‚µã‚¤ãƒ«',
                            orbit: 'è»Œé“å¼¾',
                            piercing: 'è²«é€šå¼¾',
                            homing: 'è¿½å°¾å¼¾',
                            barrier: 'ãƒãƒªã‚¢'
                        };
                        this.showMapEffect(`${weaponNames[type] || type} Lv.${this.weapons[type].level}`, '#00ff00');
                    }
                } else {
                    // ç‰¹æ®Šã‚¢ã‚¤ãƒ†ãƒ ã®åŠ¹æœ
                    switch (type) {
                        case 'freeze':
                            this.mapEffects.freeze.active = true;
                            this.mapEffects.freeze.duration = 3; // 3ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('æ•µå…¨ä½“å‡çµï¼', '#00ffff');
                            break;
                        case 'slowTime':
                            this.mapEffects.slowTime.active = true;
                            this.mapEffects.slowTime.duration = 5; // 5ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('æ™‚é–“æ¸›é€Ÿï¼', '#ffff00');
                            break;
                        case 'mapShield':
                            this.mapEffects.shield.active = true;
                            this.mapEffects.shield.duration = 10; // 10ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('å…¨ä½“ã‚·ãƒ¼ãƒ«ãƒ‰ï¼', '#00ffff');
                            break;
                        case 'doubleScore':
                            this.mapEffects.doubleScore.active = true;
                            this.mapEffects.doubleScore.duration = 10; // 10ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('ã‚¹ã‚³ã‚¢2å€ï¼', '#ffff00');
                            break;
                        case 'rapidFire':
                            this.mapEffects.rapidFire.active = true;
                            this.mapEffects.rapidFire.duration = 5; // 5ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('é€£å°„å¼·åŒ–ï¼', '#ff8800');
                            break;
                        case 'invincible':
                            this.mapEffects.invincible.active = true;
                            this.mapEffects.invincible.duration = 3; // 3ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('ç„¡æ•µçŠ¶æ…‹ï¼', '#ff00ff');
                            break;
                        case 'magneticField':
                            this.mapEffects.magneticField.active = true;
                            this.mapEffects.magneticField.duration = 6; // 6ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('ç£åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼', '#8800ff');
                            break;
                        case 'energyStorm':
                            this.mapEffects.energyStorm.active = true;
                            this.mapEffects.energyStorm.duration = 4; // 4ã‚¿ãƒ¼ãƒ³
                            this.showMapEffect('ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ ï¼', '#ff4400');
                            break;
                        case 'explosion':
                            this.activateExplosion();
                            this.showMapEffect('ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ï¼', '#ff0000');
                            break;
                        case 'timeWarp':
                            this.activateTimeWarp();
                            this.showMapEffect('æ™‚ç©ºæ­ªæ›²ï¼', '#ff00ff');
                            break;
                        case 'healEarth':
                            if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                                this.earthHealth = Math.min(this.earthHealth + 30, this.maxEarthHealth);
                                this.showMapEffect('åœ°çƒå›å¾©+30ï¼', '#00ff00');
                            }
                            break;
                        case 'barrierWall':
                            this.activateBarrierWall();
                            this.showMapEffect('ãƒãƒªã‚¢å£ï¼', '#00ffff');
                            break;
                        case 'lightningStrike':
                            this.activateLightningStrike();
                            this.showMapEffect('é›·æ’ƒï¼', '#ffff00');
                            break;
                        case 'gravityWell':
                            this.activateGravityWell();
                            this.showMapEffect('é‡åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼', '#8800ff');
                            break;
                        // é€šå¸¸ã‚¢ã‚¤ãƒ†ãƒ 
                        case 'shield':
                            this.player.shield = true;
                            this.player.shieldTime = 300;
                            this.showMapEffect('ã‚·ãƒ¼ãƒ«ãƒ‰å–å¾—ï¼', '#00ffff');
                            break;
                        case 'life':
                            this.lives++;
                            this.showMapEffect('ãƒ©ã‚¤ãƒ•+1ï¼', '#ff0080');
                            break;
                        case 'speed':
                            this.player.speed = Math.min(this.player.speed + 1, 10);
                            this.showMapEffect('ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ï¼', '#88ff00');
                            break;
                        case 'healEarth':
                            if (this.gameMode === 'defense') {
                                this.earthHealth = Math.min(this.earthHealth + 30, this.maxEarthHealth);
                                this.showMapEffect('åœ°çƒå›å¾©+30ï¼', '#00ff00');
                            }
                            break;
                    }
                }
            }
            
            showMapEffect(text, color) {
                const effectDiv = document.createElement('div');
                effectDiv.style.position = 'absolute';
                effectDiv.style.top = '50%';
                effectDiv.style.left = '50%';
                effectDiv.style.transform = 'translate(-50%, -50%)';
                effectDiv.style.color = color;
                effectDiv.style.fontSize = '32px';
                effectDiv.style.fontWeight = 'bold';
                effectDiv.style.textShadow = `0 0 20px ${color}`;
                effectDiv.style.zIndex = '25';
                effectDiv.style.pointerEvents = 'none';
                effectDiv.style.animation = 'mapEffectFade 2s ease-out forwards';
                effectDiv.textContent = text;
                
                document.getElementById('gameContainer').appendChild(effectDiv);
                
                setTimeout(() => {
                    if (effectDiv.parentNode) {
                        effectDiv.parentNode.removeChild(effectDiv);
                    }
                }, 2000);
            }
            
            activateExplosion() {
                // ç”»é¢ä¸Šã®å…¨ã¦ã®æ•µã‚’ç ´å£Š
                this.enemies.forEach(enemy => {
                    this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    this.addScore(enemy.type);
                });
                this.enemies = [];
                
                // å¤§çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.createExplosion(
                            Math.random() * this.canvas.width,
                            Math.random() * this.canvas.height
                        );
                    }, i * 100);
                }
                
                // å¤§çˆ†ç™ºéŸ³
                this.playBeep(50, 1000, 'sawtooth');
            }
            
            activateTimeWarp() {
                // æ•µã‚’éå»ã®ä½ç½®ã«æˆ»ã™
                this.enemies.forEach(enemy => {
                    if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                        enemy.gridY = Math.max(0, enemy.gridY - 3);
                        enemy.y = enemy.gridY * this.gridSize + this.gridSize/2 - enemy.height/2;
                    } else {
                        enemy.y = Math.max(-enemy.height, enemy.y - 150);
                    }
                });
            }
            
            activateBarrierWall() {
                // ç”»é¢ä¸‹éƒ¨ã«ãƒãƒªã‚¢å¼¾ã‚’é…ç½®
                const barrierY = this.gameMode === 'turnbased' || this.gameMode === 'strategy' ? 
                                this.gridHeight - 4 : this.canvas.height - 200;
                
                for (let i = 0; i < 10; i++) {
                    this.barrierBullets.push({
                        angle: 0,
                        distance: 0,
                        damage: 2,
                        life: 600,
                        size: 12,
                        x: (this.canvas.width / 10) * i + 20,
                        y: barrierY,
                        fixed: true
                    });
                }
            }
            
            activateLightningStrike() {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªæ•µã«é›·æ’ƒ
                const targets = this.enemies.filter(enemy => enemy.type !== 'enemy_bullet');
                for (let i = 0; i < Math.min(5, targets.length); i++) {
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    this.createExplosion(target.x + target.width/2, target.y + target.height/2);
                    target.health -= 5;
                    
                    if (target.health <= 0) {
                        this.addScore(target.type);
                        const index = this.enemies.indexOf(target);
                        if (index > -1) {
                            this.enemies.splice(index, 1);
                        }
                    }
                }
                
                // é›·éŸ³
                this.playBeep(1500, 200, 'square');
            }
            
            activateGravityWell() {
                // å…¨ã¦ã®æ•µã‚’ç”»é¢ä¸­å¤®ã«å¼•ãå¯„ã›ã‚‹
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.enemies.forEach(enemy => {
                    const dx = centerX - (enemy.x + enemy.width/2);
                    const dy = centerY - (enemy.y + enemy.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance > 0) {
                        const pullStrength = 0.3;
                        enemy.x += dx * pullStrength;
                        enemy.y += dy * pullStrength;
                        
                        // ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã‚‚æ›´æ–°
                        if (enemy.gridX !== undefined) {
                            enemy.gridX = Math.floor(enemy.x / this.gridSize);
                            enemy.gridY = Math.floor(enemy.y / this.gridSize);
                        }
                    }
                });
            }
            
            useInventoryItem(itemType) {
                if (this.inventory[itemType] <= 0) {
                    // ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´åˆã®è­¦å‘ŠéŸ³
                    this.playBeep(200, 100, 'square');
                    return;
                }
                
                // ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆè²»
                this.inventory[itemType]--;
                this.updateInventoryUI();
                
                // ã‚¢ã‚¤ãƒ†ãƒ åŠ¹æœã‚’ç™ºå‹•
                switch (itemType) {
                    case 'explosion':
                        this.activateExplosion();
                        this.showMapEffect('ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³ç™ºå‹•ï¼', '#ff0000');
                        break;
                }
                
                // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨éŸ³
                this.playBeep(800, 100, 'sine');
                setTimeout(() => this.playBeep(1000, 100, 'sine'), 100);
                setTimeout(() => this.playBeep(1200, 150, 'sine'), 200);
            }
            
            isColliding(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            createExplosion(x, y) {
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: 5,
                    time: 0,
                    type: 'normal'
                });
                
                // çˆ†ç™ºéŸ³ï¼ˆä½éŸ³ã®ãƒã‚¤ã‚ºï¼‰
                this.playBeep(150, 200, 'sawtooth');
            }
            
            addScore(enemyType) {
                const scoreMap = {
                    normal: 100,
                    fast: 200,
                    heavy: 300,
                    shooter: 250,
                    zigzag: 150,
                    enemy_bullet: 25
                };
                
                let points = scoreMap[enemyType] || 100;
                
                // ã‚¹ã‚³ã‚¢2å€åŠ¹æœ
                if (this.mapEffects.doubleScore.active) {
                    points *= 2;
                }
                
                // å…¨ãƒ¢ãƒ¼ãƒ‰ã§çµ±ä¸€ã•ã‚ŒãŸã‚¹ã‚³ã‚¢åŠ ç®—ï¼ˆæ•´æ•°å€¤ã®ã¿ï¼‰
                this.score += Math.floor(points);
            }
            
            createMissileExplosion(x, y, radius, damage) {
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: radius,
                    time: 0,
                    type: 'missile',
                    maxRadius: radius
                });
                
                // ç¯„å›²å†…ã®æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                this.enemies.forEach((enemy, enemyIndex) => {
                    const dx = enemy.x + enemy.width/2 - x;
                    const dy = enemy.y + enemy.height/2 - y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < radius && !enemy.hitThisFrame) {
                        enemy.health -= damage;
                        enemy.hitThisFrame = true; // é‡è¤‡ãƒ’ãƒƒãƒˆé˜²æ­¢
                        
                        if (enemy.health <= 0) {
                            this.addScore(enemy.type);
                            this.enemies.splice(enemyIndex, 1);
                        }
                    }
                });
                
                // å¤§ããªçˆ†ç™ºéŸ³
                this.playBeep(100, 300, 'sawtooth');
            }
            
            updateLevel() {
                const newLevel = Math.floor(this.score / 1000) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    
                    // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚ã®é€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                        const levelMessages = [
                            'ä½œæˆ¦ãƒ¬ãƒ™ãƒ«ä¸Šæ˜‡ï¼æ•µã®æ”»æ’ƒãŒæ¿€åŒ–ã—ã¾ã™',
                            'é˜²è¡›ã‚¯ãƒ«ãƒ¼ã€ç´ æ™´ã‚‰ã—ã„æˆ¦æœã§ã™ï¼',
                            'æ•µã®æ–°å‹æ©Ÿã‚’ç¢ºèªã€‚è­¦æˆ’ãƒ¬ãƒ™ãƒ«ã‚’ä¸Šã’ã¦ãã ã•ã„',
                            'åœ°çƒé˜²è¡›è»æœ¬éƒ¨ã‚ˆã‚Šã€ç¶™ç¶šã—ãŸé˜²è¡›ã‚’è¦è«‹',
                            'æ•µæ¯è‰¦æ¥è¿‘ã®å…†å€™ã‚ã‚Šã€‚æœ€å¤§è­¦æˆ’ã§è‡¨ã‚“ã§ãã ã•ã„'
                        ];
                        const randomMessage = levelMessages[Math.floor(Math.random() * levelMessages.length)];
                        this.addCommMessage(`ãƒ¬ãƒ™ãƒ«${newLevel}ï¼š${randomMessage}`, 'normal');
                    }
                    
                    // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—éŸ³ï¼ˆä¸Šæ˜‡éŸ³éšï¼‰
                    setTimeout(() => this.playBeep(500, 100, 'sine'), 0);
                    setTimeout(() => this.playBeep(600, 100, 'sine'), 100);
                    setTimeout(() => this.playBeep(700, 150, 'sine'), 200);
                }
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã®DAYé€²è¡Œãƒã‚§ãƒƒã‚¯
                this.checkDayProgression();
            }
            
            checkDayProgression() {
                if ((this.gameMode !== 'defense' && this.gameMode !== 'strategy') || this.endlessMode || this.dayCleared) return;
                
                const targetScore = this.dayTargetScores[this.currentDay];
                if (this.score >= targetScore) {
                    this.dayCleared = true;
                    
                    if (this.currentDay === 3) {
                        // DAY3ã‚¯ãƒªã‚¢ = ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
                        this.showEnding();
                    } else {
                        // DAY1,2ã‚¯ãƒªã‚¢ = æœ¬éƒ¨å¸°é‚„
                        this.showReturnToBase();
                    }
                }
            }
            
            showReturnToBase() {
                this.gameState = 'returnToBase';
                
                // BGMåœæ­¢
                this.stopBGM();
                
                // å¸°é‚„ç”»é¢ã®æƒ…å ±ã‚’è¨­å®š
                document.getElementById('dayCompleteTitle').textContent = `DAY ${this.currentDay} ã‚¯ãƒªã‚¢ï¼`;
                document.getElementById('returnScore').textContent = this.score.toLocaleString();
                document.getElementById('returnEarthHp').textContent = this.earthHealth;
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªã­ãã‚‰ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                this.displayRandomCongratsMessage();
                
                // å¸°é‚„ç”»é¢ã‚’è¡¨ç¤º
                document.getElementById('returnToBaseScreen').style.display = 'flex';
                
                // å¸°é‚„éŸ³ï¼ˆå‹åˆ©éŸ³éšï¼‰
                setTimeout(() => this.playBeep(600, 150, 'sine'), 0);
                setTimeout(() => this.playBeep(700, 150, 'sine'), 150);
                setTimeout(() => this.playBeep(800, 150, 'sine'), 300);
                setTimeout(() => this.playBeep(900, 200, 'sine'), 450);
            }
            
            displayRandomCongratsMessage() {
                const congratsMessages = [
                    // ä¼šè©±å‹
                    "ã€ŒãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼ç´ æ™´ã‚‰ã—ã„æˆ¦æœã§ã™ã€‚ã€\nã€Œæ¬¡ã®ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚‚é ¼ã¿ã¾ã™ã€‚ã€",
                    "ã€Œãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã€è¦‹äº‹ãªè…•å‰ã ã€‚ã€\nã€Œå›ã®ã‚ˆã†ãªäººæã‚’å¾…ã£ã¦ã„ãŸã€‚ã€",
                    "ã€Œä»Šå›ã®ä½œæˆ¦ã€å®Œç’§ã§ã—ãŸã­ã€‚ã€\nã€Œã§ã‚‚æ²¹æ–­ã¯ç¦ç‰©ã§ã™ã‚ˆã€‚ã€",
                    "ã€Œã‚„ã£ãŸã˜ã‚ƒãªã„ã§ã™ã‹ï¼ã€\nã€Œã“ã®èª¿å­ã§æ¬¡ã‚‚é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼ã€",
                    "ã€ŒæµçŸ³ã§ã™ã€ã‚¨ãƒ¼ã‚¹ã€‚ã€\nã€Œåœ°çƒã®å¸Œæœ›ã¯ã‚ãªãŸã§ã™ã€‚ã€",
                    
                    // å‘½ä»¤å‹
                    "ä½œæˆ¦å®Œäº†ã‚’ç¢ºèªã€‚æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œã›ã‚ˆã€‚",
                    "å„ªç§€ãªæˆ¦æœã‚’è¨˜éŒ²ã€‚å¼•ãç¶šãä»»å‹™ã‚’ç¶™ç¶šã•ã‚ŒãŸã—ã€‚",
                    "ç›®æ¨™é”æˆã€‚ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã¯çŸ­æ™‚é–“ã®ä¼‘æ¯å¾Œã€æ¬¡ã®ä½œæˆ¦ã«å‚åŠ ã›ã‚ˆã€‚",
                    "æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’è§£æä¸­ã€‚æ¬¡å›ã¯ã‚ˆã‚Šå›°é›£ãªä»»å‹™ãŒå¾…ã£ã¦ã„ã‚‹ã€‚",
                    "å¸ä»¤éƒ¨ã‚ˆã‚Šé€šé”ï¼šå›ã®æ´»èºã«ã‚ˆã‚Šä½œæˆ¦ã¯æˆåŠŸã—ãŸã€‚",
                    
                    // ãƒ•ã‚¡ãƒ³ã‚¿ã‚¸ãƒ¼é¢¨
                    "å‹‡è€…ã‚ˆã€è¦‹äº‹ãªæˆ¦ã„ã¶ã‚Šã§ã‚ã£ãŸã€‚\næ¬¡ãªã‚‹è©¦ç·´ãŒæ±ã‚’å¾…ã£ã¦ã„ã‚‹ã€‚",
                    "å…‰ã®æˆ¦å£«ã‚ˆã€é—‡ã‚’æ‰•ã„ã—åŠŸç¸¾ã€èª ã«è¦‹äº‹ãªã‚Šã€‚",
                    "æ˜Ÿã®åŠ è­·ã‚’å—ã‘ã—è€…ã‚ˆã€\nãã®åŠ›ã§å®‡å®™ã®å¹³å’Œã‚’å®ˆã‚Šçµ¦ãˆã€‚",
                    "å¤ã®äºˆè¨€ã®é€šã‚Šã€é¸ã°ã‚Œã—è€…ãŒç¾ã‚ŒãŸã€‚\né‹å‘½ã®æˆ¦ã„ã¯ã¾ã ç¶šãã€‚",
                    "é­”æ³•ã®åŠ›ãŒå›ã‚’å®ˆè­·ã—ã¦ã„ã‚‹ã€‚\næ¬¡ã®æˆ¦å ´ã§ã‚‚ãã®åŠ›ã‚’ç™ºæ®ã›ã‚ˆã€‚",
                    
                    // ãƒãƒƒãƒˆãƒŸãƒ¼ãƒ é¢¨
                    "ã¤ã‚ˆã„ï¼ˆç¢ºä¿¡ï¼‰\næ¬¡ã‚‚ã‚ˆã‚ã—ãã‚ªãƒŠã‚·ãƒ£ã‚¹ï¼",
                    "ãƒ•ã‚¡ãƒƒ!? å¼·ã™ãã§ã—ã‚‡...\nï¼ˆæ¬¡ã®DAYã§ï¼‰åˆ‡ã‚Šæ›¿ãˆã¦ã„ã",
                    "è‰ç”Ÿãˆã‚‹æˆ¦ã„ã¶ã‚Šã§è‰\næ¬¡ã‚‚æœŸå¾…ã—ã¦ã‚‹ã‚¾ã€œ",
                    "ã“ã‚Œã‚‚ã†ã‚ã‹ã‚“ã­ã‡ãªï¼ˆè¤’ã‚è¨€è‘‰ï¼‰\næ¬¡ã®DAYã‚‚é ¼ã‚€ã‚¾ã€œ",
                    "æœ‰èƒ½ğŸ‘\næ¬¡ã®ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚‚ãŒã‚“ã°ãƒ«ãƒ“ã‚£ï¼",
                    "ã‚„ã‚Šã¾ã™ã­ã‡ï¼\næ¬¡å›ã‚‚æ¥½ã—ã¿ã«ã—ã¦ã¾ã™ï¼ˆåŠã‚®ãƒ¬ï¼‰",
                    
                    // ç†±è¡€ç³»
                    "ç‡ƒãˆã‚‹ãœï¼ã“ã®èª¿å­ã§å®‡å®™ã‚’æ•‘ã†ã‚“ã ï¼",
                    "ã‚¢ãƒ„ã„æˆ¦ã„ã ã£ãŸï¼\næ¬¡ã¯ã‚‚ã£ã¨ç‡ƒãˆä¸ŠãŒã‚ã†ãœï¼",
                    "é­‚ã®æˆ¦ã„ã«æ„Ÿå‹•ã—ãŸï¼\nå›ã¨ãªã‚‰å®‡å®™ã‚‚æ•‘ãˆã‚‹ã•ï¼",
                    
                    // ã‚¯ãƒ¼ãƒ«ç³»
                    "...æ‚ªããªã„ã€‚\næ¬¡ã‚‚åŒã˜ãƒ¬ãƒ™ãƒ«ã‚’ç¶­æŒã—ã¦ã‚‚ã‚‰ãŠã†ã€‚",
                    "äºˆæƒ³é€šã‚Šã®çµæœã ã€‚\næ¬¡ã®ãƒŸãƒƒã‚·ãƒ§ãƒ³ã§ã‚‚æœŸå¾…ã—ã¦ã„ã‚‹ã€‚",
                    "è¨ˆç®—é€šã‚Šã€‚å›ã®å®ŸåŠ›ã¯æœ¬ç‰©ã®ã‚ˆã†ã ãªã€‚",
                    
                    // ãŠã‚‚ã—ã‚ç³»
                    "å®‡å®™äººã‚‚ãƒ“ãƒƒã‚¯ãƒªã®å¼·ã•ã§ã™ã­ï¼\næ¬¡ã®DAYã‚‚å®‡å®™äººã‚’ãƒ“ãƒƒã‚¯ãƒªã•ã›ã¡ã‚ƒã„ã¾ã—ã‚‡ã†ï¼",
                    "åœ°çƒé˜²è¡›éšŠã®æ–°æ˜Ÿç¾ã‚‹ï¼\næ¬¡å›ã€Œã•ã‚‰ã«å¼·ããªã£ãŸæ•µã€ãŠæ¥½ã—ã¿ã«ï¼",
                    "æ•µã€Œãªã‚“ã§å‹ã¦ãªã„ã‚“ã ...ã€\nã‚ãªãŸã€ŒçŸ¥ã‚‰ã‚“ãŒãªã€",
                    "ä»Šæ—¥ã®MVPï¼šã‚ãªãŸ\næ˜æ—¥ã®MVPï¼šãŸã¶ã‚“ã‚ãªãŸ",
                    
                    // å¿œæ´ç³»
                    "ã¿ã‚“ãªãŒå›ã‚’å¿œæ´ã—ã¦ã‚‹ã‚ˆï¼\næ¬¡ã®DAYã‚‚é ‘å¼µã£ã¦ï¼",
                    "åœ°çƒã®ã¿ã‚“ãªãŒå›ã®æ´»èºã‚’è¦‹ã¦ã‚‹ãï¼",
                    "å›ãŒã„ã‚Œã°åœ°çƒã¯å®‰å¿ƒã ï¼\næ¬¡ã‚‚é ¼ã‚“ã ãã€ç›¸æ£’ï¼",
                    
                    // è¬ç³»
                    "ãƒ•ãƒ•ãƒ•...è¨ˆç”»é€šã‚Š...\næ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œã—ã‚ˆã†ã€‚",
                    "èˆˆå‘³æ·±ã„ãƒ‡ãƒ¼ã‚¿ãŒå–ã‚ŒãŸã€‚\næ¬¡ã®å®Ÿé¨“...ã‚‚ã¨ã„ã€ä½œæˆ¦ã«æœŸå¾…ã™ã‚‹ã€‚",
                    "å…¨ã¦ã¯é‹å‘½...å›ã‚‚ãã®ä¸€éƒ¨ã ã€‚\næ¬¡ã®é‹å‘½ãŒå›ã‚’å¾…ã£ã¦ã„ã‚‹ã€‚"
                ];
                
                const randomMessage = congratsMessages[Math.floor(Math.random() * congratsMessages.length)];
                document.getElementById('congratsText').textContent = randomMessage;
            }
            
            displayRandomEndingMessage() {
                const endingMessages = [
                    // æ„Ÿå‹•ç³»
                    "åœ°çƒã®é’ã„ç©ºãŒã€å†ã³å¹³å’Œã«è¼ã„ã¦ã„ã¾ã™ã€‚\nã‚ãªãŸã®å‹‡æ°—ãŒã€æœªæ¥ã¸ã®å¸Œæœ›ã‚’ç¹‹ã„ã ã®ã§ã™ã€‚",
                    "æ˜Ÿã€…ãŒæ­Œã£ã¦ã„ã¾ã™ã€‚è‹±é›„ã®å¸°é‚„ã‚’ã€‚\nå®‡å®™ã«éŸ¿ãå‹åˆ©ã®è®ƒç¾æ­Œã‚’ã€ã‚ãªãŸã«æ§ã’ã¾ã™ã€‚",
                    "åœ°çƒã®å­ä¾›ãŸã¡ãŒç©ºã‚’è¦‹ä¸Šã’ã¦ç¬‘ã£ã¦ã„ã¾ã™ã€‚\nãã‚ŒãŒã€ã‚ãªãŸãŒå®ˆã‚ŠæŠœã„ãŸæœ€ã‚‚å¤§åˆ‡ãªã‚‚ã®ã§ã™ã€‚",
                    "ç„¡æ•°ã®å‘½ãŒæ•‘ã‚ã‚Œã¾ã—ãŸã€‚\nã‚ãªãŸã®æˆ¦ã„ã¯ã€æ°¸é ã«èªã‚Šç¶™ãŒã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚",
                    
                    // å£®å¤§ç³»
                    "å®‡å®™ã®æ­´å²ã«æ–°ãŸãª1ãƒšãƒ¼ã‚¸ãŒåˆ»ã¾ã‚ŒãŸã€‚\nä¼èª¬ã®é˜²è¡›è€…ã¨ã—ã¦ã€ã‚ãªãŸã®åãŒæ°¸é ã«æ®‹ã‚‹ã ã‚ã†ã€‚",
                    "éŠ€æ²³ç³»é˜²è¡›é€£åˆã‚ˆã‚Šæœ€é«˜å‹²ç« ã‚’æˆä¸ã—ã¾ã™ã€‚\nã‚ãªãŸã“ãã€çœŸã®å®‡å®™ã®å®ˆè­·è€…ã§ã™ã€‚",
                    "ã“ã®å‹åˆ©ã¯çµ‚ã‚ã‚Šã§ã¯ãªãã€å§‹ã¾ã‚Šã§ã™ã€‚\næ–°ãŸãªå¹³å’Œã®æ™‚ä»£ãŒã€ä»Šã“ã“ã‹ã‚‰å§‹ã¾ã‚Šã¾ã™ã€‚",
                    "åœ°çƒé˜²è¡›ã®æ­´å²ã«ãŠã„ã¦ã€\nã‚ãªãŸã®åŠŸç¸¾ã¯é‡‘å­—å¡”ã¨ã—ã¦æ°¸é ã«è¼ãç¶šã‘ã‚‹ã§ã—ã‚‡ã†ã€‚",
                    
                    // ãƒ¦ãƒ¼ãƒ¢ã‚¢ç³»
                    "å®‡å®™äººä¼šè­°ã®è­°äº‹éŒ²ï¼š\nã€Œåœ°çƒã€å¼·ã™ãå•é¡Œã«ã¤ã„ã¦ã€â†’ã€Œã‚‚ã†æ”»ã‚ã‚‹ã®ã‚„ã‚ã‚ˆã†ï¼ˆå…¨ä¼šä¸€è‡´ï¼‰ã€",
                    "åœ°çƒé˜²è¡›éšŠäººäº‹éƒ¨ã‚ˆã‚Šï¼š\næ˜‡é€²ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼æ–°ã—ã„ååˆºã«ã¯ã€Œå®‡å®™æœ€å¼·ã€ã¨å°åˆ·ã•ã‚Œã¾ã™ã€‚",
                    "æ•µã®æ¯è‰¦ã‹ã‚‰ç·Šæ€¥é€šä¿¡ï¼š\nã€Œã™ã¿ã¾ã›ã‚“ã€é“ã‚’é–“é•ãˆã¾ã—ãŸã€‚å¹³å’Œãªæ˜Ÿã‚’æ¢ã—ã¦ã¾ã™ã€‚ã€",
                    "å®‡å®™ä¿é™ºä¼šç¤¾ã‚ˆã‚Šï¼š\nã€Œåœ°çƒæ”»æ’ƒä¿é™ºã€ã®ä¿é™ºæ–™ãŒ1000å€ã«å€¤ä¸ŠãŒã‚Šã—ã¾ã—ãŸã€‚",
                    
                    // ãƒãƒƒãƒˆãƒŸãƒ¼ãƒ é¢¨
                    "åœ°çƒé˜²è¡›ã€å®Œã€‚\næ•µã€Œã‚‚ã†ç„¡ç†ã½...ã€\nã‚ãªãŸã€Œã–ã£ã“â™¡ã€",
                    "ã€é€Ÿå ±ã€‘å®‡å®™äººã€åœ°çƒæ”»æ’ƒã‚’æ–­å¿µ\nç†ç”±ï¼šã€Œãƒãƒ¼ãƒˆã™ãã¦è‰ã€",
                    "å®‡å®™äººã®ãƒ„ã‚¤ãƒ¼ãƒˆï¼š\nã€Œåœ°çƒã®é˜²è¡›è€…ã¤ã‚ˆã™ããƒ¯ãƒ­ã‚¿www ã‚‚ã†å¸°ã‚‹ã‚wwwã€",
                    "æ•µå¸ä»¤å®˜ã€Œè¨ˆç”»é€šã‚Š...ã®ã¯ãšã ã£ãŸã€\nã‚ãªãŸã€Œè¨ˆç”»é€šã‚Šï¼ˆå®Œå…¨å‹åˆ©ï¼‰ã€",
                    
                    // å“²å­¦çš„
                    "æˆ¦ã„ã¯çµ‚ã‚ã£ãŸã€‚ã—ã‹ã—å¹³å’Œã¯æˆ¦ã„å–ã‚‹ã‚‚ã®ã§ã¯ãªãã€\nå®ˆã‚Šç¶šã‘ã‚‹ã‚‚ã®ã ã¨ã„ã†ã“ã¨ã‚’ã€ã‚ãªãŸã¯æ•™ãˆã¦ãã‚Œã¾ã—ãŸã€‚",
                    "çœŸã®å¼·ã•ã¨ã¯ã€åŠ›ã§ã¯ãªãã€\nå®ˆã‚ŠãŸã„ã‚‚ã®ã‚’æŒã¤å¿ƒã ã¨ã„ã†ã“ã¨ã‚’è¨¼æ˜ã—ã¾ã—ãŸã­ã€‚",
                    "å®‡å®™ã¯åºƒå¤§ã§ã™ã€‚ã—ã‹ã—ã€ã‚ãªãŸã®å¿ƒã¯ãã‚Œã‚ˆã‚Šã‚‚å¤§ãã„ã€‚\nãªãœãªã‚‰ã€æ„›ã§æº€ã¡ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚",
                    
                    // ç†±è¡€ç³»
                    "ç‡ƒãˆå°½ããŸãœ...çœŸã£ç™½ã«ãª...\nã„ã‚„ã€ã¾ã ã¾ã ç‡ƒãˆç¶šã‘ã‚‹ãœï¼åœ°çƒã®å¹³å’Œã®ãŸã‚ã«ï¼",
                    "ã“ã‚ŒãŒä¿ºãŸã¡ã®å…¨åŠ›ã ï¼\nå®‡å®™ã®æœã¦ã¾ã§éŸ¿ã‘ã€å‹åˆ©ã®é›„å«ã³ï¼",
                    "è«¦ã‚ãªã„å¿ƒãŒã€ä¸å¯èƒ½ã‚’å¯èƒ½ã«ã—ãŸï¼\nå›ã“ãçœŸã®è‹±é›„ã ï¼",
                    
                    // SFé¢¨
                    "æ™‚ç©ºé€£ç¶šä½“ã®å®‰å®šåŒ–ã‚’ç¢ºèªã€‚\nå¤šå…ƒå®‡å®™ã«ãŠã‘ã‚‹åœ°çƒã®å­˜ç¶šãŒä¿è¨¼ã•ã‚Œã¾ã—ãŸã€‚",
                    "é‡å­ãƒ¬ãƒ™ãƒ«ã§ã®å‹åˆ©ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒç¢ºå®šã€‚\nå…¨ã¦ã®å¹³è¡Œä¸–ç•Œã§åœ°çƒãŒæ•‘ã‚ã‚Œã¦ã„ã¾ã™ã€‚",
                    "å®‡å®™ã®æ³•å‰‡ãŒæ›¸ãæ›ãˆã‚‰ã‚Œã¾ã—ãŸã€‚\næ–°ã—ã„æ³•å‰‡ï¼šã€Œåœ°çƒã¯çµ¶å¯¾ã«è² ã‘ãªã„ã€",
                    
                    // æ„Ÿè¬ç³»
                    "ã‚ã‚ŠãŒã¨ã†ã€‚ã“ã®è¨€è‘‰ä»¥å¤–ã«ã€\nä½•ã¨è¨€ãˆã°ã„ã„ã®ã‹ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚",
                    "åœ°çƒã®å…¨ã¦ã®ç”Ÿå‘½ã‹ã‚‰ã€å¿ƒã‹ã‚‰ã®æ„Ÿè¬ã‚’ã€‚\nã‚ãªãŸã¯ç§ãŸã¡ã®ãƒ’ãƒ¼ãƒ­ãƒ¼ã§ã™ã€‚",
                    "è¨€è‘‰ã§ã¯è¡¨ã›ãªã„ã»ã©ã®æ„Ÿè¬ã®æ°—æŒã¡ã‚’è¾¼ã‚ã¦ã€‚\næœ¬å½“ã«ã€æœ¬å½“ã«ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚",
                    
                    // ç¶šç·¨ç¤ºå”†ç³»
                    "ã—ã‹ã—ã€å®‡å®™ã®å½¼æ–¹ã‹ã‚‰æ–°ãŸãªè„…å¨ã®å½±ãŒ...\nã€Œç¶šç·¨ã«ã”æœŸå¾…ãã ã•ã„ã€",
                    "å¹³å’Œãªæ—¥ã€…ãŒç¶šã„ãŸã€‚ã—ã‹ã—ã€ãã‚Œã¯æ–°ãŸãªå†’é™ºã®å§‹ã¾ã‚Šã«éããªã‹ã£ãŸ...",
                    "ã‚¨ãƒ”ãƒ­ãƒ¼ã‚°ï¼š3å¹´å¾Œã€è¬ã®ä¿¡å·ãŒå®‡å®™ã‹ã‚‰å±Šãã€‚\nã€Œã¾ãŸä¼šãŠã†ã€åœ°çƒã®å®ˆè­·è€…ã‚ˆ...ã€",
                    
                    // ãƒ¡ã‚¿ç³»
                    "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çš†æ§˜ã€ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼\né–‹ç™ºè€…ä¸€åŒã€å¿ƒã‚ˆã‚Šæ„Ÿè¬ç”³ã—ä¸Šã’ã¾ã™ã€‚",
                    "ã“ã®ã‚²ãƒ¼ãƒ ã‚’æœ€å¾Œã¾ã§éŠã‚“ã§ãã‚Œã¦ã€ã‚ã‚ŠãŒã¨ã†ã€‚\nã‚ãªãŸã“ãã€çœŸã®ãƒ’ãƒ¼ãƒ­ãƒ¼ã§ã™ã€‚",
                    "ã‚¹ã‚¿ãƒƒãƒ•ãƒ­ãƒ¼ãƒ«ãŒæµã‚Œã‚‹ä¸­ã€\nã‚ãªãŸã®å†’é™ºã¯æ°¸é ã«ç¶šã„ã¦ã„ãã®ã§ã™..."
                ];
                
                const randomMessage = endingMessages[Math.floor(Math.random() * endingMessages.length)];
                
                // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸éƒ¨åˆ†ã‚’æ›´æ–°
                const endingScreen = document.getElementById('endingScreen');
                const messageDiv = endingScreen.querySelector('div:nth-child(1) > div:nth-child(4)');
                if (messageDiv) {
                    messageDiv.innerHTML = `
                        <div style="margin: 30px 0; padding: 25px; border: 2px solid #00ff00; background: rgba(0, 255, 0, 0.1); border-radius: 10px; min-height: 120px; display: flex; align-items: center; justify-content: center;">
                            <p style="font-size: 1rem; margin: 0; color: #00ff00; line-height: 1.8; text-align: center;">${randomMessage}</p>
                        </div>
                    `;
                } else {
                    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸éƒ¨åˆ†ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€æ–°ã—ãä½œæˆ
                    const newMessageDiv = document.createElement('div');
                    newMessageDiv.style.margin = '30px 0';
                    newMessageDiv.style.padding = '25px';
                    newMessageDiv.style.border = '2px solid #00ff00';
                    newMessageDiv.style.background = 'rgba(0, 255, 0, 0.1)';
                    newMessageDiv.style.borderRadius = '10px';
                    newMessageDiv.style.minHeight = '120px';
                    newMessageDiv.style.display = 'flex';
                    newMessageDiv.style.alignItems = 'center';
                    newMessageDiv.style.justifyContent = 'center';
                    newMessageDiv.innerHTML = `<p style="font-size: 1rem; margin: 0; color: #00ff00; line-height: 1.8; text-align: center;">${randomMessage}</p>`;
                    
                    // ã‚¹ã‚³ã‚¢è¡¨ç¤ºã®å¾Œã«æŒ¿å…¥
                    const scoreDiv = endingScreen.querySelector('div:nth-child(1) > div:nth-child(3)');
                    if (scoreDiv) {
                        scoreDiv.parentNode.insertBefore(newMessageDiv, scoreDiv.nextSibling);
                    }
                }
            }
            
            proceedToNextDay() {
                // å¸°é‚„ç”»é¢ã‚’éè¡¨ç¤º
                document.getElementById('returnToBaseScreen').style.display = 'none';
                
                // æ¬¡ã®DAYã«é€²è¡Œ
                this.currentDay++;
                this.dayCleared = false;
                
                // æ•µã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã¯ç¶™ç¶šï¼‰
                this.enemies = [];
                this.bullets = [];
                this.explosions = [];
                this.powerups = [];
                this.gridItems = [];
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height - 100;
                this.player.gridX = Math.floor(this.gridWidth / 2);
                this.player.gridY = this.gridHeight - 3;
                
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                    this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                    this.turnCount = 1;
                    this.playerMoved = false;
                    this.enemyTurnSkip = {};
                    // åˆæœŸã‚¢ã‚¤ãƒ†ãƒ ã‚’é…ç½®
                    this.spawnInitialGridItems();
                }
                
                // åœ°çƒã‚’å°‘ã—å›å¾©
                this.earthHealth = Math.min(this.earthHealth + 20, this.maxEarthHealth);
                
                // ã‚²ãƒ¼ãƒ å†é–‹
                this.gameState = 'playing';
                
                // DAYé€²è¡Œã®é€šä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                const dayMessages = {
                    2: 'DAY 2é–‹å§‹ï¼æ•µã®æ”»æ’ƒãŒã‚ˆã‚Šæ¿€ã—ããªã‚Šã¾ã™',
                    3: 'DAY 3é–‹å§‹ï¼æœ€çµ‚æ±ºæˆ¦ã§ã™ã€‚åœ°çƒã®å‘½é‹ã‚’ã‹ã‘ã¦æˆ¦ã£ã¦ãã ã•ã„ï¼'
                };
                
                this.addCommMessage(dayMessages[this.currentDay], 'urgent');
                this.addCommMessage('åœ°çƒé˜²è­·ã‚·ã‚¹ãƒ†ãƒ éƒ¨åˆ†ä¿®å¾©å®Œäº†', 'normal');
                this.showMapEffect(`DAY ${this.currentDay} é–‹å§‹ï¼`, '#ffff00');
                
                // BGMå†é–‹
                this.startBGM();
            }
            
            showEnding() {
                this.gameState = 'ending';
                
                // BGMåœæ­¢
                this.stopBGM();
                
                // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã®æƒ…å ±ã‚’è¨­å®š
                document.getElementById('endingScore').textContent = this.score.toLocaleString();
                
                const difficultyNames = {
                    easy: 'EASY',
                    normal: 'NORMAL', 
                    hard: 'HARD',
                    expert: 'EXPERT',
                    nightmare: 'NIGHTMARE'
                };
                document.getElementById('endingDifficulty').textContent = difficultyNames[this.difficulty] || this.difficulty.toUpperCase();
                
                // ãƒãƒ©ã‚¨ãƒ†ã‚£è±Šã‹ãªã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                this.displayRandomEndingMessage();
                
                // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«è¿½åŠ 
                this.addToRanking(this.score, this.difficulty, this.gameMode);
                
                // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’è¡¨ç¤º
                document.getElementById('endingScreen').style.display = 'flex';
                
                // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°éŸ³ï¼ˆå‹åˆ©ã®ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ï¼‰
                setTimeout(() => this.playBeep(500, 200, 'sine'), 0);
                setTimeout(() => this.playBeep(600, 200, 'sine'), 200);
                setTimeout(() => this.playBeep(700, 200, 'sine'), 400);
                setTimeout(() => this.playBeep(800, 300, 'sine'), 600);
                setTimeout(() => this.playBeep(900, 400, 'sine'), 900);
            }
            
            startEndlessMode() {
                this.endlessMode = true;
                this.currentDay = 4; // ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤ºç”¨
                this.dayCleared = false;
                this.gameState = 'playing';
                
                // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’éè¡¨ç¤º
                document.getElementById('endingScreen').style.display = 'none';
                
                // ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                this.addCommMessage('ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰é–‹å§‹ï¼é™ç•Œã«æŒ‘æˆ¦ã—ã¦ãã ã•ã„', 'urgent');
                this.showMapEffect('ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰é–‹å§‹ï¼', '#ff00ff');
                
                // BGMå†é–‹
                this.startBGM();
                
                // ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰éŸ³
                setTimeout(() => this.playBeep(400, 100, 'sine'), 0);
                setTimeout(() => this.playBeep(500, 100, 'sine'), 100);
                setTimeout(() => this.playBeep(600, 100, 'sine'), 200);
                setTimeout(() => this.playBeep(800, 200, 'sine'), 300);
            }
            
            addCommMessage(message, type = 'normal') {
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿å‹•ä½œ
                if (this.gameMode !== 'defense' && this.gameMode !== 'strategy') return;
                
                const now = Date.now();
                // åŒã˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€£ç¶šé€ä¿¡ã‚’é˜²ãï¼ˆ1ç§’é–“éš”ï¼‰
                if (now - this.lastCommTime < 1000) return;
                
                this.lastCommTime = now;
                this.commMessageId++;
                
                // æœ€æ–°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ä¿æŒ
                this.currentCommMessage = {
                    id: this.commMessageId,
                    text: message,
                    type: type,
                    timestamp: now
                };
                
                this.updateCommDisplay();
            }
            
            updateCommDisplay() {
                const commMessagesDiv = document.getElementById('commMessages');
                if (!commMessagesDiv || !this.currentCommMessage) return;
                
                commMessagesDiv.innerHTML = '';
                
                const msg = this.currentCommMessage;
                const messageDiv = document.createElement('div');
                messageDiv.className = `comm-message ${msg.type === 'urgent' ? 'comm-urgent' : msg.type === 'warning' ? 'comm-warning' : ''}`;
                
                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ 
                const timeStr = new Date(msg.timestamp).toLocaleTimeString('ja-JP', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
                
                messageDiv.innerHTML = `<span style="opacity: 0.7; font-size: 10px;">[${timeStr}]</span> ${msg.text}`;
                commMessagesDiv.appendChild(messageDiv);
            }
            
            render() {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ã‚°ãƒªãƒƒãƒ‰æç”»ï¼ˆã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.renderGrid();
                }
                
                this.renderStars();
                this.renderEarthSurface();
                this.renderPlayer();
                this.renderBullets();
                this.renderEnemies();
                this.renderPowerups();
                this.renderGridItems();
                this.renderMapEffects();
                this.renderExplosions();
                
                this.updateUI();
            }
            
            renderGrid() {
                this.ctx.strokeStyle = '#003300';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                
                // ç¸¦ç·š
                for (let x = 0; x <= this.gridWidth; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * this.gridSize, 0);
                    this.ctx.lineTo(x * this.gridSize, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // æ¨ªç·š
                for (let y = 0; y <= this.gridHeight; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * this.gridSize);
                    this.ctx.lineTo(this.canvas.width, y * this.gridSize);
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            renderStars() {
                this.ctx.fillStyle = '#ffffff';
                this.stars.forEach(star => {
                    this.ctx.fillRect(star.x, star.y, star.size, star.size);
                });
            }
            
            renderEarthSurface() {
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§ã¯åœ°çƒã®çŠ¶æ…‹ã«å¿œã˜ã¦è‰²ã‚’å¤‰æ›´
                let earthColor = '#00ff00';
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    const healthRatio = this.earthHealth / this.maxEarthHealth;
                    if (healthRatio > 0.6) {
                        earthColor = '#00ff00'; // ç·‘ï¼ˆå¥åº·ï¼‰
                    } else if (healthRatio > 0.3) {
                        earthColor = '#ffff00'; // é»„ï¼ˆè­¦å‘Šï¼‰
                    } else {
                        earthColor = '#ff4400'; // èµ¤ï¼ˆå±é™ºï¼‰
                    }
                }
                
                this.ctx.strokeStyle = earthColor;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                this.earthSurface.forEach((point, index) => {
                    if (index === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                    
                    // å»ºç‰©ã‚’æç”»ï¼ˆé™çš„ï¼‰
                    if (point.buildings) {
                        this.ctx.rect(point.x - 10, point.y - point.buildingHeight, 20, point.buildingHeight);
                    }
                });
                
                this.ctx.stroke();
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¦ã„ã‚‹å ´åˆã€é˜²è­·ãƒãƒªã‚¢ã‚’æç”»
                if ((this.gameMode === 'defense' || this.gameMode === 'strategy') && this.earthHealth < this.maxEarthHealth) {
                    this.ctx.strokeStyle = earthColor;
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, this.canvas.height - 80);
                    this.ctx.lineTo(this.canvas.width, this.canvas.height - 80);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
            
            renderPlayer() {
                // ã‚·ãƒ¼ãƒ«ãƒ‰æç”»
                if (this.player.shield) {
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.player.x + this.player.width/2,
                        this.player.y + this.player.height/2,
                        this.player.width/2 + 10,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.stroke();
                }
                
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                // å®‡å®™èˆ¹ã®å½¢çŠ¶ï¼ˆä¸‰è§’å½¢ãƒ™ãƒ¼ã‚¹ï¼‰
                this.ctx.moveTo(this.player.x + this.player.width/2, this.player.y);
                this.ctx.lineTo(this.player.x, this.player.y + this.player.height);
                this.ctx.lineTo(this.player.x + this.player.width/4, this.player.y + this.player.height - 5);
                this.ctx.lineTo(this.player.x + this.player.width*3/4, this.player.y + this.player.height - 5);
                this.ctx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
                this.ctx.closePath();
                this.ctx.stroke();
                
                // æ­¦å™¨ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæ­¦å™¨ã®ã¿ï¼‰
                let weaponCount = 0;
                Object.keys(this.weapons).forEach(weaponType => {
                    if (this.weapons[weaponType].level > 0) {
                        const colors = {
                            basicShot: '#ffff00',
                            spreadShot: '#ff8800',
                            laser: '#00ffff',
                            missile: '#ff0000',
                            orbit: '#00ff88',
                            piercing: '#00ff00',
                            homing: '#ff00ff',
                            barrier: '#8800ff'
                        };
                        
                        this.ctx.strokeStyle = colors[weaponType] || '#ffffff';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.rect(this.player.x + 5 + weaponCount * 8, this.player.y - 10, 6, 3);
                        this.ctx.stroke();
                        
                        // ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
                        this.ctx.fillStyle = colors[weaponType] || '#ffffff';
                        this.ctx.font = '8px monospace';
                        this.ctx.fillText(this.weapons[weaponType].level.toString(), 
                                        this.player.x + 6 + weaponCount * 8, this.player.y - 4);
                        
                        weaponCount++;
                    }
                });
                
                // ã‚¨ãƒ³ã‚¸ãƒ³ã®ç‚
                this.ctx.strokeStyle = '#ff4400';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.width/4, this.player.y + this.player.height);
                this.ctx.lineTo(this.player.x + this.player.width/2, this.player.y + this.player.height + 10);
                this.ctx.lineTo(this.player.x + this.player.width*3/4, this.player.y + this.player.height);
                this.ctx.stroke();
            }
            
            renderBullets() {
                this.bullets.forEach(bullet => {
                    this.ctx.fillStyle = bullet.color || '#ffff00';
                    this.ctx.strokeStyle = bullet.color || '#ffff00';
                    
                    if (bullet.type === 'laser') {
                        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®æç”»
                        this.ctx.lineWidth = bullet.width;
                        this.ctx.beginPath();
                        this.ctx.moveTo(bullet.x, 0);
                        this.ctx.lineTo(bullet.x, this.canvas.height);
                        this.ctx.stroke();
                    } else if (bullet.type === 'missile') {
                        // ãƒŸã‚µã‚¤ãƒ«ã®æç”»
                        this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // ç…™ã®è»Œè·¡
                        this.ctx.fillStyle = '#666666';
                        this.ctx.fillRect(bullet.x + 2, bullet.y + bullet.height, 4, 8);
                    } else if (bullet.type === 'homing') {
                        // è¿½å°¾å¼¾ã®æç”»ï¼ˆå›è»¢ï¼‰
                        this.ctx.save();
                        this.ctx.translate(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
                        this.ctx.rotate(bullet.angle + Math.PI/2);
                        this.ctx.fillRect(-bullet.width/2, -bullet.height/2, bullet.width, bullet.height);
                        this.ctx.restore();
                    } else {
                        // é€šå¸¸å¼¾ã®æç”»
                        this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    }
                });
                
                // è»Œé“å¼¾ã®æç”»
                this.orbitingBullets.forEach(orbit => {
                    const x = this.player.x + this.player.width/2 + Math.cos(orbit.angle) * orbit.distance;
                    const y = this.player.y + this.player.height/2 + Math.sin(orbit.angle) * orbit.distance;
                    
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, orbit.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // ãƒãƒªã‚¢å¼¾ã®æç”»
                this.barrierBullets.forEach(barrier => {
                    let x, y;
                    
                    if (barrier.fixed) {
                        // å›ºå®šä½ç½®ãƒãƒªã‚¢
                        x = barrier.x;
                        y = barrier.y;
                    } else {
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨å›²ã®ãƒãƒªã‚¢
                        x = this.player.x + this.player.width/2 + Math.cos(barrier.angle) * barrier.distance;
                        y = this.player.y + this.player.height/2 + Math.sin(barrier.angle) * barrier.distance;
                    }
                    
                    this.ctx.strokeStyle = '#8800ff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, barrier.size, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
            }
            
            renderEnemies() {
                this.enemies.forEach(enemy => {
                    if (enemy.type === 'enemy_bullet') {
                        // æ•µã®å¼¾
                        this.ctx.strokeStyle = '#ff8800';
                        this.ctx.fillStyle = '#ff8800';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
                        this.ctx.fill();
                        this.ctx.stroke();
                    } else {
                        // é€šå¸¸æ•µã®è‰²åˆ†ã‘
                        const colors = {
                            normal: '#ff4444',
                            fast: '#ff0000',
                            heavy: '#ffaa00',
                            shooter: '#ff8800',
                            zigzag: '#ff6600'
                        };
                        
                        this.ctx.strokeStyle = colors[enemy.type] || '#ff4444';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        
                        if (enemy.type === 'heavy') {
                            // é‡è£…æ•µï¼ˆå››è§’å½¢ï¼‰
                            this.ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
                        } else if (enemy.type === 'shooter') {
                            // å°„æ’ƒæ•µï¼ˆå…­è§’å½¢ï¼‰
                            const centerX = enemy.x + enemy.width/2;
                            const centerY = enemy.y + enemy.height/2;
                            const radius = enemy.width/2;
                            
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.7;
                                
                                if (i === 0) {
                                    this.ctx.moveTo(x, y);
                                } else {
                                    this.ctx.lineTo(x, y);
                                }
                            }
                            this.ctx.closePath();
                        } else {
                            // ãã®ä»–ã®æ•µï¼ˆé€†ä¸‰è§’å½¢ï¼‰
                            this.ctx.moveTo(enemy.x + enemy.width/2, enemy.y + enemy.height);
                            this.ctx.lineTo(enemy.x, enemy.y);
                            this.ctx.lineTo(enemy.x + enemy.width/4, enemy.y + 5);
                            this.ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y + 5);
                            this.ctx.lineTo(enemy.x + enemy.width, enemy.y);
                            this.ctx.closePath();
                        }
                        
                        this.ctx.stroke();
                        
                        // ä½“åŠ›è¡¨ç¤º
                        if (enemy.health > 1) {
                            for (let i = 1; i < enemy.health; i++) {
                                this.ctx.beginPath();
                                this.ctx.rect(enemy.x + 3*i, enemy.y + 3*i, enemy.width - 6*i, enemy.height - 6*i);
                                this.ctx.stroke();
                            }
                        }
                    }
                });
            }
            
            renderPowerups() {
                this.powerups.forEach(powerup => {
                    const centerX = powerup.x + powerup.width / 2;
                    const centerY = powerup.y + powerup.height / 2;
                    
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(powerup.rotation);
                    
                    // æ­¦å™¨ã‚¢ã‚¤ã‚³ãƒ³ã®æç”»
                    if (powerup.type === 'basicShot') {
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(0, 6);
                        this.ctx.stroke();
                    } else if (powerup.type === 'spreadShot') {
                        this.ctx.strokeStyle = '#ff8800';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(-4, -6);
                        this.ctx.lineTo(-4, 6);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(0, 6);
                        this.ctx.moveTo(4, -6);
                        this.ctx.lineTo(4, 6);
                        this.ctx.stroke();
                    } else if (powerup.type === 'laser') {
                        this.ctx.strokeStyle = '#00ffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(0, -8);
                        this.ctx.lineTo(0, 8);
                        this.ctx.stroke();
                    } else if (powerup.type === 'missile') {
                        this.ctx.strokeStyle = '#ff0000';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(-3, 0);
                        this.ctx.lineTo(0, 6);
                        this.ctx.lineTo(3, 0);
                        this.ctx.closePath();
                        this.ctx.stroke();
                    } else if (powerup.type === 'orbit') {
                        this.ctx.strokeStyle = '#00ff88';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else if (powerup.type === 'piercing') {
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(-6, 0);
                        this.ctx.lineTo(6, 0);
                        this.ctx.moveTo(3, -3);
                        this.ctx.lineTo(6, 0);
                        this.ctx.lineTo(3, 3);
                        this.ctx.stroke();
                    } else if (powerup.type === 'homing') {
                        this.ctx.strokeStyle = '#ff00ff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        this.ctx.moveTo(0, -4);
                        this.ctx.lineTo(0, -8);
                        this.ctx.stroke();
                    } else if (powerup.type === 'barrier') {
                        this.ctx.strokeStyle = '#8800ff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        this.ctx.moveTo(-4, -4);
                        this.ctx.lineTo(4, 4);
                        this.ctx.moveTo(-4, 4);
                        this.ctx.lineTo(4, -4);
                        this.ctx.stroke();
                    } else if (powerup.type === 'shield') {
                        this.ctx.strokeStyle = '#00ffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else if (powerup.type === 'life') {
                        this.ctx.strokeStyle = '#ff0080';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -10);
                        this.ctx.lineTo(-8, -2);
                        this.ctx.lineTo(-8, 6);
                        this.ctx.lineTo(0, 10);
                        this.ctx.lineTo(8, 6);
                        this.ctx.lineTo(8, -2);
                        this.ctx.closePath();
                        this.ctx.stroke();
                    } else if (powerup.type === 'speed') {
                        this.ctx.strokeStyle = '#88ff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(-6, 0);
                        this.ctx.lineTo(6, 0);
                        this.ctx.moveTo(3, -3);
                        this.ctx.lineTo(6, 0);
                        this.ctx.lineTo(3, 3);
                        this.ctx.moveTo(-3, -3);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-3, 3);
                        this.ctx.stroke();
                    } else if (powerup.type === 'healEarth') {
                        // åœ°çƒå›å¾©ã‚¢ã‚¤ãƒ†ãƒ ã¯ç‰¹åˆ¥ãªãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º
                        const pulseScale = 1 + Math.sin(powerup.pulseTime) * 0.3;
                        const glowIntensity = Math.sin(powerup.pulseTime * 2) * 0.5 + 0.5;
                        
                        // å¤–å´ã®ã‚°ãƒ­ãƒ¼åŠ¹æœ
                        this.ctx.strokeStyle = `rgba(0, 255, 0, ${glowIntensity * 0.8})`;
                        this.ctx.lineWidth = 6;
                        this.ctx.beginPath();
                        this.ctx.rect(-12 * pulseScale, -12 * pulseScale, 24 * pulseScale, 24 * pulseScale);
                        this.ctx.stroke();
                        
                        // ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¤ã‚³ãƒ³
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(-6, 0);
                        this.ctx.lineTo(6, 0);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(0, 6);
                        this.ctx.stroke();
                        
                        // åœ°çƒã‚¢ã‚¤ã‚³ãƒ³ã®è¿½åŠ 
                        this.ctx.strokeStyle = '#00aaff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 10, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç²’å­
                        for (let i = 0; i < 4; i++) {
                            const angle = (powerup.rotation * 2 + i * Math.PI / 2);
                            const particleX = Math.cos(angle) * 15;
                            const particleY = Math.sin(angle) * 15;
                            
                            this.ctx.fillStyle = `rgba(0, 255, 0, ${glowIntensity})`;
                            this.ctx.beginPath();
                            this.ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                });
            }
            

            
            renderGridItems() {
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.gridItems.forEach(item => {
                        const centerX = item.x + item.width / 2;
                        const centerY = item.y + item.height / 2;
                        const pulseScale = 1 + Math.sin(item.pulseTime) * 0.2;
                        
                        this.ctx.save();
                        this.ctx.translate(centerX, centerY);
                        this.ctx.rotate(item.rotation);
                        this.ctx.scale(pulseScale, pulseScale);
                        
                        // ç‰¹æ®Šã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¢ã‚¤ã‚³ãƒ³æç”»
                        this.ctx.lineWidth = 2;
                        
                        switch (item.type) {
                            case 'freeze':
                                this.ctx.strokeStyle = '#00ffff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                // é›ªã®çµæ™¶
                                this.ctx.moveTo(0, -8); this.ctx.lineTo(0, 8);
                                this.ctx.moveTo(-8, 0); this.ctx.lineTo(8, 0);
                                this.ctx.moveTo(-6, -6); this.ctx.lineTo(6, 6);
                                this.ctx.moveTo(-6, 6); this.ctx.lineTo(6, -6);
                                this.ctx.stroke();
                                break;
                            case 'slowTime':
                                this.ctx.strokeStyle = '#ffff00';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                this.ctx.moveTo(0, 0); this.ctx.lineTo(0, -6);
                                this.ctx.moveTo(0, 0); this.ctx.lineTo(4, 0);
                                this.ctx.stroke();
                                break;
                            case 'mapShield':
                                this.ctx.strokeStyle = '#00ffff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 10, 0, Math.PI * 2);
                                this.ctx.moveTo(-6, -6); this.ctx.lineTo(6, 6);
                                this.ctx.moveTo(-6, 6); this.ctx.lineTo(6, -6);
                                this.ctx.stroke();
                                break;
                            case 'doubleScore':
                                this.ctx.strokeStyle = '#ffff00';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.font = '16px monospace';
                                this.ctx.fillStyle = '#ffff00';
                                this.ctx.fillText('2X', -8, 4);
                                this.ctx.stroke();
                                break;
                            case 'rapidFire':
                                this.ctx.strokeStyle = '#ff8800';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                for (let i = 0; i < 3; i++) {
                                    this.ctx.moveTo(-6 + i*6, -8);
                                    this.ctx.lineTo(-6 + i*6, 8);
                                }
                                this.ctx.stroke();
                                break;
                            case 'invincible':
                                this.ctx.strokeStyle = '#ff00ff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.moveTo(0, -10); this.ctx.lineTo(-8, -2);
                                this.ctx.lineTo(-8, 6); this.ctx.lineTo(0, 10);
                                this.ctx.lineTo(8, 6); this.ctx.lineTo(8, -2);
                                this.ctx.closePath();
                                this.ctx.stroke();
                                break;
                            case 'explosion':
                                this.ctx.strokeStyle = '#ff0000';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                this.ctx.moveTo(0, -12); this.ctx.lineTo(0, -8);
                                this.ctx.stroke();
                                break;
                            case 'timeWarp':
                                this.ctx.strokeStyle = '#ff00ff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 6, 0, Math.PI);
                                this.ctx.arc(0, 0, 6, Math.PI, Math.PI * 2);
                                this.ctx.stroke();
                                break;
                            case 'healEarth':
                                // åœ°çƒå›å¾©ã‚¢ã‚¤ãƒ†ãƒ ã¯ç‰¹åˆ¥ãªãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºï¼ˆã‚°ãƒªãƒƒãƒ‰ç‰ˆï¼‰
                                const gridGlowIntensity = Math.sin(item.pulseTime * 2) * 0.5 + 0.5;
                                
                                // å¤–å´ã®ã‚°ãƒ­ãƒ¼åŠ¹æœ
                                this.ctx.strokeStyle = `rgba(0, 255, 0, ${gridGlowIntensity * 0.8})`;
                                this.ctx.lineWidth = 4;
                                this.ctx.beginPath();
                                this.ctx.rect(-15, -15, 30, 30);
                                this.ctx.stroke();
                                
                                // ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¤ã‚³ãƒ³
                                this.ctx.strokeStyle = '#00ff00';
                                this.ctx.lineWidth = 3;
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.moveTo(-6, 0); this.ctx.lineTo(6, 0);
                                this.ctx.moveTo(0, -6); this.ctx.lineTo(0, 6);
                                this.ctx.stroke();
                                
                                // åœ°çƒã‚¢ã‚¤ã‚³ãƒ³ã®è¿½åŠ 
                                this.ctx.strokeStyle = '#00aaff';
                                this.ctx.lineWidth = 2;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                this.ctx.stroke();
                                
                                // å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç²’å­
                                for (let i = 0; i < 4; i++) {
                                    const angle = (item.rotation * 2 + i * Math.PI / 2);
                                    const particleX = Math.cos(angle) * 12;
                                    const particleY = Math.sin(angle) * 12;
                                    
                                    this.ctx.fillStyle = `rgba(0, 255, 0, ${gridGlowIntensity})`;
                                    this.ctx.beginPath();
                                    this.ctx.arc(particleX, particleY, 1.5, 0, Math.PI * 2);
                                    this.ctx.fill();
                                }
                                break;
                            case 'lightningStrike':
                                this.ctx.strokeStyle = '#ffff00';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.moveTo(-4, -8); this.ctx.lineTo(0, 0);
                                this.ctx.lineTo(-2, 0); this.ctx.lineTo(4, 8);
                                this.ctx.stroke();
                                break;
                            default:
                                // é€šå¸¸ã‚¢ã‚¤ãƒ†ãƒ ã¯æ—¢å­˜ã®æç”»ã‚’ä½¿ç”¨
                                this.renderPowerupIcon(item.type);
                                break;
                        }
                        
                        this.ctx.restore();
                    });
                }
            }
            
            renderMapEffects() {
                // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒãƒƒãƒ—åŠ¹æœã®è¦–è¦šè¡¨ç¾
                if (this.mapEffects.freeze.active) {
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                if (this.mapEffects.slowTime.active) {
                    this.ctx.fillStyle = 'rgba(255, 255, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                if (this.mapEffects.shield.active || this.mapEffects.invincible.active) {
                    this.ctx.strokeStyle = this.mapEffects.invincible.active ? '#ff00ff' : '#00ffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([10, 10]);
                    this.ctx.beginPath();
                    this.ctx.rect(5, 5, this.canvas.width - 10, this.canvas.height - 10);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                if (this.mapEffects.energyStorm.active) {
                    // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 5; i++) {
                        this.ctx.strokeStyle = '#ff4400';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(Math.random() * this.canvas.width, 0);
                        this.ctx.lineTo(Math.random() * this.canvas.width, this.canvas.height);
                        this.ctx.stroke();
                    }
                }
            }
            
            renderPowerupIcon(type) {
                // æ—¢å­˜ã®ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ã‚³ãƒ³æç”»ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨
                if (type === 'basicShot') {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.rect(-8, -8, 16, 16);
                    this.ctx.moveTo(0, -6); this.ctx.lineTo(0, 6);
                    this.ctx.stroke();
                } else if (type === 'shield') {
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else if (type === 'life') {
                    this.ctx.strokeStyle = '#ff0080';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -10); this.ctx.lineTo(-8, -2);
                    this.ctx.lineTo(-8, 6); this.ctx.lineTo(0, 10);
                    this.ctx.lineTo(8, 6); this.ctx.lineTo(8, -2);
                    this.ctx.closePath();
                    this.ctx.stroke();
                } else if (type === 'speed') {
                    this.ctx.strokeStyle = '#88ff00';
                    this.ctx.beginPath();
                    this.ctx.moveTo(-6, 0); this.ctx.lineTo(6, 0);
                    this.ctx.moveTo(3, -3); this.ctx.lineTo(6, 0); this.ctx.lineTo(3, 3);
                    this.ctx.stroke();
                }
            }
            
            renderExplosions() {
                this.explosions.forEach(explosion => {
                    if (explosion.type === 'missile') {
                        // ãƒŸã‚µã‚¤ãƒ«çˆ†ç™ºã®æç”»
                        this.ctx.strokeStyle = '#ff4400';
                        this.ctx.lineWidth = 4;
                        this.ctx.beginPath();
                        this.ctx.arc(explosion.x, explosion.y, explosion.radius * (1 - explosion.time / 30), 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        this.ctx.strokeStyle = '#ffaa00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(explosion.x, explosion.y, explosion.radius * 0.7 * (1 - explosion.time / 30), 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        // é€šå¸¸çˆ†ç™ºã®æç”»
                        this.ctx.strokeStyle = '#ff8800';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        
                        const segments = 8;
                        for (let i = 0; i < segments; i++) {
                            const angle = (i / segments) * Math.PI * 2;
                            const x = explosion.x + Math.cos(angle) * explosion.radius;
                            const y = explosion.y + Math.sin(angle) * explosion.radius;
                            
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                });
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ç”¨UI
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    document.getElementById('earthHp').textContent = this.earthHealth;
                }
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®DAYæƒ…å ±æ›´æ–°
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    if (this.endlessMode) {
                        document.getElementById('currentDay').textContent = 'ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹';
                        document.getElementById('dayTarget').textContent = 'âˆ';
                    } else {
                        document.getElementById('currentDay').textContent = `DAY ${this.currentDay}`;
                        const targetScore = this.dayTargetScores[this.currentDay];
                        document.getElementById('dayTarget').textContent = targetScore ? targetScore.toLocaleString() : '---';
                    }
                }
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ç”¨UI
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    document.getElementById('turnCount').textContent = this.turnCount;
                    this.updateEffectsLog();
                    this.updateInventoryUI();
                }
            }
            
            updateEffectsLog() {
                const effectsList = document.getElementById('effectsList');
                effectsList.innerHTML = '';
                
                const effectNames = {
                    freeze: 'æ•µå…¨ä½“å‡çµ',
                    slowTime: 'æ™‚é–“æ¸›é€Ÿ',
                    shield: 'å…¨ä½“ã‚·ãƒ¼ãƒ«ãƒ‰',
                    doubleScore: 'ã‚¹ã‚³ã‚¢2å€',
                    rapidFire: 'é€£å°„å¼·åŒ–',
                    invincible: 'ç„¡æ•µçŠ¶æ…‹',
                    magneticField: 'ç£åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰',
                    energyStorm: 'ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ '
                };
                
                const effectColors = {
                    freeze: '#00ffff',
                    slowTime: '#ffff00',
                    shield: '#00ffff',
                    doubleScore: '#ffff00',
                    rapidFire: '#ff8800',
                    invincible: '#ff00ff',
                    magneticField: '#8800ff',
                    energyStorm: '#ff4400'
                };
                
                let hasActiveEffects = false;
                
                Object.keys(this.mapEffects).forEach(effectKey => {
                    const effect = this.mapEffects[effectKey];
                    if (effect.active && effect.duration > 0) {
                        hasActiveEffects = true;
                        
                        const effectItem = document.createElement('div');
                        effectItem.className = 'effect-item';
                        effectItem.style.borderColor = effectColors[effectKey] || '#ffff00';
                        effectItem.style.background = `rgba(${effectColors[effectKey] ? this.hexToRgb(effectColors[effectKey]) : '255,255,0'}, 0.1)`;
                        
                        effectItem.innerHTML = `
                            <span class="effect-name" style="color: ${effectColors[effectKey] || '#ffff00'}">
                                ${effectNames[effectKey] || effectKey}
                            </span>
                            <span class="effect-duration">æ®‹ã‚Š${effect.duration}ã‚¿ãƒ¼ãƒ³</span>
                        `;
                        
                        effectsList.appendChild(effectItem);
                    }
                });
                
                if (!hasActiveEffects) {
                    effectsList.innerHTML = '<div style="opacity: 0.5; font-style: italic;">ãªã—</div>';
                }
            }
            
            updateInventoryUI() {
                const inventoryList = document.getElementById('inventoryList');
                inventoryList.innerHTML = '';
                
                const itemNames = {
                    explosion: 'ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ§ãƒ³'
                };
                
                const itemColors = {
                    explosion: '#ff0000'
                };
                
                const itemHotkeys = {
                    explosion: 'Q'
                };
                
                let hasItems = false;
                
                Object.keys(this.inventory).forEach(itemKey => {
                    const count = this.inventory[itemKey];
                    if (count > 0) {
                        hasItems = true;
                        
                        const inventoryItem = document.createElement('div');
                        inventoryItem.className = 'inventory-item';
                        inventoryItem.style.borderColor = itemColors[itemKey] || '#ff8800';
                        inventoryItem.style.background = `rgba(${itemColors[itemKey] ? this.hexToRgb(itemColors[itemKey]) : '255,136,0'}, 0.1)`;
                        
                        inventoryItem.innerHTML = `
                            <div>
                                <span class="item-name" style="color: ${itemColors[itemKey] || '#ff8800'}">
                                    ${itemNames[itemKey] || itemKey}
                                </span>
                                <span class="item-hotkey">[${itemHotkeys[itemKey] || '?'}]</span>
                            </div>
                            <span class="item-count">x${count}</span>
                        `;
                        
                        // ã‚¯ãƒªãƒƒã‚¯ã§ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨
                        inventoryItem.addEventListener('click', () => {
                            this.useInventoryItem(itemKey);
                        });
                        
                        inventoryList.appendChild(inventoryItem);
                    }
                });
                
                if (!hasItems) {
                    inventoryList.innerHTML = '<div style="opacity: 0.5; font-style: italic;">ãªã—</div>';
                }
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? 
                    `${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)}` : 
                    '255,255,0';
            }
            
            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                }
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                
                // BGMåœæ­¢
                this.stopBGM();
                
                document.getElementById('finalScore').textContent = this.score.toLocaleString();
                
                const difficultyNames = {
                    easy: 'EASY',
                    normal: 'NORMAL', 
                    hard: 'HARD',
                    expert: 'EXPERT',
                    nightmare: 'NIGHTMARE'
                };
                document.getElementById('finalDifficulty').textContent = difficultyNames[this.difficulty] || this.difficulty.toUpperCase();
                
                // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«è¿½åŠ ï¼ˆå…¨ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰
                const newRecordIndex = this.addToRanking(this.score, this.difficulty, this.gameMode);
                this.displayRankings(newRecordIndex);
                
                // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰åˆ¥ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤º
                const rankingSection = document.getElementById('rankingList');
                const rankingTitle = rankingSection.querySelector('h3');
                const gameModeNames = {
                    classic: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯',
                    defense: 'åœ°çƒé˜²è¡›',
                    turnbased: 'ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹',
                    strategy: 'ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼'
                };
                const gameModeName = gameModeNames[this.gameMode] || this.gameMode;
                rankingTitle.innerHTML = `ğŸ† ãƒã‚¤ã‚¹ã‚³ã‚¢ ãƒ©ãƒ³ã‚­ãƒ³ã‚°<br><small style="font-size: 12px; opacity: 0.7;">(${gameModeName}ãƒ¢ãƒ¼ãƒ‰)</small>`;
                
                document.getElementById('gameOver').style.display = 'block';
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼éŸ³ï¼ˆä¸‹é™éŸ³éšï¼‰
                setTimeout(() => this.playBeep(400, 200, 'sine'), 0);
                setTimeout(() => this.playBeep(350, 200, 'sine'), 200);
                setTimeout(() => this.playBeep(300, 400, 'sine'), 400);
            }
            
            restartSameDifficulty() {
                this.gameState = 'playing';
                this.score = 0;
                this.lives = this.difficultySettings.playerLives;
                this.level = 1;
                this.bullets = [];
                this.enemies = [];
                this.explosions = [];
                this.powerups = [];
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height - 100;
                this.player.shield = false;
                this.player.shieldTime = 0;
                this.player.speed = this.isMobile() ? 4 : 5;
                
                // ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã®åˆæœŸåŒ–
                this.player.gridX = Math.floor(this.gridWidth / 2);
                this.player.gridY = this.gridHeight - 3;
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ­£ç¢ºãªã‚°ãƒªãƒƒãƒ‰ä½ç½®ã«é…ç½®
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                    this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                }
                
                // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å›ºæœ‰ã®åˆæœŸåŒ–
                this.earthHealth = this.maxEarthHealth;
                this.turnCount = 1;
                this.playerMoved = false;
                
                // DAYã‚·ã‚¹ãƒ†ãƒ ã®ãƒªã‚»ãƒƒãƒˆ
                this.currentDay = 1;
                this.dayCleared = false;
                this.endlessMode = false;
                
                // ãƒãƒƒãƒ—åŠ¹æœã¨ã‚°ãƒªãƒƒãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚»ãƒƒãƒˆ
                this.mapEffects = {
                    freeze: { active: false, duration: 0 },
                    slowTime: { active: false, duration: 0 },
                    shield: { active: false, duration: 0 },
                    doubleScore: { active: false, duration: 0 },
                    rapidFire: { active: false, duration: 0 },
                    invincible: { active: false, duration: 0 },
                    magneticField: { active: false, duration: 0 },
                    energyStorm: { active: false, duration: 0 }
                };
                this.gridItems = [];
                this.enemyTurnSkip = {};
                
                // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®ãƒªã‚»ãƒƒãƒˆ
                this.inventory = {
                    explosion: 0
                };
                
                // é€šä¿¡ãƒ­ã‚°ã®ãƒªã‚»ãƒƒãƒˆ
                this.currentCommMessage = null;
                this.lastCommTime = 0;
                this.commMessageId = 0;
                
                // æ­¦å™¨ãƒªã‚»ãƒƒãƒˆ
                this.weapons = {
                    basicShot: { level: 1, maxLevel: 5, lastShot: 0, cooldown: 150 },
                    spreadShot: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 200 },
                    laser: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 300 },
                    missile: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 800 },
                    orbit: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 100 },
                    piercing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 250 },
                    homing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 400 },
                    barrier: { level: 0, maxLevel: 3, lastShot: 0, cooldown: 1000 }
                };
                
                this.orbitingBullets = [];
                this.barrierBullets = [];
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('endingScreen').style.display = 'none';
                
                // UIè¡¨ç¤ºã®æ›´æ–°
                this.updateUIVisibility();
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯åˆæœŸã‚¢ã‚¤ãƒ†ãƒ ã‚’é…ç½®
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.spawnInitialGridItems();
                    this.giveInitialInventoryItems();
                }
                
                // åœ°çƒé˜²è¡›ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                if (this.gameMode === 'defense') {
                    this.addCommMessage('é˜²è¡›å¸ä»¤éƒ¨ã‚ˆã‚Šã€åœ°çƒé˜²è¡›ä½œæˆ¦ã‚’é–‹å§‹ã—ã¾ã™', 'normal');
                    this.addCommMessage('DAY 1ï¼šæ•µã®ä¾µæ”»ã‚’é˜»æ­¢ã—ã€åœ°çƒã‚’å®ˆã‚ŠæŠœã„ã¦ãã ã•ã„', 'normal');
                } else if (this.gameMode === 'strategy') {
                    this.addCommMessage('æˆ¦ç•¥å¸ä»¤éƒ¨ã‚ˆã‚Šã€ã‚¿ãƒ¼ãƒ³åˆ¶åœ°çƒé˜²è¡›ä½œæˆ¦ã‚’é–‹å§‹ã—ã¾ã™', 'normal');
                    this.addCommMessage('DAY 1ï¼šæˆ¦ç•¥çš„æ€è€ƒã§æ•µã‚’æ’ƒé€€ã—ã€åœ°çƒã‚’å®ˆã‚ŠæŠœã„ã¦ãã ã•ã„', 'normal');
                }
                
                // BGMå†é–‹
                this.startBGM();
            }
            
            restart() {
                // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚
                this.restartSameDifficulty();
            }
            
            backToTitle() {
                this.gameState = 'title';
                
                // BGMåœæ­¢
                this.stopBGM();
                
                // ç”»é¢è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('endingScreen').style.display = 'none';
                document.getElementById('returnToBaseScreen').style.display = 'none';
                document.getElementById('titleScreen').style.display = 'flex';
                document.getElementById('difficultyScreen').style.display = 'none';
                document.getElementById('instructionsScreen').style.display = 'none';
                document.getElementById('gameModeScreen').style.display = 'none';
                
                // UIè¦ç´ ã‚’éè¡¨ç¤º
                document.getElementById('earthHealth').style.display = 'none';
                document.getElementById('dayInfo').style.display = 'none';
                document.getElementById('turnInfo').style.display = 'none';
                document.getElementById('effectsLog').style.display = 'none';
                document.getElementById('inventoryUI').style.display = 'none';
                
                // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.bullets = [];
                this.enemies = [];
                this.explosions = [];
                this.powerups = [];
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height - 100;
                this.player.shield = false;
                this.player.shieldTime = 0;
                this.player.speed = this.isMobile() ? 4 : 5;
                
                // ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã®åˆæœŸåŒ–
                this.player.gridX = Math.floor(this.gridWidth / 2);
                this.player.gridY = this.gridHeight - 3;
                
                // ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ­£ç¢ºãªã‚°ãƒªãƒƒãƒ‰ä½ç½®ã«é…ç½®
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                    this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                }
                
                // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å›ºæœ‰ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.earthHealth = this.maxEarthHealth;
                this.turnCount = 1;
                this.playerMoved = false;
                this.enemyTurnSkip = {};
                
                // DAYã‚·ã‚¹ãƒ†ãƒ ã®ãƒªã‚»ãƒƒãƒˆ
                this.currentDay = 1;
                this.dayCleared = false;
                this.endlessMode = false;
                
                // æ­¦å™¨ãƒªã‚»ãƒƒãƒˆ
                this.weapons = {
                    basicShot: { level: 1, maxLevel: 5, lastShot: 0, cooldown: 150 },
                    spreadShot: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 200 },
                    laser: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 300 },
                    missile: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 800 },
                    orbit: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 100 },
                    piercing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 250 },
                    homing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 400 },
                    barrier: { level: 0, maxLevel: 3, lastShot: 0, cooldown: 1000 }
                };
                
                this.orbitingBullets = [];
                this.barrierBullets = [];
                
                // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®ãƒªã‚»ãƒƒãƒˆ
                this.inventory = {
                    explosion: 0
                };
                
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã«æˆ»ã™
                this.gameMode = 'classic';
                this.difficulty = 'normal';
                this.difficultySettings = this.getDifficultySettings('normal');
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        let game;
        window.addEventListener('load', () => {
            game = new WireframeShooter();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'967a1748341dd54b',t:'MTc1MzkzMzQwMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
  <button id="fullscreenBtn" onclick="toggleFullScreen()">â›¶ å…¨ç”»é¢</button>

  <script>
    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch((err) => {
          alert(`å…¨ç”»é¢ã«ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    }
  </script>
</body>
</html>
