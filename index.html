<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Space Survivor - ワイヤーフレームシューティング</title>
    <style>
  html, body {
    width: 100%;
    height: 100%;
    overflow: auto;
    font-size: 16px;
    box-sizing: border-box;
  }
  canvas {
    max-width: 100%;
    height: auto;
    display: block;
  }
  #gameContainer, #mainMenu, #instructions, #fireControls, #mobileItemButtons {
    max-width: 100vw;
    overflow-x: auto;
    box-sizing: border-box;
    word-break: break-word;
  }
  .menu-button, .mobile-item-button {
    font-size: 1rem;
    padding: 12px;
  }
  @media (max-width: 480px) {
    .menu-button, .mobile-item-button {
      font-size: 0.9rem;
      padding: 10px;
    }
    #fireControls {
    position: fixed;
    bottom: 40px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    #mobileItemButtons {
      right: 10px;
      bottom: 100px;
    }
  }
    #fireBtn {
      width: 56px;
      height: 56px;
      font-size: 16px;
    }
  }
  #fullscreenBtn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 100;
    padding: 10px 15px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    border: none;
    border-radius: 8px;
    font-size: 14px;
  }
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
        }
        
        canvas {
            display: block;
            border: 2px solid #00ff00;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #00ff00;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 0 0 20px #ff0000;
            display: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
        }
        
        #rankingList {
            margin: 20px 0;
            text-align: left;
            color: #00ff00;
            font-size: 16px;
        }
        
        .ranking-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 10px;
            border: 1px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .ranking-item.new-record {
            color: #ffff00;
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
            animation: pulse 1s infinite;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            color: #00ff00;
            text-align: center;
        }
        
        #titleScreen h1 {
            font-size: 4rem;
            margin: 0;
            text-shadow: 0 0 30px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #titleScreen h2 {
            font-size: 1.5rem;
            margin: 10px 0 30px 0;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
        }
        
        #gameModeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 35;
            color: #00ff00;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .mode-btn {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid;
            color: #ffffff;
            padding: 20px;
            margin: 10px 0;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 500px;
        }
        
        .mode-btn.classic {
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .mode-btn.defense {
            border-color: #ff8800;
            color: #ff8800;
        }
        
        .mode-btn.turnbased {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .mode-btn.strategy {
            border-color: #ff00ff;
            color: #ff00ff;
        }
        
        .mode-btn:hover {
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mode-name {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .mode-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        
        #earthHealth {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 10;
            color: #ff8800;
            font-size: 18px;
            text-shadow: 0 0 10px #ff8800;
            display: none;
        }
        
        #turnInfo {
            position: absolute;
            top: 120px;
            left: 20px;
            z-index: 10;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            display: none;
        }
        
        #effectsLog {
            position: absolute;
            top: 160px;
            left: 20px;
            z-index: 10;
            color: #ffff00;
            font-size: 14px;
            text-shadow: 0 0 10px #ffff00;
            display: none;
            max-width: 300px;
        }
        
        #inventoryUI {
            position: absolute;
            top: 220px;
            left: 20px;
            z-index: 10;
            color: #ff8800;
            font-size: 14px;
            text-shadow: 0 0 10px #ff8800;
            display: none;
            max-width: 300px;
        }
        
        .inventory-item {
            background: rgba(255, 136, 0, 0.1);
            border: 1px solid #ff8800;
            padding: 8px 12px;
            margin: 3px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .inventory-item:hover {
            background: rgba(255, 136, 0, 0.2);
            transform: scale(1.02);
        }
        
        .inventory-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .inventory-item.disabled:hover {
            background: rgba(255, 136, 0, 0.1);
            transform: none;
        }
        
        .item-name {
            font-weight: bold;
            color: #ff8800;
        }
        
        .item-count {
            color: #ffff00;
            font-size: 12px;
            background: rgba(255, 255, 0, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid #ffff00;
        }
        
        .item-hotkey {
            color: #00ff00;
            font-size: 10px;
            opacity: 0.7;
            margin-left: 5px;
        }
        
        #commLog {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            color: #00ffaa;
            font-size: 12px;
            text-shadow: 0 0 10px #00ffaa;
            display: none;
            max-width: 350px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            padding: 10px;
            border-radius: 5px;
        }
        
        .comm-message {
            margin: 3px 0;
            padding: 2px 5px;
            border-left: 2px solid #00ffaa;
            background: rgba(0, 255, 170, 0.1);
            animation: fadeInComm 0.5s ease-in;
        }
        
        .comm-urgent {
            color: #ff4400;
            border-left-color: #ff4400;
            background: rgba(255, 68, 0, 0.2);
            text-shadow: 0 0 10px #ff4400;
        }
        
        .comm-warning {
            color: #ffaa00;
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.2);
            text-shadow: 0 0 10px #ffaa00;
        }
        
        @keyframes fadeInComm {
            0% { opacity: 0; transform: translateX(20px); }
            100% { opacity: 1; transform: translateX(0); }
        }
        
        .effect-item {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .effect-name {
            font-weight: bold;
        }
        
        .effect-duration {
            color: #00ff00;
            font-size: 12px;
        }
        
        #helpButton {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 15px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            display: none;
        }
        
        #helpButton:hover {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(1.05);
            text-shadow: 0 0 10px #00ff00;
        }
        
        .earth-damage-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0000;
            animation: damageFlash 0.5s ease-out;
            pointer-events: none;
            z-index: 15;
        }
        
        @keyframes damageFlash {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
        }
        
        .menu-button {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 15px 30px;
            margin: 10px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .menu-button:hover {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(1.05);
            text-shadow: 0 0 10px #00ff00;
        }
        
        .difficulty-btn {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid;
            color: #ffffff;
            padding: 20px;
            margin: 5px 0;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .difficulty-btn.easy {
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .difficulty-btn.normal {
            border-color: #ffff00;
            color: #ffff00;
        }
        
        .difficulty-btn.hard {
            border-color: #ff8800;
            color: #ff8800;
        }
        
        .difficulty-btn.expert {
            border-color: #ff4400;
            color: #ff4400;
        }
        
        .difficulty-btn.nightmare {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .difficulty-btn:hover {
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .diff-name {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .diff-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        
        #difficultyScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 35;
            color: #00ff00;
            padding: 20px;
            box-sizing: border-box;
        }
        
        #instructionsScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 35;
            color: #00ff00;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        .instructions-content {
            max-width: 800px;
            margin: 0 auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .instructions-content h2 {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .weapon-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .weapon-item {
            border: 1px solid #00ff00;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .weapon-icon {
            width: 40px;
            height: 40px;
            border: 2px solid;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .weapon-name {
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .weapon-desc {
            font-size: 12px;
            opacity: 0.8;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes mapEffectFade {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1.0);
            }
        }
        
        @media (max-width: 768px) {
            #titleScreen h1 {
                font-size: 2.5rem;
            }
            
            #titleScreen h2 {
                font-size: 1.2rem;
            }
            
            .menu-button {
                padding: 12px 25px;
                font-size: 16px;
            }
            
            .instructions-content {
                font-size: 12px;
            }
            
            .weapon-grid {
                grid-template-columns: 1fr;
            }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 14px;
            opacity: 0.7;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 40px;
            left: 20px;
            display: none;
        }
        
        #fireControls {
            position: absolute;
            bottom: 40px;
            right: 20px;
            display: none;
        }
        
        .control-btn {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            user-select: none;
            touch-action: manipulation;
            font-family: 'Courier New', monospace;
        }
        
        .control-btn:active {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(0.95);
        }
        
        #dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            margin-bottom: 20px;
        }
        
        #fireBtn  {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background-color: rgba(255, 80, 80, 0.9);
    color: white;
    font-size: 18px;
    font-weight: bold;
    border: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
  }
        
        #fireBtn:active {
            background: rgba(255, 255, 0, 0.4);
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            #fireControls {
                display: block;
            }
            
            #instructions {
                display: none;
            }
            
            #ui {
                font-size: 16px;
            }
            
            body {
                touch-action: none;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
        }
        
        .wireframe {
            stroke: #00ff00;
            fill: none;
            stroke-width: 2;
        }
        
        .enemy {
            stroke: #ff4444;
            fill: none;
            stroke-width: 2;
        }
        
        .bullet {
            stroke: #ffff00;
            fill: #ffff00;
            stroke-width: 1;
        }
        
        .explosion {
            stroke: #ff8800;
            fill: none;
            stroke-width: 3;
        }
    </style>
</head>
<body style="margin:0; padding:0; overflow:auto; touch-action:manipulation; -webkit-overflow-scrolling: touch;">
    <div id="gameContainer">
        <div id="titleScreen">
            <h1>SPACE SURVIVOR</h1>
            <h2>ワイヤーフレーム シューティング</h2>
            <button class="menu-button" onclick="game.showGameModeSelect()">ゲーム開始</button>
            <button class="menu-button" onclick="game.showInstructions()">操作説明</button>
        </div>
        
        <div id="gameModeScreen">
            <div class="instructions-content" style="text-align: center; max-width: 600px;">
                <h2 style="color: #00ffff; margin-bottom: 30px;">ゲームモード選択</h2>
                
                <div class="mode-grid" style="display: grid; gap: 15px; margin: 30px 0;">
                    <button class="mode-btn classic" onclick="game.selectGameMode('classic')">
                        <span class="mode-name">クラシック</span>
                        <span class="mode-desc">従来のシューティングゲーム - 敵を倒してスコアを稼ぐ</span>
                    </button>
                    
                    <button class="mode-btn defense" onclick="game.selectGameMode('defense')">
                        <span class="mode-name">地球防衛</span>
                        <span class="mode-desc">敵が画面下部に到達すると地球がダメージ - 地球を守り抜け</span>
                    </button>
                    
                    <button class="mode-btn turnbased" onclick="game.selectGameMode('turnbased')">
                        <span class="mode-name">ターンベース</span>
                        <span class="mode-desc">自機が動くと敵も下に向かって移動 - 戦略的な移動が重要</span>
                    </button>
                    
                    <button class="mode-btn strategy" onclick="game.selectGameMode('strategy')">
                        <span class="mode-name">ストラテジー</span>
                        <span class="mode-desc">地球防衛 + ターンベース - 究極の戦略モード</span>
                    </button>
                </div>
                
                <button class="menu-button" onclick="game.hideGameModeSelect()">戻る</button>
            </div>
        </div>
        
        <div id="difficultyScreen" style="display: none;">
            <div class="instructions-content" style="text-align: center; max-width: 600px;">
                <h2 style="color: #00ffff; margin-bottom: 30px;">難易度選択</h2>
                
                <div class="difficulty-grid" style="display: grid; gap: 15px; margin: 30px 0;">
                    <button class="difficulty-btn easy" onclick="game.startGameWithDifficulty('easy')">
                        <span class="diff-name">EASY</span>
                        <span class="diff-desc">初心者向け - アイテム多め、敵少なめ</span>
                    </button>
                    
                    <button class="difficulty-btn normal" onclick="game.startGameWithDifficulty('normal')">
                        <span class="diff-name">NORMAL</span>
                        <span class="diff-desc">標準的な難易度 - バランス重視</span>
                    </button>
                    
                    <button class="difficulty-btn hard" onclick="game.startGameWithDifficulty('hard')">
                        <span class="diff-name">HARD</span>
                        <span class="diff-desc">上級者向け - 敵多め、アイテム少なめ</span>
                    </button>
                    
                    <button class="difficulty-btn expert" onclick="game.startGameWithDifficulty('expert')">
                        <span class="diff-name">EXPERT</span>
                        <span class="diff-desc">エキスパート - 高速敵、アイテム激減</span>
                    </button>
                    
                    <button class="difficulty-btn nightmare" onclick="game.startGameWithDifficulty('nightmare')">
                        <span class="diff-name">NIGHTMARE</span>
                        <span class="diff-desc">悪夢級 - 最高難易度、生存が困難</span>
                    </button>
                </div>
                
                <button class="menu-button" onclick="game.hideDifficultySelect()">戻る</button>
            </div>
        </div>
        
        <div id="instructionsScreen">
            <div class="instructions-content">
                <h2>🎮 操作方法</h2>
                <p><strong>PC:</strong> 矢印キー：移動 | スペース：射撃 | ESC：ポーズ</p>
                <p><strong>ターンベース・ストラテジー:</strong> Qキー：エクスプロージョン使用</p>
                <p><strong>モバイル:</strong> 画面下のボタンで操作</p>
                
                <h2>🎯 ゲームモード</h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff00; color: #00ff00;">C</div>
                        <div class="weapon-name" style="color: #00ff00;">クラシック</div>
                        <div class="weapon-desc">従来のシューティング。敵を倒してスコアを稼ぐ。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff8800; color: #ff8800;">D</div>
                        <div class="weapon-name" style="color: #ff8800;">地球防衛</div>
                        <div class="weapon-desc">敵が画面下部に到達すると地球がダメージ。地球HPが0になるとゲームオーバー。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">T</div>
                        <div class="weapon-name" style="color: #00ffff;">ターンベース</div>
                        <div class="weapon-desc">自機が動くと敵も下に向かって移動。戦略的な移動が重要。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">S</div>
                        <div class="weapon-name" style="color: #ff00ff;">ストラテジー</div>
                        <div class="weapon-desc">地球防衛とターンベースを組み合わせた究極の戦略モード。</div>
                    </div>
                </div>
                
                <h2>⚔️ 武器システム</h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">|</div>
                        <div class="weapon-name" style="color: #ffff00;">基本射撃</div>
                        <div class="weapon-desc">最大3連射まで強化可能。基本となる武器。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff8800; color: #ff8800;">|||</div>
                        <div class="weapon-name" style="color: #ff8800;">拡散射撃</div>
                        <div class="weapon-desc">扇状に多数の弾を発射。広範囲攻撃。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">━</div>
                        <div class="weapon-name" style="color: #00ffff;">レーザー</div>
                        <div class="weapon-desc">画面を貫通する強力なビーム攻撃。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff0000; color: #ff0000;">◆</div>
                        <div class="weapon-name" style="color: #ff0000;">ミサイル</div>
                        <div class="weapon-desc">爆発範囲ダメージ付きの重火器。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff88; color: #00ff88;">○</div>
                        <div class="weapon-name" style="color: #00ff88;">軌道弾</div>
                        <div class="weapon-desc">プレイヤーの周りを回転する防御兼攻撃。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff00; color: #00ff00;">→</div>
                        <div class="weapon-name" style="color: #00ff00;">貫通弾</div>
                        <div class="weapon-desc">複数の敵を貫通する弾。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">◎</div>
                        <div class="weapon-name" style="color: #ff00ff;">追尾弾</div>
                        <div class="weapon-desc">敵を自動で追いかける弾。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #8800ff; color: #8800ff;">⊕</div>
                        <div class="weapon-name" style="color: #8800ff;">バリア</div>
                        <div class="weapon-desc">プレイヤー周囲に防御弾を配置。</div>
                    </div>
                </div>
                
                <h2>⚡ ターンベース・ストラテジー専用アイテム</h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">❄</div>
                        <div class="weapon-name" style="color: #00ffff;">敵全体凍結</div>
                        <div class="weapon-desc">3ターンの間、全ての敵の行動を停止。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">⏰</div>
                        <div class="weapon-name" style="color: #ffff00;">時間減速</div>
                        <div class="weapon-desc">5ターンの間、敵の移動速度を大幅に減少。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">🛡</div>
                        <div class="weapon-name" style="color: #00ffff;">全体シールド</div>
                        <div class="weapon-desc">10ターンの間、全てのダメージを無効化。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">2X</div>
                        <div class="weapon-name" style="color: #ffff00;">スコア2倍</div>
                        <div class="weapon-desc">10ターンの間、獲得スコアが2倍になる。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff8800; color: #ff8800;">⚡</div>
                        <div class="weapon-name" style="color: #ff8800;">連射強化</div>
                        <div class="weapon-desc">5ターンの間、全武器の発射間隔が短縮。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">★</div>
                        <div class="weapon-name" style="color: #ff00ff;">無敵状態</div>
                        <div class="weapon-desc">3ターンの間、敵との接触ダメージを無効化。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff0000; color: #ff0000;">💥</div>
                        <div class="weapon-name" style="color: #ff0000;">エクスプロージョン</div>
                        <div class="weapon-desc">画面上の全ての敵を即座に破壊する。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff00ff; color: #ff00ff;">🌀</div>
                        <div class="weapon-name" style="color: #ff00ff;">時空歪曲</div>
                        <div class="weapon-desc">全ての敵を過去の位置に戻す。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ffff00; color: #ffff00;">⚡</div>
                        <div class="weapon-name" style="color: #ffff00;">雷撃</div>
                        <div class="weapon-desc">ランダムな敵5体に大ダメージを与える。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ff00; color: #00ff00;">+</div>
                        <div class="weapon-name" style="color: #00ff00;">地球回復</div>
                        <div class="weapon-desc">地球HPを30回復（地球防衛・ストラテジーモード）。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff4400; color: #ff4400;">⚡</div>
                        <div class="weapon-name" style="color: #ff4400;">エネルギーストーム</div>
                        <div class="weapon-desc">4ターンの間、敵に継続的なダメージを与える。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #8800ff; color: #8800ff;">🔮</div>
                        <div class="weapon-name" style="color: #8800ff;">磁力フィールド</div>
                        <div class="weapon-desc">6ターンの間、敵を画面中央に引き寄せる。</div>
                    </div>
                </div>
                
                <h2>🎁 その他のアイテム</h2>
                <div class="weapon-grid">
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #00ffff; color: #00ffff;">◯</div>
                        <div class="weapon-name" style="color: #00ffff;">シールド</div>
                        <div class="weapon-desc">一定時間ダメージを無効化。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #ff0080; color: #ff0080;">♥</div>
                        <div class="weapon-name" style="color: #ff0080;">ライフ</div>
                        <div class="weapon-desc">残機を1つ回復。</div>
                    </div>
                    <div class="weapon-item">
                        <div class="weapon-icon" style="border-color: #88ff00; color: #88ff00;">⇒</div>
                        <div class="weapon-name" style="color: #88ff00;">スピード</div>
                        <div class="weapon-desc">移動速度を永続的に向上。</div>
                    </div>
                </div>
                
                <h2>👾 敵の種類</h2>
                <p><span style="color: #ff4444;">■ 通常敵</span> - 100点 | <span style="color: #ff0000;">■ 高速敵</span> - 200点 | <span style="color: #ffaa00;">■ 重装敵</span> - 300点</p>
                <p><span style="color: #ff8800;">■ 射撃敵</span> - 250点 | <span style="color: #ff6600;">■ ジグザグ敵</span> - 150点</p>
                
                <button class="menu-button" onclick="game.hideInstructions()">戻る</button>
            </div>
        </div>
        
        <div id="ui">
            <div>スコア: <span id="score">0</span></div>
            <div>ライフ: <span id="lives">3</span></div>
            <div>レベル: <span id="level">1</span></div>
        </div>
        
        <div id="earthHealth">
            地球HP: <span id="earthHp">100</span>
            <div id="dayInfo" style="margin-top: 5px; display: none;">
                <span id="currentDay">DAY 1</span> | 目標: <span id="dayTarget">5,000</span>
            </div>
        </div>
        
        <div id="turnInfo">
            <div>ターン: <span id="turnCount">1</span></div>
        </div>
        
        <div id="effectsLog">
            <div style="font-weight: bold; margin-bottom: 5px;">アクティブ効果:</div>
            <div id="effectsList"></div>
        </div>
        
        <div id="inventoryUI">
            <div style="font-weight: bold; margin-bottom: 5px;">手持ちアイテム:</div>
            <div id="inventoryList"></div>
        </div>
        
        <div id="commLog">
            <div style="font-weight: bold; margin-bottom: 5px; color: #00ffaa;">🛰️ 防衛司令部通信</div>
            <div id="commMessages"></div>
        </div>
        
        <button id="helpButton" onclick="game.showInstructions()">操作説明</button>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameOver">
            <h2>ゲームオーバー</h2>
            <p>最終スコア: <span id="finalScore">0</span></p>
            <p>難易度: <span id="finalDifficulty">NORMAL</span></p>
            <div id="rankingList">
                <h3 style="text-align: center; color: #00ffff; margin-bottom: 15px;">🏆 ハイスコア ランキング</h3>
                <div id="rankingItems"></div>
            </div>
            <div style="margin-top: 20px;">
                <button class="menu-button" onclick="game.restartSameDifficulty()" style="margin: 5px;">リスタート</button>
                <button class="menu-button" onclick="game.backToTitle()" style="margin: 5px;">タイトルに戻る</button>
            </div>
            <p style="margin-top: 15px; font-size: 14px; opacity: 0.7;">スペースキー: リスタート | ESC: タイトルに戻る</p>
        </div>
        
        <div id="returnToBaseScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; justify-content: center; align-items: center; z-index: 40; color: #00ff00; text-align: center; padding: 20px; box-sizing: border-box;">
            <div style="max-width: 700px;">
                <h1 style="font-size: 2.5rem; margin: 0 0 20px 0; text-shadow: 0 0 30px #00ff00; animation: pulse 2s infinite;">🛰️ 本部帰還 🛰️</h1>
                <h2 id="dayCompleteTitle" style="font-size: 1.5rem; margin: 0 0 30px 0; color: #00ffff; text-shadow: 0 0 20px #00ffff;">DAY 1 クリア！</h2>
                
                <div style="margin: 30px 0; padding: 20px; border: 2px solid #00ff00; background: rgba(0, 255, 0, 0.1); border-radius: 10px;">
                    <p style="font-size: 1.2rem; margin: 10px 0;">現在スコア: <span id="returnScore" style="color: #ffff00;">0</span></p>
                    <p style="font-size: 1.2rem; margin: 10px 0;">地球HP: <span id="returnEarthHp" style="color: #00ff88;">100</span></p>
                    <p style="font-size: 1rem; margin: 15px 0; color: #00ffff;">パワーアップは次のDAYに継続されます</p>
                </div>
                
                <div id="congratsMessage" style="margin: 30px 0; padding: 25px; border: 2px solid #ffff00; background: rgba(255, 255, 0, 0.1); border-radius: 10px; min-height: 120px; display: flex; align-items: center; justify-content: center;">
                    <p id="congratsText" style="font-size: 1.1rem; margin: 0; color: #ffff00; line-height: 1.6;"></p>
                </div>
                
                <div style="margin-top: 40px;">
                    <button class="menu-button" onclick="game.proceedToNextDay()" style="margin: 10px; background: rgba(0, 255, 255, 0.2); border-color: #00ffff; color: #00ffff;">次のDAYに進む</button>
                    <button class="menu-button" onclick="game.backToTitle()" style="margin: 10px;">タイトルに戻る</button>
                </div>
                
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.7;">スペースキー: 次のDAYに進む | ESC: タイトルに戻る</p>
            </div>
        </div>
        
        <div id="endingScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; justify-content: center; align-items: center; z-index: 40; color: #00ff00; text-align: center; padding: 20px; box-sizing: border-box;">
            <div style="max-width: 600px;">
                <h1 style="font-size: 3rem; margin: 0 0 20px 0; text-shadow: 0 0 30px #00ff00; animation: pulse 2s infinite;">🌍 地球防衛完了 🌍</h1>
                <h2 style="font-size: 1.5rem; margin: 0 0 30px 0; color: #00ffff; text-shadow: 0 0 20px #00ffff;">DAY 3 クリア！</h2>
                
                <div style="margin: 30px 0; padding: 20px; border: 2px solid #00ff00; background: rgba(0, 255, 0, 0.1); border-radius: 10px;">
                    <p style="font-size: 1.2rem; margin: 10px 0;">最終スコア: <span id="endingScore" style="color: #ffff00;">0</span></p>
                    <p style="font-size: 1.2rem; margin: 10px 0;">難易度: <span id="endingDifficulty" style="color: #ff8800;">NORMAL</span></p>
                    <p style="font-size: 1rem; margin: 15px 0; color: #00ffff;">あなたの勇敢な戦いにより、地球は救われました！</p>
                </div>
                
                <div style="margin: 30px 0;">
                    <p style="font-size: 1rem; margin: 10px 0; opacity: 0.8;">防衛クルーの皆様、お疲れ様でした。</p>
                    <p style="font-size: 1rem; margin: 10px 0; opacity: 0.8;">地球の平和は守られましたが、宇宙の脅威は続きます...</p>
                </div>
                
                <div style="margin-top: 40px;">
                    <button class="menu-button" onclick="game.startEndlessMode()" style="margin: 10px; background: rgba(255, 255, 0, 0.2); border-color: #ffff00; color: #ffff00;">エンドレスモードに挑戦</button>
                    <button class="menu-button" onclick="game.restartSameDifficulty()" style="margin: 10px;">DAY 1からリスタート</button>
                    <button class="menu-button" onclick="game.backToTitle()" style="margin: 10px;">タイトルに戻る</button>
                </div>
                
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.7;">スペースキー: エンドレスモード | ESC: タイトルに戻る</p>
            </div>
        </div>
        
        <div id="instructions">
            矢印キー: 移動 | スペース: 射撃 | ESC: ポーズ
        </div>
        
        <div id="mobileControls">
            <div id="dpad">
                <div></div>
                <button class="control-btn" data-key="ArrowUp">↑</button>
                <div></div>
                <button class="control-btn" data-key="ArrowLeft">←</button>
                <div></div>
                <button class="control-btn" data-key="ArrowRight">→</button>
                <div></div>
                <button class="control-btn" data-key="ArrowDown">↓</button>
                <div></div>
            </div>
        </div>
        
        <div id="fireControls">
            <button id="fireBtn" class="control-btn" data-key="Space">射撃</button>
        </div>
    </div>

    <script>
        class WireframeShooter {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth - 4;
                this.canvas.height = window.innerHeight - 4;
                
                this.gameState = 'title'; // title, playing, paused, gameOver
                this.gameMode = 'classic'; // classic, defense, turnbased, strategy
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.difficulty = 'normal';
                this.difficultySettings = this.getDifficultySettings('normal');
                
                // グリッドシステム（ターンベース・ストラテジーモード用）
                this.gridSize = 40;
                this.gridWidth = Math.floor(this.canvas.width / this.gridSize);
                this.gridHeight = Math.floor(this.canvas.height / this.gridSize);
                
                // 地球防衛モード用
                this.earthHealth = 100;
                this.maxEarthHealth = 100;
                
                // DAYシステム（地球防衛モード）
                this.currentDay = 1;
                this.dayTargetScores = {
                    1: 5000,   // DAY1クリア条件
                    2: 15000,  // DAY2クリア条件
                    3: 30000   // DAY3クリア条件（エンディング）
                };
                this.dayCleared = false;
                this.endlessMode = false;
                
                // ターンベースモード用
                this.turnCount = 1;
                this.playerMoved = false;
                this.enemyTurnSkip = {}; // 時間減速効果用の敵ターンスキップ管理
                
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 100,
                    width: 40,
                    height: 30,
                    speed: this.isMobile() ? 4 : 5,
                    shield: false,
                    shieldTime: 0,
                    // グリッド座標（ターンベース・ストラテジーモード用）
                    gridX: Math.floor(this.gridWidth / 2),
                    gridY: this.gridHeight - 3
                };
                
                // 武器システム
                this.weapons = {
                    basicShot: { level: 1, maxLevel: 5, lastShot: 0, cooldown: 150 },
                    spreadShot: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 200 },
                    laser: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 300 },
                    missile: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 800 },
                    orbit: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 100 },
                    piercing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 250 },
                    homing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 400 },
                    barrier: { level: 0, maxLevel: 3, lastShot: 0, cooldown: 1000 }
                };
                
                this.orbitingBullets = [];
                this.barrierBullets = [];
                
                this.bullets = [];
                this.enemies = [];
                this.explosions = [];
                this.stars = [];
                this.earthSurface = [];
                this.powerups = [];
                
                // ターンベース・ストラテジーモード用の特殊アイテム
                this.mapEffects = {
                    freeze: { active: false, duration: 0 },
                    slowTime: { active: false, duration: 0 },
                    shield: { active: false, duration: 0 },
                    doubleScore: { active: false, duration: 0 },
                    rapidFire: { active: false, duration: 0 },
                    invincible: { active: false, duration: 0 },
                    magneticField: { active: false, duration: 0 },
                    energyStorm: { active: false, duration: 0 }
                };
                
                this.gridItems = []; // グリッドに配置される特殊アイテム
                
                // 手持ちアイテムシステム（ターンベース・ストラテジーモード用）
                this.inventory = {
                    explosion: 0  // エクスプロージョンの所持数
                };
                
                // 通信ログシステム（地球防衛モード用）
                this.currentCommMessage = null;
                this.lastCommTime = 0;
                this.commMessageId = 0;
                
                this.keys = {};
                this.lastShot = 0;
                this.shotCooldown = this.isMobile() ? 200 : 150;
                
                this.initializeStars();
                this.initializeEarthSurface();
                this.setupEventListeners();
                this.setupMobileControls();
                this.setupAudio();
                this.loadRankings();
                this.gameLoop();
            }
            
            getDifficultySettings(difficulty) {
                const settings = {
                    easy: {
                        enemySpawnRate: 0.015,
                        enemySpeedMultiplier: 0.7,
                        powerupSpawnRate: 0.012,
                        enemyHealthMultiplier: 0.8,
                        playerLives: 5,
                        defenseSpeedMultiplier: 0.4
                    },
                    normal: {
                        enemySpawnRate: 0.02,
                        enemySpeedMultiplier: 1.0,
                        powerupSpawnRate: 0.008,
                        enemyHealthMultiplier: 1.0,
                        playerLives: 3,
                        defenseSpeedMultiplier: 0.6
                    },
                    hard: {
                        enemySpawnRate: 0.028,
                        enemySpeedMultiplier: 1.3,
                        powerupSpawnRate: 0.005,
                        enemyHealthMultiplier: 1.2,
                        playerLives: 3,
                        defenseSpeedMultiplier: 0.8
                    },
                    expert: {
                        enemySpawnRate: 0.035,
                        enemySpeedMultiplier: 1.6,
                        powerupSpawnRate: 0.003,
                        enemyHealthMultiplier: 1.5,
                        playerLives: 2,
                        defenseSpeedMultiplier: 1.0
                    },
                    nightmare: {
                        enemySpawnRate: 0.045,
                        enemySpeedMultiplier: 2.0,
                        powerupSpawnRate: 0.002,
                        enemyHealthMultiplier: 2.0,
                        playerLives: 1,
                        defenseSpeedMultiplier: 1.2
                    }
                };
                return settings[difficulty] || settings.normal;
            }
            
            showGameModeSelect() {
                document.getElementById('gameModeScreen').style.display = 'flex';
            }
            
            hideGameModeSelect() {
                document.getElementById('gameModeScreen').style.display = 'none';
            }
            
            selectGameMode(mode) {
                this.gameMode = mode;
                document.getElementById('gameModeScreen').style.display = 'none';
                this.showDifficultySelect();
            }
            
            showDifficultySelect() {
                document.getElementById('difficultyScreen').style.display = 'flex';
            }
            
            hideDifficultySelect() {
                document.getElementById('difficultyScreen').style.display = 'none';
            }
            
            startGameWithDifficulty(difficulty) {
                this.difficulty = difficulty;
                this.difficultySettings = this.getDifficultySettings(difficulty);
                this.gameState = 'playing';
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('difficultyScreen').style.display = 'none';
                
                // UI表示の切り替え
                this.updateUIVisibility();
                
                // BGM開始
                this.startBGM();
                
                this.restart();
                
                // ターンベース・ストラテジーモードでは初期アイテムを配置
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.spawnInitialGridItems();
                    // 難易度に応じて初期エクスプロージョンを付与
                    this.giveInitialInventoryItems();
                }
            }
            
            updateUIVisibility() {
                // 地球防衛モードまたはストラテジーモードの場合、地球HPを表示
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    document.getElementById('earthHealth').style.display = 'block';
                    
                    // 地球防衛モードまたはストラテジーモードの場合、DAY情報も表示
                    if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                        document.getElementById('dayInfo').style.display = 'block';
                    } else {
                        document.getElementById('dayInfo').style.display = 'none';
                    }
                } else {
                    document.getElementById('earthHealth').style.display = 'none';
                    document.getElementById('dayInfo').style.display = 'none';
                }
                
                // ターンベースモードまたはストラテジーモードの場合、ターン情報を表示
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    document.getElementById('turnInfo').style.display = 'block';
                    document.getElementById('effectsLog').style.display = 'block';
                    document.getElementById('inventoryUI').style.display = 'block';
                } else {
                    document.getElementById('turnInfo').style.display = 'none';
                    document.getElementById('effectsLog').style.display = 'none';
                    document.getElementById('inventoryUI').style.display = 'none';
                }
                
                // 地球防衛モードまたはストラテジーモードの場合、通信ログを表示
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    document.getElementById('commLog').style.display = 'block';
                    // 初期通信メッセージを送信
                    this.addCommMessage('防衛司令部より、地球防衛作戦を開始します', 'normal');
                    this.addCommMessage('敵の侵攻を阻止し、地球を守り抜いてください', 'normal');
                } else {
                    document.getElementById('commLog').style.display = 'none';
                }
                
                // ゲーム中は操作説明ボタンを表示
                if (this.gameState === 'playing') {
                    document.getElementById('helpButton').style.display = 'block';
                } else {
                    document.getElementById('helpButton').style.display = 'none';
                }
            }
            
            startGame() {
                this.gameState = 'playing';
                document.getElementById('titleScreen').style.display = 'none';
                this.restart();
            }
            
            showInstructions() {
                if (this.gameState === 'playing') this.gameState = 'paused';
                document.getElementById('instructionsScreen').style.display = 'block';
                // ゲーム中の場合は一時停止
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                }
            }
            
            hideInstructions() {
                document.getElementById('instructionsScreen').style.display = 'none';
                // ゲームが一時停止中だった場合は再開
                if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                }
            }
            
            isMobile() {
                return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            
applyActiveEffects() {
    // スピードアップ処理
    if (this.mapEffects.rapidFire && this.mapEffects.rapidFire.active) {
        this.player.speed = this.isMobile() ? 6 : 7;
    } else {
        this.player.speed = this.isMobile() ? 4 : 5;
    }

    // 無敵状態フラグ
    this.player.invincible = this.mapEffects.invincible && this.mapEffects.invincible.active;
}


    setupAudio() {
                this.audioContext = null;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.setupBGM();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            setupBGM() {
                if (!this.audioContext) return;
                
                this.bgmPlaying = false;
                this.bgmGainNode = null;
                this.bgmOscillators = [];
                
                // 神秘的な宇宙のアルペジオパターン
                // Cマイナーペンタトニック + 浮遊感のある音程
                this.arpeggioPattern = [
                    { note: 'C4', freq: 261.63 },
                    { note: 'Eb4', freq: 311.13 },
                    { note: 'F4', freq: 349.23 },
                    { note: 'G4', freq: 392.00 },
                    { note: 'Bb4', freq: 466.16 },
                    { note: 'C5', freq: 523.25 },
                    { note: 'Eb5', freq: 622.25 },
                    { note: 'F5', freq: 698.46 },
                    { note: 'G5', freq: 783.99 },
                    { note: 'Bb5', freq: 932.33 },
                    { note: 'C6', freq: 1046.50 }
                ];
                
                // 和音進行（神秘的な響き）
                this.chordProgression = [
                    [261.63, 311.13, 392.00], // Cm
                    [293.66, 349.23, 440.00], // Dm
                    [311.13, 392.00, 466.16], // Eb
                    [349.23, 440.00, 523.25], // F
                    [392.00, 466.16, 587.33], // G
                    [466.16, 587.33, 698.46], // Bb
                    [523.25, 659.25, 783.99], // C
                    [392.00, 493.88, 587.33]  // G7
                ];
                
                this.currentArpeggioIndex = 0;
                this.currentChordIndex = 0;
                this.arpeggioTimer = 0;
                this.chordTimer = 0;
            }
            
            startBGM() {
                if (!this.audioContext || this.bgmPlaying) return;
                
                try {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.bgmPlaying = true;
                    this.bgmGainNode = this.audioContext.createGain();
                    this.bgmGainNode.connect(this.audioContext.destination);
                    this.bgmGainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    
                    this.playArpeggio();
                    this.playChords();
                    
                } catch (e) {
                    console.log('BGM start failed');
                }
            }
            
            stopBGM() {
                if (!this.bgmPlaying) return;
                
                this.bgmPlaying = false;
                
                // 全てのオシレーターを停止
                this.bgmOscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // オシレーターが既に停止している場合
                    }
                });
                this.bgmOscillators = [];
                
                if (this.bgmGainNode) {
                    this.bgmGainNode.disconnect();
                    this.bgmGainNode = null;
                }
                
                clearTimeout(this.arpeggioTimer);
                clearTimeout(this.chordTimer);
            }
            
            playArpeggio() {
                if (!this.bgmPlaying || !this.audioContext) return;
                
                try {
                    // 不規則な音階選択で浮遊感を演出
                    let note;
                    const rand = Math.random();
                    
                    if (rand < 0.4) {
                        // 40%の確率で順次進行
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                        this.currentArpeggioIndex = (this.currentArpeggioIndex + 1) % this.arpeggioPattern.length;
                    } else if (rand < 0.7) {
                        // 30%の確率で大きくジャンプ（上昇）
                        const jumpSize = 3 + Math.floor(Math.random() * 4); // 3-6音程ジャンプ
                        this.currentArpeggioIndex = (this.currentArpeggioIndex + jumpSize) % this.arpeggioPattern.length;
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                    } else if (rand < 0.85) {
                        // 15%の確率で下降ジャンプ
                        const jumpSize = 2 + Math.floor(Math.random() * 3); // 2-4音程下降
                        this.currentArpeggioIndex = (this.currentArpeggioIndex - jumpSize + this.arpeggioPattern.length) % this.arpeggioPattern.length;
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                    } else {
                        // 15%の確率で完全にランダムな音程
                        this.currentArpeggioIndex = Math.floor(Math.random() * this.arpeggioPattern.length);
                        note = this.arpeggioPattern[this.currentArpeggioIndex];
                    }
                    
                    // メインアルペジオ音
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.bgmGainNode);
                    
                    // 微細なピッチベンドで浮遊感を追加
                    const pitchVariation = 1 + (Math.random() - 0.5) * 0.02; // ±1%のピッチ変動
                    oscillator.frequency.setValueAtTime(note.freq * pitchVariation, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    // ローパスフィルターで柔らかい音色
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(2000 + Math.random() * 1000, this.audioContext.currentTime);
                    filterNode.Q.setValueAtTime(0.5 + Math.random() * 1, this.audioContext.currentTime);
                    
                    // 不規則なエンベロープで浮遊感を演出
                    const attackTime = 0.05 + Math.random() * 0.15; // 0.05-0.2秒のアタック
                    const sustainTime = 0.8 + Math.random() * 0.8; // 0.8-1.6秒のサスティン
                    const peakGain = 0.2 + Math.random() * 0.2; // 0.2-0.4のピークゲイン
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(peakGain, this.audioContext.currentTime + attackTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + attackTime + sustainTime);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + attackTime + sustainTime);
                    
                    this.bgmOscillators.push(oscillator);
                    
                    // オクターブ上下のハーモニー（煌びやかさを演出）
                    if (Math.random() > 0.4) {
                        const harmonyOsc = this.audioContext.createOscillator();
                        const harmonyGain = this.audioContext.createGain();
                        const harmonyFilter = this.audioContext.createBiquadFilter();
                        
                        harmonyOsc.connect(harmonyFilter);
                        harmonyFilter.connect(harmonyGain);
                        harmonyGain.connect(this.bgmGainNode);
                        
                        // ランダムにオクターブ上下を選択
                        const octaveMultiplier = Math.random() > 0.5 ? 2 : 0.5;
                        harmonyOsc.frequency.setValueAtTime(note.freq * octaveMultiplier * pitchVariation, this.audioContext.currentTime);
                        harmonyOsc.type = Math.random() > 0.5 ? 'triangle' : 'sine';
                        
                        harmonyFilter.type = 'lowpass';
                        harmonyFilter.frequency.setValueAtTime(2500 + Math.random() * 1500, this.audioContext.currentTime);
                        
                        const harmonyGainValue = 0.08 + Math.random() * 0.12;
                        harmonyGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        harmonyGain.gain.linearRampToValueAtTime(harmonyGainValue, this.audioContext.currentTime + 0.1 + Math.random() * 0.2);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6 + Math.random() * 0.8);
                        
                        const harmonyDelay = Math.random() * 0.3; // 0-0.3秒の遅延
                        harmonyOsc.start(this.audioContext.currentTime + harmonyDelay);
                        harmonyOsc.stop(this.audioContext.currentTime + harmonyDelay + 0.6 + Math.random() * 0.8);
                        
                        this.bgmOscillators.push(harmonyOsc);
                    }
                    
                    // 不規則な間隔でアルペジオを演奏（浮遊感を強化）
                    const baseDelay = 150 + Math.random() * 200; // 150-350ms
                    const rhythmVariation = Math.random() > 0.8 ? Math.random() * 300 : 0; // 20%の確率で大きな間隔
                    const nextDelay = baseDelay + rhythmVariation;
                    
                    this.arpeggioTimer = setTimeout(() => this.playArpeggio(), nextDelay);
                    
                } catch (e) {
                    console.log('Arpeggio playback failed');
                }
            }
            
            playChords() {
                if (!this.bgmPlaying || !this.audioContext) return;
                
                try {
                    const chord = this.chordProgression[this.currentChordIndex];
                    
                    chord.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        const filterNode = this.audioContext.createBiquadFilter();
                        
                        oscillator.connect(filterNode);
                        filterNode.connect(gainNode);
                        gainNode.connect(this.bgmGainNode);
                        
                        oscillator.frequency.setValueAtTime(freq * 0.5, this.audioContext.currentTime); // 低音域
                        oscillator.type = 'sawtooth';
                        
                        // ローパスフィルターで暖かい音色
                        filterNode.type = 'lowpass';
                        filterNode.frequency.setValueAtTime(800 + index * 200, this.audioContext.currentTime);
                        filterNode.Q.setValueAtTime(0.5, this.audioContext.currentTime);
                        
                        // 長いエンベロープ（パッド的な響き）
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.08, this.audioContext.currentTime + 0.5);
                        gainNode.gain.linearRampToValueAtTime(0.06, this.audioContext.currentTime + 3.0);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 4.0);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 4.0);
                        
                        this.bgmOscillators.push(oscillator);
                    });
                    
                    // アンビエント効果音（宇宙の神秘感）
                    if (Math.random() > 0.7) {
                        const ambientOsc = this.audioContext.createOscillator();
                        const ambientGain = this.audioContext.createGain();
                        const ambientFilter = this.audioContext.createBiquadFilter();
                        
                        ambientOsc.connect(ambientFilter);
                        ambientFilter.connect(ambientGain);
                        ambientGain.connect(this.bgmGainNode);
                        
                        ambientOsc.frequency.setValueAtTime(100 + Math.random() * 200, this.audioContext.currentTime);
                        ambientOsc.type = 'sine';
                        
                        ambientFilter.type = 'highpass';
                        ambientFilter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        
                        ambientGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        ambientGain.gain.linearRampToValueAtTime(0.03, this.audioContext.currentTime + 1.0);
                        ambientGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 3.0);
                        
                        ambientOsc.start(this.audioContext.currentTime + 0.5);
                        ambientOsc.stop(this.audioContext.currentTime + 3.0);
                        
                        this.bgmOscillators.push(ambientOsc);
                    }
                    
                    // 次のコードへ
                    this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
                    
                    // コード進行の間隔
                    this.chordTimer = setTimeout(() => this.playChords(), 4000);
                    
                } catch (e) {
                    console.log('Chord playback failed');
                }
            }
            

            
            loadRankings() {
                try {
                    const saved = localStorage.getItem('spaceShooterRankings');
                    this.rankings = saved ? JSON.parse(saved) : {
                        classic: [],
                        defense: [],
                        turnbased: [],
                        strategy: []
                    };
                    
                    // 旧形式のデータを新形式に変換
                    if (Array.isArray(this.rankings)) {
                        const oldRankings = this.rankings;
                        this.rankings = {
                            classic: oldRankings.filter(r => r.gameMode === 'classic' || !r.gameMode),
                            defense: [],
                            turnbased: [],
                            strategy: []
                        };
                        this.saveRankings();
                    }
                } catch (e) {
                    this.rankings = {
                        classic: [],
                        defense: [],
                        turnbased: [],
                        strategy: []
                    };
                }
            }
            
            saveRankings() {
                try {
                    localStorage.setItem('spaceShooterRankings', JSON.stringify(this.rankings));
                } catch (e) {
                    console.log('Failed to save rankings');
                }
            }
            
            addToRanking(score, difficulty, gameMode) {
                const newRecord = {
                    score: score,
                    difficulty: difficulty,
                    gameMode: gameMode,
                    date: new Date().toLocaleDateString('ja-JP')
                };
                
                // 該当ゲームモードのランキングに追加
                if (!this.rankings[gameMode]) {
                    this.rankings[gameMode] = [];
                }
                
                this.rankings[gameMode].push(newRecord);
                this.rankings[gameMode].sort((a, b) => b.score - a.score);
                this.rankings[gameMode] = this.rankings[gameMode].slice(0, 10); // トップ10のみ保持
                
                this.saveRankings();
                return this.rankings[gameMode].findIndex(r => r === newRecord);
            }
            
            displayRankings(newRecordIndex = -1) {
                const rankingItems = document.getElementById('rankingItems');
                rankingItems.innerHTML = '';
                
                const currentRankings = this.rankings[this.gameMode] || [];
                
                if (currentRankings.length === 0) {
                    rankingItems.innerHTML = '<div style="text-align: center; color: #666;">まだ記録がありません</div>';
                    return;
                }
                
                currentRankings.forEach((record, index) => {
                    const item = document.createElement('div');
                    item.className = 'ranking-item';
                    if (index === newRecordIndex) {
                        item.classList.add('new-record');
                    }
                    
                    const difficultyColors = {
                        easy: '#00ff00',
                        normal: '#ffff00',
                        hard: '#ff8800',
                        expert: '#ff4400',
                        nightmare: '#ff0000'
                    };
                    
                    const difficultyNames = {
                        easy: 'EASY',
                        normal: 'NORMAL',
                        hard: 'HARD',
                        expert: 'EXPERT',
                        nightmare: 'NIGHTMARE'
                    };
                    
                    item.innerHTML = `
                        <span>${index + 1}. ${record.score.toLocaleString()}点</span>
                        <span style="color: ${difficultyColors[record.difficulty] || '#ffffff'}">
                            ${difficultyNames[record.difficulty] || record.difficulty.toUpperCase()}
                        </span>
                    `;
                    
                    rankingItems.appendChild(item);
                });
            }
            
            playBeep(frequency = 440, duration = 100, type = 'sine') {
                if (!this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (e) {
                    console.log('Audio playback failed');
                }
            }
            
            initializeStars() {
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 2 + 1
                    });
                }
            }
            
            initializeEarthSurface() {
                const segments = 20;
                const segmentWidth = this.canvas.width / segments;
                
                for (let i = 0; i <= segments; i++) {
                    this.earthSurface.push({
                        x: i * segmentWidth,
                        y: this.canvas.height - 50 + Math.sin(i * 0.5) * 20, // 波状の地形を復活
                        buildings: Math.random() < 0.4, // ランダムに建物を配置（40%の確率）
                        buildingHeight: Math.random() * 30 + 20 // 建物の高さもランダムに設定
                    });
                }
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    if (e.code === 'Escape') {
                        if (this.gameState === 'gameOver' || this.gameState === 'ending' || this.gameState === 'returnToBase') {
                            this.backToTitle();
                        } else {
                            this.togglePause();
                        }
                    }
                    
                    if (e.code === 'Space') {
                        if (this.gameState === 'gameOver') {
                            this.restartSameDifficulty();
                        } else if (this.gameState === 'ending') {
                            this.startEndlessMode();
                        } else if (this.gameState === 'returnToBase') {
                            this.proceedToNextDay();
                        }
                    }
                    
                    // 手持ちアイテムの使用（ターンベース・ストラテジーモード）
                    if (this.gameState === 'playing' && (this.gameMode === 'turnbased' || this.gameMode === 'strategy')) {
                        if (e.code === 'KeyQ') {
                            this.useInventoryItem('explosion');
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth - 4;
                    this.canvas.height = window.innerHeight - 4;
                });
                
                // タッチイベントの処理
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                });
            }
            
            setupMobileControls() {
                const controlButtons = document.querySelectorAll('.control-btn');
                
                controlButtons.forEach(button => {
                    const key = button.getAttribute('data-key');
                    
                    // タッチ開始
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys[key] = true;
                        
                        // モバイルでオーディオコンテキストを有効化
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                        
                        if (key === 'Space' && this.gameState === 'gameOver') {
                            this.restartSameDifficulty();
                        }
                    });
                    
                    // タッチ終了
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                    
                    // タッチキャンセル
                    button.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                    
                    // マウスイベント（デスクトップでのテスト用）
                    button.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.keys[key] = true;
                        
                        if (key === 'Space' && this.gameState === 'gameOver') {
                            this.restartSameDifficulty();
                        }
                    });
                    
                    button.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                    
                    button.addEventListener('mouseleave', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                });
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                // フレーム毎のヒット状態をリセット
                this.enemies.forEach(enemy => {
                    enemy.hitThisFrame = false;
                });
                
                this.updatePlayer();
                this.applyActiveEffects && this.applyActiveEffects();
                this.updateBullets();
                this.updateEnemies();
                this.updateExplosions();
                this.updateStars();
                this.updatePowerups();
                this.updateGridItems();
                this.updateMapEffects();
                this.spawnEnemies();
                this.spawnPowerups();
                this.checkCollisions();
                this.updateLevel();
            }
            
            updatePlayer() {
                let moved = false;
                let shot = false;
                
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    // グリッドベースの移動（ターンベース・ストラテジーモード）
                    if (!this.playerMoved) {
                        if (this.keys['ArrowLeft'] && this.player.gridX > 0) {
                            this.player.gridX--;
                            this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                            moved = true;
                            this.keys['ArrowLeft'] = false; // キー入力をリセット
                        }
                        if (this.keys['ArrowRight'] && this.player.gridX < this.gridWidth - 1) {
                            this.player.gridX++;
                            this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                            moved = true;
                            this.keys['ArrowRight'] = false;
                        }
                        if (this.keys['ArrowUp'] && this.player.gridY > 0) {
                            this.player.gridY--;
                            this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                            moved = true;
                            this.keys['ArrowUp'] = false;
                        }
                        if (this.keys['ArrowDown'] && this.player.gridY < this.gridHeight - 2) {
                            this.player.gridY++;
                            this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                            moved = true;
                            this.keys['ArrowDown'] = false;
                        }
                        
                        if (this.keys['Space']) {
                            this.shootAllWeapons();
                            shot = true;
                            this.keys['Space'] = false;
                        }
                        
                        // 移動または射撃した場合の処理
                        if (moved || shot) {
                            this.playerMoved = true;
                            // 敵の行動を実行
                            this.processEnemyTurnMovement();
                            // エフェクトの持続時間を減らす（ターン終了時）
                            this.updateTurnBasedEffects();
                        }
                    }
                } else {
                    // 通常の移動（クラシック・地球防衛モード）
                    if (this.keys['ArrowLeft'] && this.player.x > 0) {
                        this.player.x -= this.player.speed;
                    }
                    if (this.keys['ArrowRight'] && this.player.x < this.canvas.width - this.player.width) {
                        this.player.x += this.player.speed;
                    }
                    if (this.keys['ArrowUp'] && this.player.y > 0) {
                        this.player.y -= this.player.speed;
                    }
                    if (this.keys['ArrowDown'] && this.player.y < this.canvas.height - this.player.height - 60) {
                        this.player.y += this.player.speed;
                    }
                    
                    if (this.keys['Space']) {
                        this.shootAllWeapons();
                    }
                }
                
                // シールド時間の更新
                if (this.player.shield && this.player.shieldTime > 0) {
                    this.player.shieldTime--;
                    if (this.player.shieldTime <= 0) {
                        this.player.shield = false;
                    }
                }
            }
            
            processEnemyTurnMovement() {
                // 敵は2ターンに1回のみ行動（プレイヤー2ターン：敵1ターン）
                const shouldEnemyAct = this.turnCount % 2 === 0;
                
                // 凍結効果中でも敵の行動は停止するが、ターンは進行する
                if (!this.mapEffects.freeze.active && shouldEnemyAct) {
                    // 敵を逆順で処理（削除時のインデックスずれを防ぐ）
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        
                        // 時間減速効果：さらに行動頻度を下げる（4ターンに1回）
                        if (this.mapEffects.slowTime.active) {
                            if (!this.enemyTurnSkip[i]) {
                                this.enemyTurnSkip[i] = 0;
                            }
                            this.enemyTurnSkip[i]++;
                            
                            // 4ターンに1回のみ移動を許可
                            if (this.enemyTurnSkip[i] % 4 !== 0) {
                                continue; // このターンは移動しない
                            }
                        }
                        
                        if (enemy.type === 'enemy_bullet') {
                            // 敵の弾は下に向かって移動
                            if (enemy.gridY !== undefined) {
                                enemy.gridY++;
                                enemy.y = enemy.gridY * this.gridSize + this.gridSize/2 - enemy.height/2;
                            } else {
                                enemy.y += this.gridSize; // グリッド1つ分移動
                            }
                        } else {
                            // 通常の敵はグリッド1つ分下に移動
                            if (enemy.gridY !== undefined) {
                                const newGridY = enemy.gridY + 1;
                                let newGridX = enemy.gridX;
                                
                                // ジグザグ敵の特殊移動（確率を下げて処理負荷軽減）
                                if (enemy.type === 'zigzag' && Math.random() < 0.3) {
                                    const direction = Math.random() < 0.5 ? -1 : 1;
                                    const candidateGridX = enemy.gridX + direction;
                                    if (candidateGridX >= 0 && candidateGridX < this.gridWidth) {
                                        // 簡単な重複チェック（パフォーマンス重視）
                                        let occupied = false;
                                        for (let j = 0; j < this.enemies.length; j++) {
                                            if (j !== i && this.enemies[j].gridX === candidateGridX && this.enemies[j].gridY === newGridY) {
                                                occupied = true;
                                                break;
                                            }
                                        }
                                        if (!occupied) {
                                            newGridX = candidateGridX;
                                        }
                                    }
                                }
                                
                                // 移動先の重複チェック（簡略化）
                                let canMove = true;
                                for (let j = 0; j < this.enemies.length; j++) {
                                    if (j !== i && this.enemies[j].gridX === newGridX && this.enemies[j].gridY === newGridY) {
                                        canMove = false;
                                        break;
                                    }
                                }
                                
                                if (canMove) {
                                    enemy.gridY = newGridY;
                                    enemy.gridX = newGridX;
                                    enemy.x = enemy.gridX * this.gridSize + this.gridSize/2 - enemy.width/2;
                                    enemy.y = enemy.gridY * this.gridSize + this.gridSize/2 - enemy.height/2;
                                }
                            } else {
                                enemy.y += this.gridSize; // グリッド1つ分移動
                            }
                            
                            // 射撃敵の攻撃（確率を下げて処理負荷軽減）
                            if (enemy.type === 'shooter' && Math.random() < 0.2) {
                                this.enemyShoot(enemy);
                            }
                        }
                    }
                }
                
                // ターンベース・ストラテジーモードでの新しい敵の出現（敵が行動するターンのみ）
                if (shouldEnemyAct) {
                    this.spawnTurnBasedEnemies();
                }
                
                // ターンベース・ストラテジーモードでのアイテム出現（毎ターン判定）
                this.spawnTurnBasedItems();
                
                // ターンカウントを増加し、プレイヤーの行動フラグをリセット
                this.turnCount++;
                this.playerMoved = false;
            }
            
            spawnTurnBasedEnemies() {
                // ターンベース・ストラテジーモードでの敵出現（プレイヤーの行動後）
                const baseSpawnRate = 0.3; // 基本30%の出現率
                const levelBonus = this.level * 0.02; // レベルボーナス（控えめに）
                const spawnRate = Math.min(baseSpawnRate + levelBonus, 0.6); // 最大60%まで
                
                // 1ターンに最大2体まで出現
                const maxEnemies = Math.min(1 + Math.floor(this.level / 5), 2);
                
                // 利用可能なグリッド位置を事前に計算
                const availablePositions = [];
                for (let y = 0; y < 3; y++) { // 上部3行のみ
                    for (let x = 0; x < this.gridWidth; x++) {
                        if (!this.isGridOccupiedByEnemy(x, y)) {
                            availablePositions.push({ x, y });
                        }
                    }
                }
                
                // 利用可能な位置がない場合は早期終了
                if (availablePositions.length === 0) {
                    return;
                }
                
                let currentSpawnRate = spawnRate;
                for (let spawn = 0; spawn < maxEnemies && availablePositions.length > 0; spawn++) {
                    if (Math.random() < currentSpawnRate) {
                        const enemyType = this.getRandomEnemyType();
                        const enemyData = this.getEnemyData(enemyType);
                        
                        // ランダムに位置を選択
                        const positionIndex = Math.floor(Math.random() * availablePositions.length);
                        const position = availablePositions[positionIndex];
                        
                        // 選択した位置を利用可能リストから削除
                        availablePositions.splice(positionIndex, 1);
                        
                        let enemy = {
                            x: position.x * this.gridSize + this.gridSize/2 - enemyData.width/2,
                            y: position.y * this.gridSize + this.gridSize/2 - enemyData.height/2,
                            width: enemyData.width,
                            height: enemyData.height,
                            speed: enemyData.speed,
                            type: enemyType,
                            health: Math.ceil(enemyData.health * this.difficultySettings.enemyHealthMultiplier),
                            lastShot: 0,
                            shootCooldown: enemyData.shootCooldown || 0,
                            gridX: position.x,
                            gridY: position.y
                        };
                        
                        this.enemies.push(enemy);
                        
                        // ストラテジーモードでの通信メッセージ
                        if (this.gameMode === 'strategy' && Math.random() < 0.1) {
                            const enemyMessages = {
                                heavy: '重装甲型敵機を確認！',
                                shooter: '射撃型敵機接近中！',
                                fast: '高速型敵機を探知！',
                                zigzag: '不規則機動型敵機を確認'
                            };
                            
                            if (enemyMessages[enemyType]) {
                                this.addCommMessage(enemyMessages[enemyType], 'warning');
                            }
                        }
                    }
                    
                    // 複数敵出現時は確率を下げる
                    currentSpawnRate *= 0.7;
                }
            }
            
            shootAllWeapons() {
                const now = Date.now();
                const centerX = this.player.x + this.player.width / 2;
                const centerY = this.player.y;
                
                // 連射強化効果
                const cooldownMultiplier = this.mapEffects.rapidFire.active ? 0.3 : 1;
                
                // 基本射撃
                if (this.weapons.basicShot.level > 0 && now - this.weapons.basicShot.lastShot > this.weapons.basicShot.cooldown * cooldownMultiplier) {
                    this.shootBasic(centerX, centerY);
                    this.weapons.basicShot.lastShot = now;
                }
                
                // 拡散射撃
                if (this.weapons.spreadShot.level > 0 && now - this.weapons.spreadShot.lastShot > this.weapons.spreadShot.cooldown * cooldownMultiplier) {
                    this.shootSpread(centerX, centerY);
                    this.weapons.spreadShot.lastShot = now;
                }
                
                // レーザー
                if (this.weapons.laser.level > 0 && now - this.weapons.laser.lastShot > this.weapons.laser.cooldown * cooldownMultiplier) {
                    this.shootLaser(centerX, centerY);
                    this.weapons.laser.lastShot = now;
                }
                
                // ミサイル
                if (this.weapons.missile.level > 0 && now - this.weapons.missile.lastShot > this.weapons.missile.cooldown * cooldownMultiplier) {
                    this.shootMissile(centerX, centerY);
                    this.weapons.missile.lastShot = now;
                }
                
                // 軌道弾
                if (this.weapons.orbit.level > 0 && now - this.weapons.orbit.lastShot > this.weapons.orbit.cooldown * cooldownMultiplier) {
                    this.shootOrbit();
                    this.weapons.orbit.lastShot = now;
                }
                
                // 貫通弾
                if (this.weapons.piercing.level > 0 && now - this.weapons.piercing.lastShot > this.weapons.piercing.cooldown * cooldownMultiplier) {
                    this.shootPiercing(centerX, centerY);
                    this.weapons.piercing.lastShot = now;
                }
                
                // 追尾弾
                if (this.weapons.homing.level > 0 && now - this.weapons.homing.lastShot > this.weapons.homing.cooldown * cooldownMultiplier) {
                    this.shootHoming(centerX, centerY);
                    this.weapons.homing.lastShot = now;
                }
                
                // バリア
                if (this.weapons.barrier.level > 0 && now - this.weapons.barrier.lastShot > this.weapons.barrier.cooldown * cooldownMultiplier) {
                    this.shootBarrier();
                    this.weapons.barrier.lastShot = now;
                }
            }
            
            shootBasic(x, y) {
                const level = this.weapons.basicShot.level;
                const bulletCount = Math.min(level, 3);
                
                for (let i = 0; i < bulletCount; i++) {
                    const offsetX = (i - (bulletCount - 1) / 2) * 15;
                    this.bullets.push({
                        x: x + offsetX,
                        y: y,
                        speed: 8 + level,
                        width: 3 + level,
                        height: 10 + level * 2,
                        damage: level,
                        type: 'basic',
                        color: '#ffff00'
                    });
                }
                this.playBeep(800, 50, 'square');
            }
            
            shootSpread(x, y) {
                const level = this.weapons.spreadShot.level;
                const bulletCount = 3 + level * 2;
                const angleSpread = Math.PI / 3;
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = -angleSpread/2 + (angleSpread / (bulletCount - 1)) * i;
                    this.bullets.push({
                        x: x,
                        y: y,
                        speed: 6 + level,
                        width: 4,
                        height: 8,
                        damage: level,
                        type: 'spread',
                        angle: angle,
                        color: '#ff8800'
                    });
                }
                this.playBeep(700, 80, 'sawtooth');
            }
            
            shootLaser(x, y) {
                const level = this.weapons.laser.level;
                this.bullets.push({
                    x: x - 2,
                    y: y,
                    speed: 15,
                    width: 4 + level * 2,
                    height: this.canvas.height,
                    damage: level * 3,
                    type: 'laser',
                    life: 10,
                    color: '#00ffff'
                });
                this.playBeep(1200, 100, 'sine');
            }
            
            shootMissile(x, y) {
                const level = this.weapons.missile.level;
                const missileCount = Math.min(level, 3);
                
                for (let i = 0; i < missileCount; i++) {
                    this.bullets.push({
                        x: x + (i - 1) * 20,
                        y: y,
                        speed: 4,
                        width: 8,
                        height: 16,
                        damage: level * 5,
                        type: 'missile',
                        explosionRadius: 30 + level * 10,
                        color: '#ff0000'
                    });
                }
                this.playBeep(400, 200, 'sawtooth');
            }
            
            shootOrbit() {
                const level = this.weapons.orbit.level;
                if (this.orbitingBullets.length < level * 2) {
                    this.orbitingBullets.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: 50 + level * 10,
                        speed: 0.1,
                        damage: level * 2,
                        size: 6 + level * 2
                    });
                }
            }
            
            shootPiercing(x, y) {
                const level = this.weapons.piercing.level;
                this.bullets.push({
                    x: x,
                    y: y,
                    speed: 10,
                    width: 6,
                    height: 20,
                    damage: level * 2,
                    type: 'piercing',
                    pierceCount: level * 2,
                    color: '#00ff00'
                });
                this.playBeep(900, 60, 'triangle');
            }
            
            shootHoming(x, y) {
                const level = this.weapons.homing.level;
                this.bullets.push({
                    x: x,
                    y: y,
                    speed: 5,
                    width: 8,
                    height: 12,
                    damage: level * 3,
                    type: 'homing',
                    target: null,
                    turnSpeed: 0.1 + level * 0.02,
                    angle: -Math.PI / 2,
                    color: '#ff00ff'
                });
                this.playBeep(600, 100, 'sine');
            }
            
            shootBarrier() {
                const level = this.weapons.barrier.level;
                if (this.barrierBullets.length < level * 4) {
                    for (let i = 0; i < 4; i++) {
                        this.barrierBullets.push({
                            angle: (Math.PI / 2) * i,
                            distance: 60,
                            damage: level,
                            life: 300,
                            size: 8
                        });
                    }
                }
            }
            
            updateBullets() {
                // 通常弾の更新
                this.bullets = this.bullets.filter(bullet => {
                    if (bullet.type === 'spread') {
                        bullet.x += Math.sin(bullet.angle) * bullet.speed;
                        bullet.y -= Math.cos(bullet.angle) * bullet.speed;
                    } else if (bullet.type === 'laser') {
                        bullet.life--;
                        return bullet.life > 0;
                    } else if (bullet.type === 'homing') {
                        this.updateHomingBullet(bullet);
                    } else {
                        bullet.y -= bullet.speed;
                    }
                    
                    return bullet.y > -bullet.height && bullet.x > -bullet.width && bullet.x < this.canvas.width + bullet.width;
                });
                
                // 軌道弾の更新
                this.orbitingBullets.forEach(orbit => {
                    orbit.angle += orbit.speed;
                });
                
                // バリア弾の更新
                this.barrierBullets = this.barrierBullets.filter(barrier => {
                    barrier.life--;
                    return barrier.life > 0;
                });
            }
            
            updateHomingBullet(bullet) {
                // 最も近い敵を探す
                let closestEnemy = null;
                let closestDistance = Infinity;
                
                this.enemies.forEach(enemy => {
                    const dx = enemy.x + enemy.width/2 - bullet.x;
                    const dy = enemy.y + enemy.height/2 - bullet.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEnemy = enemy;
                    }
                });
                
                if (closestEnemy) {
                    const dx = closestEnemy.x + closestEnemy.width/2 - bullet.x;
                    const dy = closestEnemy.y + closestEnemy.height/2 - bullet.y;
                    const targetAngle = Math.atan2(dx, -dy);
                    
                    // 角度を徐々に調整
                    let angleDiff = targetAngle - bullet.angle;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    bullet.angle += angleDiff * bullet.turnSpeed;
                }
                
                bullet.x += Math.sin(bullet.angle) * bullet.speed;
                bullet.y -= Math.cos(bullet.angle) * bullet.speed;
            }
            
            spawnEnemies() {
                // ターンベース・ストラテジーモードでは敵の出現を制限
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    // ターンベースモードでは自動的な敵出現は行わない
                    // 敵はプレイヤーの行動後にのみ出現（processEnemyTurnMovement関数で処理）
                    return;
                }
                
                if (Math.random() < this.difficultySettings.enemySpawnRate + this.level * 0.005) {
                    const enemyType = this.getRandomEnemyType();
                    const enemyData = this.getEnemyData(enemyType);
                    
                    // 地球防衛モードでは敵の速度を調整
                    let speedMultiplier = this.difficultySettings.enemySpeedMultiplier;
                    if (this.gameMode === 'defense') {
                        // より滑らかな速度調整（レベルに応じて徐々に増加）
                        const baseSpeed = this.difficultySettings.defenseSpeedMultiplier;
                        const levelBonus = Math.min(this.level * 0.05, 0.3); // 最大30%まで増加
                        speedMultiplier = baseSpeed + levelBonus;
                        
                        // 特殊な敵タイプの出現時に通信メッセージ
                        if (Math.random() < 0.1) { // 10%の確率でメッセージ
                            const enemyMessages = {
                                heavy: '重装甲型敵機を確認！集中攻撃を推奨',
                                shooter: '射撃型敵機接近中！回避行動を取ってください',
                                fast: '高速型敵機を探知！迎撃準備',
                                zigzag: '不規則機動型敵機を確認'
                            };
                            
                            if (enemyMessages[enemyType]) {
                                this.addCommMessage(enemyMessages[enemyType], 'warning');
                            }
                        }
                    }
                    
                    let enemy = {
                        x: Math.random() * (this.canvas.width - enemyData.width),
                        y: -enemyData.height,
                        width: enemyData.width,
                        height: enemyData.height,
                        speed: (enemyData.speed + this.level * 0.2) * speedMultiplier,
                        type: enemyType,
                        health: Math.ceil(enemyData.health * this.difficultySettings.enemyHealthMultiplier),
                        lastShot: 0,
                        shootCooldown: enemyData.shootCooldown || 0
                    };
                    
                    this.enemies.push(enemy);
                }
            }
            
            getRandomEnemyType() {
                const rand = Math.random();
                if (rand < 0.4) return 'normal';
                if (rand < 0.6) return 'fast';
                if (rand < 0.75) return 'heavy';
                if (rand < 0.9) return 'shooter';
                return 'zigzag';
            }
            
            getEnemyData(type) {
                const enemyTypes = {
                    normal: { width: 40, height: 30, speed: 1.5, health: 1, points: 100 },
                    fast: { width: 30, height: 25, speed: 3, health: 1, points: 200 },
                    heavy: { width: 50, height: 40, speed: 0.8, health: 3, points: 300 },
                    shooter: { width: 45, height: 35, speed: 1, health: 2, points: 250, shootCooldown: 1500 },
                    zigzag: { width: 35, height: 28, speed: 2, health: 1, points: 150 }
                };
                return enemyTypes[type] || enemyTypes.normal;
            }
            
            spawnPowerups() {
                // ターンベース・ストラテジーモードでは自動的なアイテム出現は行わない
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    // アイテムはプレイヤーの行動後にのみ出現（spawnTurnBasedItems関数で処理）
                    return;
                } else {
                    // 通常のパワーアップスポーン（クラシック・地球防衛モード）
                    if (Math.random() < this.difficultySettings.powerupSpawnRate) {
                        const weaponTypes = Object.keys(this.weapons);
                        const availableWeapons = weaponTypes.filter(weapon => this.weapons[weapon].level < this.weapons[weapon].maxLevel);
                        
                        let type;
                        
                        // 地球防衛モードで地球HPが低い場合、地球回復アイテムの出現率を大幅に上げる
                        if (this.gameMode === 'defense' && this.earthHealth < this.maxEarthHealth) {
                            const healthRatio = this.earthHealth / this.maxEarthHealth;
                            let healEarthChance = 0.15; // 基本15%
                            
                            if (healthRatio < 0.3) {
                                healEarthChance = 0.4; // 地球HP30%以下で40%
                            } else if (healthRatio < 0.6) {
                                healEarthChance = 0.25; // 地球HP60%以下で25%
                            }
                            
                            if (Math.random() < healEarthChance) {
                                type = 'healEarth';
                            }
                        }
                        
                        // 地球回復アイテムが選ばれなかった場合の通常処理
                        if (!type) {
                            if (availableWeapons.length > 0 && Math.random() < 0.7) {
                                // 70%の確率で武器強化
                                type = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                            } else {
                                // 30%の確率でその他のアイテム
                                let otherTypes = ['shield', 'life', 'speed'];
                                
                                // 地球防衛モードでは地球回復アイテムを追加（通常確率）
                                if (this.gameMode === 'defense' && this.earthHealth < this.maxEarthHealth) {
                                    otherTypes.push('healEarth');
                                }
                                
                                type = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                            }
                        }
                        
                        this.powerups.push({
                            x: Math.random() * (this.canvas.width - 30),
                            y: -30,
                            width: 30,
                            height: 30,
                            speed: 2,
                            type: type,
                            rotation: 0,
                            pulseTime: 0 // ハイライト用
                        });
                    }
                }
            }
            

            
            giveInitialInventoryItems() {
                // 難易度に応じて初期エクスプロージョンを付与
                const explosionCounts = {
                    easy: 5,
                    normal: 3,
                    hard: 2,
                    expert: 1,
                    nightmare: 1
                };
                
                this.inventory.explosion = explosionCounts[this.difficulty] || 3;
                this.updateInventoryUI();
                
                // 初期アイテム付与メッセージ
                this.showMapEffect(`エクスプロージョン x${this.inventory.explosion} 支給！`, '#ff8800');
            }
            
            spawnInitialGridItems() {
                // ゲーム開始時に初期アイテムを2-4個配置
                const initialItemCount = 2 + Math.floor(Math.random() * 3); // 2-4個
                
                for (let i = 0; i < initialItemCount; i++) {
                    const weaponTypes = Object.keys(this.weapons);
                    const availableWeapons = weaponTypes.filter(weapon => this.weapons[weapon].level < this.weapons[weapon].maxLevel);
                    
                    let type;
                    if (availableWeapons.length > 0 && Math.random() < 0.8) {
                        // 80%の確率で武器強化
                        type = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    } else {
                        // 20%の確率でその他のアイテム
                        const otherTypes = ['shield', 'life', 'speed'];
                        type = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                    }
                    
                    // 空いているグリッド位置を探す
                    let attempts = 0;
                    let gridX, gridY;
                    do {
                        gridX = Math.floor(Math.random() * this.gridWidth);
                        gridY = Math.floor(Math.random() * (this.gridHeight - 5)) + 2; // 上部2行と下部3行を避ける
                        attempts++;
                    } while (this.isGridOccupied(gridX, gridY) && attempts < 50);
                    
                    if (attempts < 50) {
                        this.gridItems.push({
                            gridX: gridX,
                            gridY: gridY,
                            x: gridX * this.gridSize + this.gridSize/2 - 15,
                            y: gridY * this.gridSize + this.gridSize/2 - 15,
                            width: 30,
                            height: 30,
                            type: type,
                            rotation: 0,
                            pulseTime: 0
                        });
                    }
                }
            }
            
            spawnTurnBasedItems() {
                // プレイヤーが行動した後に確率でアイテム出現
                if (Math.random() < 0.15) { // 15%の確率でアイテム出現
                    const specialItemTypes = [
                        'freeze', 'slowTime', 'mapShield', 'doubleScore', 'rapidFire',
                        'invincible', 'magneticField', 'energyStorm', 'explosion', 'timeWarp',
                        'healEarth', 'barrierWall', 'lightningStrike', 'gravityWell'
                    ];
                    
                    const weaponTypes = Object.keys(this.weapons);
                    const availableWeapons = weaponTypes.filter(weapon => this.weapons[weapon].level < this.weapons[weapon].maxLevel);
                    
                    let type;
                    if (Math.random() < 0.6 && specialItemTypes.length > 0) {
                        // 60%の確率で特殊アイテム
                        type = specialItemTypes[Math.floor(Math.random() * specialItemTypes.length)];
                    } else if (availableWeapons.length > 0 && Math.random() < 0.8) {
                        // 32%の確率で武器強化
                        type = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    } else {
                        // 8%の確率でその他のアイテム
                        const otherTypes = ['shield', 'life', 'speed'];
                        type = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                    }
                    
                    // 空いているグリッド位置を探す
                    let attempts = 0;
                    let gridX, gridY;
                    do {
                        gridX = Math.floor(Math.random() * this.gridWidth);
                        gridY = Math.floor(Math.random() * (this.gridHeight - 5)) + 2; // 上部2行と下部3行を避ける
                        attempts++;
                    } while (this.isGridOccupied(gridX, gridY) && attempts < 20);
                    
                    if (attempts < 20) {
                        this.gridItems.push({
                            gridX: gridX,
                            gridY: gridY,
                            x: gridX * this.gridSize + this.gridSize/2 - 15,
                            y: gridY * this.gridSize + this.gridSize/2 - 15,
                            width: 30,
                            height: 30,
                            type: type,
                            rotation: 0,
                            pulseTime: 0
                        });
                    }
                }
            }
            
            isGridOccupied(gridX, gridY) {
                // プレイヤーの位置をチェック
                if (gridX === this.player.gridX && gridY === this.player.gridY) {
                    return true;
                }
                
                // 敵の位置をチェック
                for (let enemy of this.enemies) {
                    if (enemy.gridX === gridX && enemy.gridY === gridY) {
                        return true;
                    }
                }
                
                // 既存のグリッドアイテムをチェック
                for (let item of this.gridItems) {
                    if (item.gridX === gridX && item.gridY === gridY) {
                        return true;
                    }
                }
                
                return false;
            }
            
            isGridOccupiedByEnemy(gridX, gridY) {
                // 敵の位置のみをチェック（敵のスポーン時に使用）
                for (let enemy of this.enemies) {
                    if (enemy.gridX === gridX && enemy.gridY === gridY) {
                        return true;
                    }
                }
                return false;
            }
            

            
            updateEnemies() {
                this.enemies = this.enemies.filter(enemy => {
                    // マップ効果による敵の行動制限
                    let canMove = true;
                    let speedMultiplier = 1;
                    
                    if (this.mapEffects.freeze.active) {
                        canMove = false;
                    }
                    if (this.mapEffects.slowTime.active) {
                        speedMultiplier = 0.3;
                    }
                    
                    // ターンベースモードでは敵の自動移動を停止、凍結効果も適用
                    if ((this.gameMode === 'classic' || this.gameMode === 'defense') && canMove) {
                        // 敵の移動パターン
                        if (enemy.type === 'zigzag') {
                            enemy.x += Math.sin(enemy.y * 0.02) * 2 * speedMultiplier;
                            if (enemy.x < 0) enemy.x = 0;
                            if (enemy.x > this.canvas.width - enemy.width) enemy.x = this.canvas.width - enemy.width;
                        }
                        
                        enemy.y += enemy.speed * speedMultiplier;
                        
                        // 射撃敵の攻撃（凍結中は攻撃しない）
                        if (enemy.type === 'shooter' && enemy.shootCooldown && Date.now() - enemy.lastShot > enemy.shootCooldown) {
                            this.enemyShoot(enemy);
                            enemy.lastShot = Date.now();
                        }
                    }
                    
                    // 地球防衛モードで敵が画面下部に到達した場合
                    if ((this.gameMode === 'defense' || this.gameMode === 'strategy')) {
                        const bottomBoundary = this.gameMode === 'strategy' || this.gameMode === 'turnbased' ? 
                                             (this.gridHeight - 2) * this.gridSize : this.canvas.height - 60;
                        
                        if (enemy.y + enemy.height >= bottomBoundary) {
                            this.damageEarth(enemy);
                            return false; // 敵を削除
                        }
                    }
                    
                    // 画面外判定
                    const screenBottom = this.gameMode === 'turnbased' || this.gameMode === 'strategy' ? 
                                       this.gridHeight * this.gridSize : this.canvas.height + enemy.height;
                    
                    return enemy.y < screenBottom;
                });
            }
            
            damageEarth(enemy) {
                const damage = this.getEnemyDamage(enemy.type);
                this.earthHealth -= damage;
                
                // ダメージ表示
                this.showEarthDamage(damage);
                
                // 通信ログにダメージ報告を追加
                this.addCommMessage(`地球にダメージ！ HP-${damage} (残り${this.earthHealth})`, 'urgent');
                
                // 地球HP状況に応じた通信メッセージ
                const healthRatio = this.earthHealth / this.maxEarthHealth;
                if (healthRatio <= 0.2 && healthRatio > 0) {
                    this.addCommMessage('緊急事態！地球の防護シールドが限界です！', 'urgent');
                } else if (healthRatio <= 0.5) {
                    this.addCommMessage('警告：地球の防護システムが危険レベルです', 'warning');
                } else if (healthRatio <= 0.7) {
                    this.addCommMessage('地球の防護システムに損傷を確認', 'warning');
                }
                
                // 地球ダメージ音
                this.playBeep(150, 300, 'sawtooth');
                
                if (this.earthHealth <= 0) {
                    this.earthHealth = 0;
                    this.addCommMessage('地球防護システム完全停止...作戦失敗', 'urgent');
                    this.gameOver();
                }
            }
            
            getEnemyDamage(enemyType) {
                const damageMap = {
                    normal: 5,
                    fast: 3,
                    heavy: 10,
                    shooter: 7,
                    zigzag: 4,
                    enemy_bullet: 1
                };
                return damageMap[enemyType] || 5;
            }
            
            showEarthDamage(damage) {
                const indicator = document.createElement('div');
                indicator.className = 'earth-damage-indicator';
                indicator.textContent = `-${damage}`;
                document.getElementById('gameContainer').appendChild(indicator);
                
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 500);
            }
            
            enemyShoot(enemy) {
                let bullet = {
                    x: enemy.x + enemy.width/2 - 3,
                    y: enemy.y + enemy.height,
                    width: 6,
                    height: 12,
                    speed: 3,
                    type: 'enemy_bullet',
                    health: 1
                };
                
                // ターンベース・ストラテジーモードではグリッド座標を追加
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    bullet.gridX = enemy.gridX;
                    bullet.gridY = enemy.gridY + 1;
                    bullet.x = bullet.gridX * this.gridSize + this.gridSize/2 - bullet.width/2;
                    bullet.y = bullet.gridY * this.gridSize + this.gridSize/2 - bullet.height/2;
                }
                
                this.enemies.push(bullet);
                this.playBeep(300, 50, 'square');
            }
            
            updatePowerups() {
                this.powerups = this.powerups.filter(powerup => {
                    powerup.y += powerup.speed;
                    powerup.rotation += 0.03; // 回転速度を大幅に減速（0.1 → 0.03）
                    powerup.pulseTime += 0.15; // パルス効果用
                    return powerup.y < this.canvas.height + powerup.height;
                });
            }
            
            updateGridItems() {
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.gridItems.forEach(item => {
                        item.rotation += 0.02; // 回転速度を減速（0.05 → 0.02）
                        item.pulseTime += 0.08; // パルス速度も少し減速（0.1 → 0.08）
                    });
                }
            }
            
            updateTurnBasedEffects() {
                // ターンベース・ストラテジーモード専用のエフェクト更新
                Object.keys(this.mapEffects).forEach(effectName => {
                    const effect = this.mapEffects[effectName];
                    if (effect.active && effect.duration > 0) {
                        effect.duration--;
                        if (effect.duration <= 0) {
                            effect.active = false;
                            // エネルギーストーム終了時の特別処理
                            if (effectName === 'energyStorm') {
                                this.showMapEffect('エネルギーストーム終了', '#666666');
                            }
                        }
                    }
                });
                
                // エネルギーストームの継続ダメージ処理（ターンベース専用）
                if (this.mapEffects.energyStorm.active) {
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        if (enemy.type !== 'enemy_bullet' && 
                            enemy.y >= 0 && enemy.y < this.canvas.height &&
                            enemy.x >= 0 && enemy.x < this.canvas.width &&
                            Math.random() < 0.3) {
                            
                            enemy.health -= 1;
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(i, 1);
                                this.playBeep(600, 50, 'triangle');
                            }
                        }
                    }
                }
            }
            
            updateMapEffects() {
                // クラシック・地球防衛モードでは毎フレーム減らす（60FPSで1秒 = 60フレーム）
                if (this.gameMode === 'classic' || this.gameMode === 'defense') {
                    Object.keys(this.mapEffects).forEach(effectName => {
                        const effect = this.mapEffects[effectName];
                        if (effect.active && effect.duration > 0) {
                            effect.duration--;
                            if (effect.duration <= 0) {
                                effect.active = false;
                                // エネルギーストーム終了時の特別処理
                                if (effectName === 'energyStorm') {
                                    this.showMapEffect('エネルギーストーム終了', '#666666');
                                }
                            }
                        }
                    });
                    
                    // エネルギーストームの継続ダメージ処理（リアルタイムモード）
                    if (this.mapEffects.energyStorm.active) {
                        for (let i = this.enemies.length - 1; i >= 0; i--) {
                            const enemy = this.enemies[i];
                            if (enemy.type !== 'enemy_bullet' && 
                                enemy.y >= 0 && enemy.y < this.canvas.height &&
                                enemy.x >= 0 && enemy.x < this.canvas.width &&
                                Math.random() < 0.005) { // フレーム毎なので確率を下げる
                                
                                enemy.health -= 1;
                                this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                
                                if (enemy.health <= 0) {
                                    this.addScore(enemy.type);
                                    this.enemies.splice(i, 1);
                                    this.playBeep(600, 50, 'triangle');
                                }
                            }
                        }
                    }
                }
            }
            

            

            
            updateExplosions() {
                this.explosions = this.explosions.filter(explosion => {
                    explosion.time++;
                    explosion.radius += 2;
                    return explosion.time < 20;
                });
            }
            
            updateStars() {
                this.stars.forEach(star => {
                    star.y += star.speed;
                    if (star.y > this.canvas.height) {
                        star.y = -5;
                        star.x = Math.random() * this.canvas.width;
                    }
                });
            }
            
            checkCollisions() {
                // 弾と敵の衝突
                this.bullets.forEach((bullet, bulletIndex) => {
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (this.isColliding(bullet, enemy) && !enemy.hitThisFrame) {
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemy.health -= bullet.damage || 1;
                            enemy.hitThisFrame = true; // 重複ヒット防止
                            
                            // 敵を倒した場合のスコア加算
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(enemyIndex, 1);
                                this.playBeep(600, 100, 'triangle');
                            } else {
                                this.playBeep(1000, 30, 'sine');
                            }
                            
                            // ミサイルの爆発ダメージ（直撃後に爆発）
                            if (bullet.type === 'missile') {
                                this.createMissileExplosion(bullet.x, bullet.y, bullet.explosionRadius, bullet.damage);
                            }
                            
                            // 貫通弾以外は削除
                            if (bullet.type !== 'piercing' || bullet.pierceCount <= 0) {
                                this.bullets.splice(bulletIndex, 1);
                            } else if (bullet.type === 'piercing') {
                                bullet.pierceCount--;
                            }
                        }
                    });
                });
                
                // 軌道弾と敵の衝突
                this.orbitingBullets.forEach((orbit, orbitIndex) => {
                    const orbitX = this.player.x + this.player.width/2 + Math.cos(orbit.angle) * orbit.distance;
                    const orbitY = this.player.y + this.player.height/2 + Math.sin(orbit.angle) * orbit.distance;
                    
                    this.enemies.forEach((enemy, enemyIndex) => {
                        const dx = orbitX - (enemy.x + enemy.width/2);
                        const dy = orbitY - (enemy.y + enemy.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < orbit.size + enemy.width/2 && !enemy.hitThisFrame) {
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemy.health -= orbit.damage;
                            enemy.hitThisFrame = true; // 重複ヒット防止
                            
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(enemyIndex, 1);
                                this.playBeep(600, 100, 'triangle');
                            }
                        }
                    });
                });
                
                // バリア弾と敵の衝突
                this.barrierBullets.forEach((barrier, barrierIndex) => {
                    const barrierX = this.player.x + this.player.width/2 + Math.cos(barrier.angle) * barrier.distance;
                    const barrierY = this.player.y + this.player.height/2 + Math.sin(barrier.angle) * barrier.distance;
                    
                    this.enemies.forEach((enemy, enemyIndex) => {
                        const dx = barrierX - (enemy.x + enemy.width/2);
                        const dy = barrierY - (enemy.y + enemy.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < barrier.size + enemy.width/2 && !enemy.hitThisFrame) {
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemy.health -= barrier.damage;
                            enemy.hitThisFrame = true; // 重複ヒット防止
                            
                            if (enemy.health <= 0) {
                                this.addScore(enemy.type);
                                this.enemies.splice(enemyIndex, 1);
                                this.playBeep(600, 100, 'triangle');
                            }
                        }
                    });
                });
                
                // プレイヤーと敵の衝突
                this.enemies.forEach((enemy, enemyIndex) => {
                    if (this.isColliding(this.player, enemy)) {
                        if (!this.player.shield && !this.mapEffects.shield.active && !this.mapEffects.invincible.active) {
                            this.createExplosion(this.player.x + this.player.width/2, this.player.y + this.player.height/2);
                            this.lives--;
                            this.enemies.splice(enemyIndex, 1);
                            
                            // ダメージ音（低音の警告音）
                            this.playBeep(200, 300, 'sawtooth');
                            
                            if (this.lives <= 0) {
                                this.gameOver();
                            }
                        } else {
                            // シールドまたは無敵で防御
                            this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            this.enemies.splice(enemyIndex, 1);
                            this.playBeep(400, 100, 'triangle');
                        }
                    }
                });
                

                
                // プレイヤーとパワーアップの衝突
                this.powerups.forEach((powerup, powerupIndex) => {
                    if (this.isColliding(this.player, powerup)) {
                        this.applyPowerup(powerup.type);
                        this.powerups.splice(powerupIndex, 1);
                        
                        // パワーアップ取得音
                        this.playBeep(800, 100, 'sine');
                        setTimeout(() => this.playBeep(1000, 100, 'sine'), 100);
                    }
                });
                
                // プレイヤーとグリッドアイテムの衝突（ターンベース・ストラテジーモード）
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.gridItems.forEach((item, itemIndex) => {
                        if (item.gridX === this.player.gridX && item.gridY === this.player.gridY) {
                            this.applyGridItem(item.type);
                            this.gridItems.splice(itemIndex, 1);
                            
                            // 特殊アイテム取得音
                            this.playBeep(600, 80, 'sine');
                            setTimeout(() => this.playBeep(800, 80, 'sine'), 80);
                            setTimeout(() => this.playBeep(1000, 120, 'sine'), 160);
                        }
                    });
                }
            }
            
            applyPowerup(type) {
                if (this.weapons[type]) {
                    // 武器強化
                    if (this.weapons[type].level < this.weapons[type].maxLevel) {
                        this.weapons[type].level++;
                        const weaponNames = {
                            basicShot: '基本射撃',
                            spreadShot: '拡散射撃',
                            laser: 'レーザー',
                            missile: 'ミサイル',
                            orbit: '軌道弾',
                            piercing: '貫通弾',
                            homing: '追尾弾',
                            barrier: 'バリア'
                        };
                        this.showMapEffect(`${weaponNames[type] || type} Lv.${this.weapons[type].level}`, '#00ff00');
                        
                        // 地球防衛モードで武器強化時の通信メッセージ
                        if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                            this.addCommMessage(`武器システム強化完了：${weaponNames[type]}`, 'normal');
                        }
                    }
                } else {
                    // その他のアイテム
                    switch (type) {
                        case 'shield':
                            this.player.shield = true;
                            this.player.shieldTime = 300;
                            this.showMapEffect('シールド取得！', '#00ffff');
                            this.addCommMessage('防護シールド展開完了', 'normal');
                            break;
                        case 'life':
                            this.lives++;
                            this.showMapEffect('ライフ+1！', '#ff0080');
                            this.addCommMessage('予備機体が到着しました', 'normal');
                            break;
                        case 'speed':
                            this.player.speed = Math.min(this.player.speed + 1, 10);
                            this.showMapEffect('スピードアップ！', '#88ff00');
                            this.addCommMessage('推進システム強化完了', 'normal');
                            break;
                        case 'healEarth':
                            if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                                const oldHealth = this.earthHealth;
                                this.earthHealth = Math.min(this.earthHealth + 30, this.maxEarthHealth);
                                const actualHeal = this.earthHealth - oldHealth;
                                this.showMapEffect('地球回復+30！', '#00ff00');
                                this.addCommMessage(`地球防護システム修復完了 HP+${actualHeal}`, 'normal');
                            }
                            break;
                    }
                }
            }
            
            applyGridItem(type) {
                if (this.weapons[type]) {
                    // 武器強化
                    if (this.weapons[type].level < this.weapons[type].maxLevel) {
                        this.weapons[type].level++;
                        const weaponNames = {
                            basicShot: '基本射撃',
                            spreadShot: '拡散射撃',
                            laser: 'レーザー',
                            missile: 'ミサイル',
                            orbit: '軌道弾',
                            piercing: '貫通弾',
                            homing: '追尾弾',
                            barrier: 'バリア'
                        };
                        this.showMapEffect(`${weaponNames[type] || type} Lv.${this.weapons[type].level}`, '#00ff00');
                    }
                } else {
                    // 特殊アイテムの効果
                    switch (type) {
                        case 'freeze':
                            this.mapEffects.freeze.active = true;
                            this.mapEffects.freeze.duration = 3; // 3ターン
                            this.showMapEffect('敵全体凍結！', '#00ffff');
                            break;
                        case 'slowTime':
                            this.mapEffects.slowTime.active = true;
                            this.mapEffects.slowTime.duration = 5; // 5ターン
                            this.showMapEffect('時間減速！', '#ffff00');
                            break;
                        case 'mapShield':
                            this.mapEffects.shield.active = true;
                            this.mapEffects.shield.duration = 10; // 10ターン
                            this.showMapEffect('全体シールド！', '#00ffff');
                            break;
                        case 'doubleScore':
                            this.mapEffects.doubleScore.active = true;
                            this.mapEffects.doubleScore.duration = 10; // 10ターン
                            this.showMapEffect('スコア2倍！', '#ffff00');
                            break;
                        case 'rapidFire':
                            this.mapEffects.rapidFire.active = true;
                            this.mapEffects.rapidFire.duration = 5; // 5ターン
                            this.showMapEffect('連射強化！', '#ff8800');
                            break;
                        case 'invincible':
                            this.mapEffects.invincible.active = true;
                            this.mapEffects.invincible.duration = 3; // 3ターン
                            this.showMapEffect('無敵状態！', '#ff00ff');
                            break;
                        case 'magneticField':
                            this.mapEffects.magneticField.active = true;
                            this.mapEffects.magneticField.duration = 6; // 6ターン
                            this.showMapEffect('磁力フィールド！', '#8800ff');
                            break;
                        case 'energyStorm':
                            this.mapEffects.energyStorm.active = true;
                            this.mapEffects.energyStorm.duration = 4; // 4ターン
                            this.showMapEffect('エネルギーストーム！', '#ff4400');
                            break;
                        case 'explosion':
                            this.activateExplosion();
                            this.showMapEffect('エクスプロージョン！', '#ff0000');
                            break;
                        case 'timeWarp':
                            this.activateTimeWarp();
                            this.showMapEffect('時空歪曲！', '#ff00ff');
                            break;
                        case 'healEarth':
                            if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                                this.earthHealth = Math.min(this.earthHealth + 30, this.maxEarthHealth);
                                this.showMapEffect('地球回復+30！', '#00ff00');
                            }
                            break;
                        case 'barrierWall':
                            this.activateBarrierWall();
                            this.showMapEffect('バリア壁！', '#00ffff');
                            break;
                        case 'lightningStrike':
                            this.activateLightningStrike();
                            this.showMapEffect('雷撃！', '#ffff00');
                            break;
                        case 'gravityWell':
                            this.activateGravityWell();
                            this.showMapEffect('重力フィールド！', '#8800ff');
                            break;
                        // 通常アイテム
                        case 'shield':
                            this.player.shield = true;
                            this.player.shieldTime = 300;
                            this.showMapEffect('シールド取得！', '#00ffff');
                            break;
                        case 'life':
                            this.lives++;
                            this.showMapEffect('ライフ+1！', '#ff0080');
                            break;
                        case 'speed':
                            this.player.speed = Math.min(this.player.speed + 1, 10);
                            this.showMapEffect('スピードアップ！', '#88ff00');
                            break;
                        case 'healEarth':
                            if (this.gameMode === 'defense') {
                                this.earthHealth = Math.min(this.earthHealth + 30, this.maxEarthHealth);
                                this.showMapEffect('地球回復+30！', '#00ff00');
                            }
                            break;
                    }
                }
            }
            
            showMapEffect(text, color) {
                const effectDiv = document.createElement('div');
                effectDiv.style.position = 'absolute';
                effectDiv.style.top = '50%';
                effectDiv.style.left = '50%';
                effectDiv.style.transform = 'translate(-50%, -50%)';
                effectDiv.style.color = color;
                effectDiv.style.fontSize = '32px';
                effectDiv.style.fontWeight = 'bold';
                effectDiv.style.textShadow = `0 0 20px ${color}`;
                effectDiv.style.zIndex = '25';
                effectDiv.style.pointerEvents = 'none';
                effectDiv.style.animation = 'mapEffectFade 2s ease-out forwards';
                effectDiv.textContent = text;
                
                document.getElementById('gameContainer').appendChild(effectDiv);
                
                setTimeout(() => {
                    if (effectDiv.parentNode) {
                        effectDiv.parentNode.removeChild(effectDiv);
                    }
                }, 2000);
            }
            
            activateExplosion() {
                // 画面上の全ての敵を破壊
                this.enemies.forEach(enemy => {
                    this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    this.addScore(enemy.type);
                });
                this.enemies = [];
                
                // 大爆発エフェクト
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.createExplosion(
                            Math.random() * this.canvas.width,
                            Math.random() * this.canvas.height
                        );
                    }, i * 100);
                }
                
                // 大爆発音
                this.playBeep(50, 1000, 'sawtooth');
            }
            
            activateTimeWarp() {
                // 敵を過去の位置に戻す
                this.enemies.forEach(enemy => {
                    if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                        enemy.gridY = Math.max(0, enemy.gridY - 3);
                        enemy.y = enemy.gridY * this.gridSize + this.gridSize/2 - enemy.height/2;
                    } else {
                        enemy.y = Math.max(-enemy.height, enemy.y - 150);
                    }
                });
            }
            
            activateBarrierWall() {
                // 画面下部にバリア弾を配置
                const barrierY = this.gameMode === 'turnbased' || this.gameMode === 'strategy' ? 
                                this.gridHeight - 4 : this.canvas.height - 200;
                
                for (let i = 0; i < 10; i++) {
                    this.barrierBullets.push({
                        angle: 0,
                        distance: 0,
                        damage: 2,
                        life: 600,
                        size: 12,
                        x: (this.canvas.width / 10) * i + 20,
                        y: barrierY,
                        fixed: true
                    });
                }
            }
            
            activateLightningStrike() {
                // ランダムな敵に雷撃
                const targets = this.enemies.filter(enemy => enemy.type !== 'enemy_bullet');
                for (let i = 0; i < Math.min(5, targets.length); i++) {
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    this.createExplosion(target.x + target.width/2, target.y + target.height/2);
                    target.health -= 5;
                    
                    if (target.health <= 0) {
                        this.addScore(target.type);
                        const index = this.enemies.indexOf(target);
                        if (index > -1) {
                            this.enemies.splice(index, 1);
                        }
                    }
                }
                
                // 雷音
                this.playBeep(1500, 200, 'square');
            }
            
            activateGravityWell() {
                // 全ての敵を画面中央に引き寄せる
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.enemies.forEach(enemy => {
                    const dx = centerX - (enemy.x + enemy.width/2);
                    const dy = centerY - (enemy.y + enemy.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance > 0) {
                        const pullStrength = 0.3;
                        enemy.x += dx * pullStrength;
                        enemy.y += dy * pullStrength;
                        
                        // グリッド座標も更新
                        if (enemy.gridX !== undefined) {
                            enemy.gridX = Math.floor(enemy.x / this.gridSize);
                            enemy.gridY = Math.floor(enemy.y / this.gridSize);
                        }
                    }
                });
            }
            
            useInventoryItem(itemType) {
                if (this.inventory[itemType] <= 0) {
                    // アイテムがない場合の警告音
                    this.playBeep(200, 100, 'square');
                    return;
                }
                
                // アイテムを消費
                this.inventory[itemType]--;
                this.updateInventoryUI();
                
                // アイテム効果を発動
                switch (itemType) {
                    case 'explosion':
                        this.activateExplosion();
                        this.showMapEffect('エクスプロージョン発動！', '#ff0000');
                        break;
                }
                
                // アイテム使用音
                this.playBeep(800, 100, 'sine');
                setTimeout(() => this.playBeep(1000, 100, 'sine'), 100);
                setTimeout(() => this.playBeep(1200, 150, 'sine'), 200);
            }
            
            isColliding(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            createExplosion(x, y) {
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: 5,
                    time: 0,
                    type: 'normal'
                });
                
                // 爆発音（低音のノイズ）
                this.playBeep(150, 200, 'sawtooth');
            }
            
            addScore(enemyType) {
                const scoreMap = {
                    normal: 100,
                    fast: 200,
                    heavy: 300,
                    shooter: 250,
                    zigzag: 150,
                    enemy_bullet: 25
                };
                
                let points = scoreMap[enemyType] || 100;
                
                // スコア2倍効果
                if (this.mapEffects.doubleScore.active) {
                    points *= 2;
                }
                
                // 全モードで統一されたスコア加算（整数値のみ）
                this.score += Math.floor(points);
            }
            
            createMissileExplosion(x, y, radius, damage) {
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: radius,
                    time: 0,
                    type: 'missile',
                    maxRadius: radius
                });
                
                // 範囲内の敵にダメージ
                this.enemies.forEach((enemy, enemyIndex) => {
                    const dx = enemy.x + enemy.width/2 - x;
                    const dy = enemy.y + enemy.height/2 - y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < radius && !enemy.hitThisFrame) {
                        enemy.health -= damage;
                        enemy.hitThisFrame = true; // 重複ヒット防止
                        
                        if (enemy.health <= 0) {
                            this.addScore(enemy.type);
                            this.enemies.splice(enemyIndex, 1);
                        }
                    }
                });
                
                // 大きな爆発音
                this.playBeep(100, 300, 'sawtooth');
            }
            
            updateLevel() {
                const newLevel = Math.floor(this.score / 1000) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    
                    // 地球防衛モードでレベルアップ時の通信メッセージ
                    if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                        const levelMessages = [
                            '作戦レベル上昇！敵の攻撃が激化します',
                            '防衛クルー、素晴らしい戦果です！',
                            '敵の新型機を確認。警戒レベルを上げてください',
                            '地球防衛軍本部より、継続した防衛を要請',
                            '敵母艦接近の兆候あり。最大警戒で臨んでください'
                        ];
                        const randomMessage = levelMessages[Math.floor(Math.random() * levelMessages.length)];
                        this.addCommMessage(`レベル${newLevel}：${randomMessage}`, 'normal');
                    }
                    
                    // レベルアップ音（上昇音階）
                    setTimeout(() => this.playBeep(500, 100, 'sine'), 0);
                    setTimeout(() => this.playBeep(600, 100, 'sine'), 100);
                    setTimeout(() => this.playBeep(700, 150, 'sine'), 200);
                }
                
                // 地球防衛モードのDAY進行チェック
                this.checkDayProgression();
            }
            
            checkDayProgression() {
                if ((this.gameMode !== 'defense' && this.gameMode !== 'strategy') || this.endlessMode || this.dayCleared) return;
                
                const targetScore = this.dayTargetScores[this.currentDay];
                if (this.score >= targetScore) {
                    this.dayCleared = true;
                    
                    if (this.currentDay === 3) {
                        // DAY3クリア = エンディング
                        this.showEnding();
                    } else {
                        // DAY1,2クリア = 本部帰還
                        this.showReturnToBase();
                    }
                }
            }
            
            showReturnToBase() {
                this.gameState = 'returnToBase';
                
                // BGM停止
                this.stopBGM();
                
                // 帰還画面の情報を設定
                document.getElementById('dayCompleteTitle').textContent = `DAY ${this.currentDay} クリア！`;
                document.getElementById('returnScore').textContent = this.score.toLocaleString();
                document.getElementById('returnEarthHp').textContent = this.earthHealth;
                
                // ランダムなねぎらいメッセージを表示
                this.displayRandomCongratsMessage();
                
                // 帰還画面を表示
                document.getElementById('returnToBaseScreen').style.display = 'flex';
                
                // 帰還音（勝利音階）
                setTimeout(() => this.playBeep(600, 150, 'sine'), 0);
                setTimeout(() => this.playBeep(700, 150, 'sine'), 150);
                setTimeout(() => this.playBeep(800, 150, 'sine'), 300);
                setTimeout(() => this.playBeep(900, 200, 'sine'), 450);
            }
            
            displayRandomCongratsMessage() {
                const congratsMessages = [
                    // 会話型
                    "「お疲れ様でした！素晴らしい戦果です。」\n「次のミッションも頼みます。」",
                    "「パイロット、見事な腕前だ。」\n「君のような人材を待っていた。」",
                    "「今回の作戦、完璧でしたね。」\n「でも油断は禁物ですよ。」",
                    "「やったじゃないですか！」\n「この調子で次も頑張りましょう！」",
                    "「流石です、エース。」\n「地球の希望はあなたです。」",
                    
                    // 命令型
                    "作戦完了を確認。次のフェーズに移行せよ。",
                    "優秀な戦果を記録。引き続き任務を継続されたし。",
                    "目標達成。パイロットは短時間の休息後、次の作戦に参加せよ。",
                    "戦闘データを解析中。次回はより困難な任務が待っている。",
                    "司令部より通達：君の活躍により作戦は成功した。",
                    
                    // ファンタジー風
                    "勇者よ、見事な戦いぶりであった。\n次なる試練が汝を待っている。",
                    "光の戦士よ、闇を払いし功績、誠に見事なり。",
                    "星の加護を受けし者よ、\nその力で宇宙の平和を守り給え。",
                    "古の予言の通り、選ばれし者が現れた。\n運命の戦いはまだ続く。",
                    "魔法の力が君を守護している。\n次の戦場でもその力を発揮せよ。",
                    
                    // ネットミーム風
                    "つよい（確信）\n次もよろしくオナシャス！",
                    "ファッ!? 強すぎでしょ...\n（次のDAYで）切り替えていく",
                    "草生える戦いぶりで草\n次も期待してるゾ〜",
                    "これもうわかんねぇな（褒め言葉）\n次のDAYも頼むゾ〜",
                    "有能👍\n次のミッションもがんばルビィ！",
                    "やりますねぇ！\n次回も楽しみにしてます（半ギレ）",
                    
                    // 熱血系
                    "燃えるぜ！この調子で宇宙を救うんだ！",
                    "アツい戦いだった！\n次はもっと燃え上がろうぜ！",
                    "魂の戦いに感動した！\n君となら宇宙も救えるさ！",
                    
                    // クール系
                    "...悪くない。\n次も同じレベルを維持してもらおう。",
                    "予想通りの結果だ。\n次のミッションでも期待している。",
                    "計算通り。君の実力は本物のようだな。",
                    
                    // おもしろ系
                    "宇宙人もビックリの強さですね！\n次のDAYも宇宙人をビックリさせちゃいましょう！",
                    "地球防衛隊の新星現る！\n次回「さらに強くなった敵」お楽しみに！",
                    "敵「なんで勝てないんだ...」\nあなた「知らんがな」",
                    "今日のMVP：あなた\n明日のMVP：たぶんあなた",
                    
                    // 応援系
                    "みんなが君を応援してるよ！\n次のDAYも頑張って！",
                    "地球のみんなが君の活躍を見てるぞ！",
                    "君がいれば地球は安心だ！\n次も頼んだぞ、相棒！",
                    
                    // 謎系
                    "フフフ...計画通り...\n次のフェーズに移行しよう。",
                    "興味深いデータが取れた。\n次の実験...もとい、作戦に期待する。",
                    "全ては運命...君もその一部だ。\n次の運命が君を待っている。"
                ];
                
                const randomMessage = congratsMessages[Math.floor(Math.random() * congratsMessages.length)];
                document.getElementById('congratsText').textContent = randomMessage;
            }
            
            displayRandomEndingMessage() {
                const endingMessages = [
                    // 感動系
                    "地球の青い空が、再び平和に輝いています。\nあなたの勇気が、未来への希望を繋いだのです。",
                    "星々が歌っています。英雄の帰還を。\n宇宙に響く勝利の讃美歌を、あなたに捧げます。",
                    "地球の子供たちが空を見上げて笑っています。\nそれが、あなたが守り抜いた最も大切なものです。",
                    "無数の命が救われました。\nあなたの戦いは、永遠に語り継がれるでしょう。",
                    
                    // 壮大系
                    "宇宙の歴史に新たな1ページが刻まれた。\n伝説の防衛者として、あなたの名が永遠に残るだろう。",
                    "銀河系防衛連合より最高勲章を授与します。\nあなたこそ、真の宇宙の守護者です。",
                    "この勝利は終わりではなく、始まりです。\n新たな平和の時代が、今ここから始まります。",
                    "地球防衛の歴史において、\nあなたの功績は金字塔として永遠に輝き続けるでしょう。",
                    
                    // ユーモア系
                    "宇宙人会議の議事録：\n「地球、強すぎ問題について」→「もう攻めるのやめよう（全会一致）」",
                    "地球防衛隊人事部より：\n昇進おめでとうございます！新しい名刺には「宇宙最強」と印刷されます。",
                    "敵の母艦から緊急通信：\n「すみません、道を間違えました。平和な星を探してます。」",
                    "宇宙保険会社より：\n「地球攻撃保険」の保険料が1000倍に値上がりしました。",
                    
                    // ネットミーム風
                    "地球防衛、完。\n敵「もう無理ぽ...」\nあなた「ざっこ♡」",
                    "【速報】宇宙人、地球攻撃を断念\n理由：「チートすぎて草」",
                    "宇宙人のツイート：\n「地球の防衛者つよすぎワロタwww もう帰るわwww」",
                    "敵司令官「計画通り...のはずだった」\nあなた「計画通り（完全勝利）」",
                    
                    // 哲学的
                    "戦いは終わった。しかし平和は戦い取るものではなく、\n守り続けるものだということを、あなたは教えてくれました。",
                    "真の強さとは、力ではなく、\n守りたいものを持つ心だということを証明しましたね。",
                    "宇宙は広大です。しかし、あなたの心はそれよりも大きい。\nなぜなら、愛で満ちているからです。",
                    
                    // 熱血系
                    "燃え尽きたぜ...真っ白にな...\nいや、まだまだ燃え続けるぜ！地球の平和のために！",
                    "これが俺たちの全力だ！\n宇宙の果てまで響け、勝利の雄叫び！",
                    "諦めない心が、不可能を可能にした！\n君こそ真の英雄だ！",
                    
                    // SF風
                    "時空連続体の安定化を確認。\n多元宇宙における地球の存続が保証されました。",
                    "量子レベルでの勝利パターンが確定。\n全ての平行世界で地球が救われています。",
                    "宇宙の法則が書き換えられました。\n新しい法則：「地球は絶対に負けない」",
                    
                    // 感謝系
                    "ありがとう。この言葉以外に、\n何と言えばいいのかわかりません。",
                    "地球の全ての生命から、心からの感謝を。\nあなたは私たちのヒーローです。",
                    "言葉では表せないほどの感謝の気持ちを込めて。\n本当に、本当にありがとうございました。",
                    
                    // 続編示唆系
                    "しかし、宇宙の彼方から新たな脅威の影が...\n「続編にご期待ください」",
                    "平和な日々が続いた。しかし、それは新たな冒険の始まりに過ぎなかった...",
                    "エピローグ：3年後、謎の信号が宇宙から届く。\n「また会おう、地球の守護者よ...」",
                    
                    // メタ系
                    "プレイヤーの皆様、お疲れ様でした！\n開発者一同、心より感謝申し上げます。",
                    "このゲームを最後まで遊んでくれて、ありがとう。\nあなたこそ、真のヒーローです。",
                    "スタッフロールが流れる中、\nあなたの冒険は永遠に続いていくのです..."
                ];
                
                const randomMessage = endingMessages[Math.floor(Math.random() * endingMessages.length)];
                
                // エンディング画面のメッセージ部分を更新
                const endingScreen = document.getElementById('endingScreen');
                const messageDiv = endingScreen.querySelector('div:nth-child(1) > div:nth-child(4)');
                if (messageDiv) {
                    messageDiv.innerHTML = `
                        <div style="margin: 30px 0; padding: 25px; border: 2px solid #00ff00; background: rgba(0, 255, 0, 0.1); border-radius: 10px; min-height: 120px; display: flex; align-items: center; justify-content: center;">
                            <p style="font-size: 1rem; margin: 0; color: #00ff00; line-height: 1.8; text-align: center;">${randomMessage}</p>
                        </div>
                    `;
                } else {
                    // メッセージ部分が見つからない場合は、新しく作成
                    const newMessageDiv = document.createElement('div');
                    newMessageDiv.style.margin = '30px 0';
                    newMessageDiv.style.padding = '25px';
                    newMessageDiv.style.border = '2px solid #00ff00';
                    newMessageDiv.style.background = 'rgba(0, 255, 0, 0.1)';
                    newMessageDiv.style.borderRadius = '10px';
                    newMessageDiv.style.minHeight = '120px';
                    newMessageDiv.style.display = 'flex';
                    newMessageDiv.style.alignItems = 'center';
                    newMessageDiv.style.justifyContent = 'center';
                    newMessageDiv.innerHTML = `<p style="font-size: 1rem; margin: 0; color: #00ff00; line-height: 1.8; text-align: center;">${randomMessage}</p>`;
                    
                    // スコア表示の後に挿入
                    const scoreDiv = endingScreen.querySelector('div:nth-child(1) > div:nth-child(3)');
                    if (scoreDiv) {
                        scoreDiv.parentNode.insertBefore(newMessageDiv, scoreDiv.nextSibling);
                    }
                }
            }
            
            proceedToNextDay() {
                // 帰還画面を非表示
                document.getElementById('returnToBaseScreen').style.display = 'none';
                
                // 次のDAYに進行
                this.currentDay++;
                this.dayCleared = false;
                
                // 敵をリセット（パワーアップは継続）
                this.enemies = [];
                this.bullets = [];
                this.explosions = [];
                this.powerups = [];
                this.gridItems = [];
                
                // プレイヤー位置をリセット
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height - 100;
                this.player.gridX = Math.floor(this.gridWidth / 2);
                this.player.gridY = this.gridHeight - 3;
                
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                    this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                    this.turnCount = 1;
                    this.playerMoved = false;
                    this.enemyTurnSkip = {};
                    // 初期アイテムを配置
                    this.spawnInitialGridItems();
                }
                
                // 地球を少し回復
                this.earthHealth = Math.min(this.earthHealth + 20, this.maxEarthHealth);
                
                // ゲーム再開
                this.gameState = 'playing';
                
                // DAY進行の通信メッセージ
                const dayMessages = {
                    2: 'DAY 2開始！敵の攻撃がより激しくなります',
                    3: 'DAY 3開始！最終決戦です。地球の命運をかけて戦ってください！'
                };
                
                this.addCommMessage(dayMessages[this.currentDay], 'urgent');
                this.addCommMessage('地球防護システム部分修復完了', 'normal');
                this.showMapEffect(`DAY ${this.currentDay} 開始！`, '#ffff00');
                
                // BGM再開
                this.startBGM();
            }
            
            showEnding() {
                this.gameState = 'ending';
                
                // BGM停止
                this.stopBGM();
                
                // エンディング画面の情報を設定
                document.getElementById('endingScore').textContent = this.score.toLocaleString();
                
                const difficultyNames = {
                    easy: 'EASY',
                    normal: 'NORMAL', 
                    hard: 'HARD',
                    expert: 'EXPERT',
                    nightmare: 'NIGHTMARE'
                };
                document.getElementById('endingDifficulty').textContent = difficultyNames[this.difficulty] || this.difficulty.toUpperCase();
                
                // バラエティ豊かなエンディングメッセージを表示
                this.displayRandomEndingMessage();
                
                // ランキングに追加
                this.addToRanking(this.score, this.difficulty, this.gameMode);
                
                // エンディング画面を表示
                document.getElementById('endingScreen').style.display = 'flex';
                
                // エンディング音（勝利のファンファーレ）
                setTimeout(() => this.playBeep(500, 200, 'sine'), 0);
                setTimeout(() => this.playBeep(600, 200, 'sine'), 200);
                setTimeout(() => this.playBeep(700, 200, 'sine'), 400);
                setTimeout(() => this.playBeep(800, 300, 'sine'), 600);
                setTimeout(() => this.playBeep(900, 400, 'sine'), 900);
            }
            
            startEndlessMode() {
                this.endlessMode = true;
                this.currentDay = 4; // エンドレスモード表示用
                this.dayCleared = false;
                this.gameState = 'playing';
                
                // エンディング画面を非表示
                document.getElementById('endingScreen').style.display = 'none';
                
                // エンドレスモード開始メッセージ
                this.addCommMessage('エンドレスモード開始！限界に挑戦してください', 'urgent');
                this.showMapEffect('エンドレスモード開始！', '#ff00ff');
                
                // BGM再開
                this.startBGM();
                
                // エンドレスモード音
                setTimeout(() => this.playBeep(400, 100, 'sine'), 0);
                setTimeout(() => this.playBeep(500, 100, 'sine'), 100);
                setTimeout(() => this.playBeep(600, 100, 'sine'), 200);
                setTimeout(() => this.playBeep(800, 200, 'sine'), 300);
            }
            
            addCommMessage(message, type = 'normal') {
                // 地球防衛モードまたはストラテジーモードでのみ動作
                if (this.gameMode !== 'defense' && this.gameMode !== 'strategy') return;
                
                const now = Date.now();
                // 同じメッセージの連続送信を防ぐ（1秒間隔）
                if (now - this.lastCommTime < 1000) return;
                
                this.lastCommTime = now;
                this.commMessageId++;
                
                // 最新のメッセージのみ保持
                this.currentCommMessage = {
                    id: this.commMessageId,
                    text: message,
                    type: type,
                    timestamp: now
                };
                
                this.updateCommDisplay();
            }
            
            updateCommDisplay() {
                const commMessagesDiv = document.getElementById('commMessages');
                if (!commMessagesDiv || !this.currentCommMessage) return;
                
                commMessagesDiv.innerHTML = '';
                
                const msg = this.currentCommMessage;
                const messageDiv = document.createElement('div');
                messageDiv.className = `comm-message ${msg.type === 'urgent' ? 'comm-urgent' : msg.type === 'warning' ? 'comm-warning' : ''}`;
                
                // タイムスタンプを追加
                const timeStr = new Date(msg.timestamp).toLocaleTimeString('ja-JP', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
                
                messageDiv.innerHTML = `<span style="opacity: 0.7; font-size: 10px;">[${timeStr}]</span> ${msg.text}`;
                commMessagesDiv.appendChild(messageDiv);
            }
            
            render() {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // グリッド描画（ターンベース・ストラテジーモード）
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.renderGrid();
                }
                
                this.renderStars();
                this.renderEarthSurface();
                this.renderPlayer();
                this.renderBullets();
                this.renderEnemies();
                this.renderPowerups();
                this.renderGridItems();
                this.renderMapEffects();
                this.renderExplosions();
                
                this.updateUI();
            }
            
            renderGrid() {
                this.ctx.strokeStyle = '#003300';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                
                // 縦線
                for (let x = 0; x <= this.gridWidth; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * this.gridSize, 0);
                    this.ctx.lineTo(x * this.gridSize, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // 横線
                for (let y = 0; y <= this.gridHeight; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * this.gridSize);
                    this.ctx.lineTo(this.canvas.width, y * this.gridSize);
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            renderStars() {
                this.ctx.fillStyle = '#ffffff';
                this.stars.forEach(star => {
                    this.ctx.fillRect(star.x, star.y, star.size, star.size);
                });
            }
            
            renderEarthSurface() {
                // 地球防衛モードでは地球の状態に応じて色を変更
                let earthColor = '#00ff00';
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    const healthRatio = this.earthHealth / this.maxEarthHealth;
                    if (healthRatio > 0.6) {
                        earthColor = '#00ff00'; // 緑（健康）
                    } else if (healthRatio > 0.3) {
                        earthColor = '#ffff00'; // 黄（警告）
                    } else {
                        earthColor = '#ff4400'; // 赤（危険）
                    }
                }
                
                this.ctx.strokeStyle = earthColor;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                this.earthSurface.forEach((point, index) => {
                    if (index === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                    
                    // 建物を描画（静的）
                    if (point.buildings) {
                        this.ctx.rect(point.x - 10, point.y - point.buildingHeight, 20, point.buildingHeight);
                    }
                });
                
                this.ctx.stroke();
                
                // 地球防衛モードでダメージを受けている場合、防護バリアを描画
                if ((this.gameMode === 'defense' || this.gameMode === 'strategy') && this.earthHealth < this.maxEarthHealth) {
                    this.ctx.strokeStyle = earthColor;
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, this.canvas.height - 80);
                    this.ctx.lineTo(this.canvas.width, this.canvas.height - 80);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
            
            renderPlayer() {
                // シールド描画
                if (this.player.shield) {
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.player.x + this.player.width/2,
                        this.player.y + this.player.height/2,
                        this.player.width/2 + 10,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.stroke();
                }
                
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                // 宇宙船の形状（三角形ベース）
                this.ctx.moveTo(this.player.x + this.player.width/2, this.player.y);
                this.ctx.lineTo(this.player.x, this.player.y + this.player.height);
                this.ctx.lineTo(this.player.x + this.player.width/4, this.player.y + this.player.height - 5);
                this.ctx.lineTo(this.player.x + this.player.width*3/4, this.player.y + this.player.height - 5);
                this.ctx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
                this.ctx.closePath();
                this.ctx.stroke();
                
                // 武器レベル表示（アクティブな武器のみ）
                let weaponCount = 0;
                Object.keys(this.weapons).forEach(weaponType => {
                    if (this.weapons[weaponType].level > 0) {
                        const colors = {
                            basicShot: '#ffff00',
                            spreadShot: '#ff8800',
                            laser: '#00ffff',
                            missile: '#ff0000',
                            orbit: '#00ff88',
                            piercing: '#00ff00',
                            homing: '#ff00ff',
                            barrier: '#8800ff'
                        };
                        
                        this.ctx.strokeStyle = colors[weaponType] || '#ffffff';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.rect(this.player.x + 5 + weaponCount * 8, this.player.y - 10, 6, 3);
                        this.ctx.stroke();
                        
                        // レベル表示
                        this.ctx.fillStyle = colors[weaponType] || '#ffffff';
                        this.ctx.font = '8px monospace';
                        this.ctx.fillText(this.weapons[weaponType].level.toString(), 
                                        this.player.x + 6 + weaponCount * 8, this.player.y - 4);
                        
                        weaponCount++;
                    }
                });
                
                // エンジンの炎
                this.ctx.strokeStyle = '#ff4400';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.width/4, this.player.y + this.player.height);
                this.ctx.lineTo(this.player.x + this.player.width/2, this.player.y + this.player.height + 10);
                this.ctx.lineTo(this.player.x + this.player.width*3/4, this.player.y + this.player.height);
                this.ctx.stroke();
            }
            
            renderBullets() {
                this.bullets.forEach(bullet => {
                    this.ctx.fillStyle = bullet.color || '#ffff00';
                    this.ctx.strokeStyle = bullet.color || '#ffff00';
                    
                    if (bullet.type === 'laser') {
                        // レーザーの描画
                        this.ctx.lineWidth = bullet.width;
                        this.ctx.beginPath();
                        this.ctx.moveTo(bullet.x, 0);
                        this.ctx.lineTo(bullet.x, this.canvas.height);
                        this.ctx.stroke();
                    } else if (bullet.type === 'missile') {
                        // ミサイルの描画
                        this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 煙の軌跡
                        this.ctx.fillStyle = '#666666';
                        this.ctx.fillRect(bullet.x + 2, bullet.y + bullet.height, 4, 8);
                    } else if (bullet.type === 'homing') {
                        // 追尾弾の描画（回転）
                        this.ctx.save();
                        this.ctx.translate(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
                        this.ctx.rotate(bullet.angle + Math.PI/2);
                        this.ctx.fillRect(-bullet.width/2, -bullet.height/2, bullet.width, bullet.height);
                        this.ctx.restore();
                    } else {
                        // 通常弾の描画
                        this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    }
                });
                
                // 軌道弾の描画
                this.orbitingBullets.forEach(orbit => {
                    const x = this.player.x + this.player.width/2 + Math.cos(orbit.angle) * orbit.distance;
                    const y = this.player.y + this.player.height/2 + Math.sin(orbit.angle) * orbit.distance;
                    
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, orbit.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // バリア弾の描画
                this.barrierBullets.forEach(barrier => {
                    let x, y;
                    
                    if (barrier.fixed) {
                        // 固定位置バリア
                        x = barrier.x;
                        y = barrier.y;
                    } else {
                        // プレイヤー周囲のバリア
                        x = this.player.x + this.player.width/2 + Math.cos(barrier.angle) * barrier.distance;
                        y = this.player.y + this.player.height/2 + Math.sin(barrier.angle) * barrier.distance;
                    }
                    
                    this.ctx.strokeStyle = '#8800ff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, barrier.size, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
            }
            
            renderEnemies() {
                this.enemies.forEach(enemy => {
                    if (enemy.type === 'enemy_bullet') {
                        // 敵の弾
                        this.ctx.strokeStyle = '#ff8800';
                        this.ctx.fillStyle = '#ff8800';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
                        this.ctx.fill();
                        this.ctx.stroke();
                    } else {
                        // 通常敵の色分け
                        const colors = {
                            normal: '#ff4444',
                            fast: '#ff0000',
                            heavy: '#ffaa00',
                            shooter: '#ff8800',
                            zigzag: '#ff6600'
                        };
                        
                        this.ctx.strokeStyle = colors[enemy.type] || '#ff4444';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        
                        if (enemy.type === 'heavy') {
                            // 重装敵（四角形）
                            this.ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
                        } else if (enemy.type === 'shooter') {
                            // 射撃敵（六角形）
                            const centerX = enemy.x + enemy.width/2;
                            const centerY = enemy.y + enemy.height/2;
                            const radius = enemy.width/2;
                            
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius * 0.7;
                                
                                if (i === 0) {
                                    this.ctx.moveTo(x, y);
                                } else {
                                    this.ctx.lineTo(x, y);
                                }
                            }
                            this.ctx.closePath();
                        } else {
                            // その他の敵（逆三角形）
                            this.ctx.moveTo(enemy.x + enemy.width/2, enemy.y + enemy.height);
                            this.ctx.lineTo(enemy.x, enemy.y);
                            this.ctx.lineTo(enemy.x + enemy.width/4, enemy.y + 5);
                            this.ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y + 5);
                            this.ctx.lineTo(enemy.x + enemy.width, enemy.y);
                            this.ctx.closePath();
                        }
                        
                        this.ctx.stroke();
                        
                        // 体力表示
                        if (enemy.health > 1) {
                            for (let i = 1; i < enemy.health; i++) {
                                this.ctx.beginPath();
                                this.ctx.rect(enemy.x + 3*i, enemy.y + 3*i, enemy.width - 6*i, enemy.height - 6*i);
                                this.ctx.stroke();
                            }
                        }
                    }
                });
            }
            
            renderPowerups() {
                this.powerups.forEach(powerup => {
                    const centerX = powerup.x + powerup.width / 2;
                    const centerY = powerup.y + powerup.height / 2;
                    
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(powerup.rotation);
                    
                    // 武器アイコンの描画
                    if (powerup.type === 'basicShot') {
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(0, 6);
                        this.ctx.stroke();
                    } else if (powerup.type === 'spreadShot') {
                        this.ctx.strokeStyle = '#ff8800';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(-4, -6);
                        this.ctx.lineTo(-4, 6);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(0, 6);
                        this.ctx.moveTo(4, -6);
                        this.ctx.lineTo(4, 6);
                        this.ctx.stroke();
                    } else if (powerup.type === 'laser') {
                        this.ctx.strokeStyle = '#00ffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(0, -8);
                        this.ctx.lineTo(0, 8);
                        this.ctx.stroke();
                    } else if (powerup.type === 'missile') {
                        this.ctx.strokeStyle = '#ff0000';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(-3, 0);
                        this.ctx.lineTo(0, 6);
                        this.ctx.lineTo(3, 0);
                        this.ctx.closePath();
                        this.ctx.stroke();
                    } else if (powerup.type === 'orbit') {
                        this.ctx.strokeStyle = '#00ff88';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else if (powerup.type === 'piercing') {
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(-6, 0);
                        this.ctx.lineTo(6, 0);
                        this.ctx.moveTo(3, -3);
                        this.ctx.lineTo(6, 0);
                        this.ctx.lineTo(3, 3);
                        this.ctx.stroke();
                    } else if (powerup.type === 'homing') {
                        this.ctx.strokeStyle = '#ff00ff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        this.ctx.moveTo(0, -4);
                        this.ctx.lineTo(0, -8);
                        this.ctx.stroke();
                    } else if (powerup.type === 'barrier') {
                        this.ctx.strokeStyle = '#8800ff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        this.ctx.moveTo(-4, -4);
                        this.ctx.lineTo(4, 4);
                        this.ctx.moveTo(-4, 4);
                        this.ctx.lineTo(4, -4);
                        this.ctx.stroke();
                    } else if (powerup.type === 'shield') {
                        this.ctx.strokeStyle = '#00ffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else if (powerup.type === 'life') {
                        this.ctx.strokeStyle = '#ff0080';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -10);
                        this.ctx.lineTo(-8, -2);
                        this.ctx.lineTo(-8, 6);
                        this.ctx.lineTo(0, 10);
                        this.ctx.lineTo(8, 6);
                        this.ctx.lineTo(8, -2);
                        this.ctx.closePath();
                        this.ctx.stroke();
                    } else if (powerup.type === 'speed') {
                        this.ctx.strokeStyle = '#88ff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(-6, 0);
                        this.ctx.lineTo(6, 0);
                        this.ctx.moveTo(3, -3);
                        this.ctx.lineTo(6, 0);
                        this.ctx.lineTo(3, 3);
                        this.ctx.moveTo(-3, -3);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-3, 3);
                        this.ctx.stroke();
                    } else if (powerup.type === 'healEarth') {
                        // 地球回復アイテムは特別なハイライト表示
                        const pulseScale = 1 + Math.sin(powerup.pulseTime) * 0.3;
                        const glowIntensity = Math.sin(powerup.pulseTime * 2) * 0.5 + 0.5;
                        
                        // 外側のグロー効果
                        this.ctx.strokeStyle = `rgba(0, 255, 0, ${glowIntensity * 0.8})`;
                        this.ctx.lineWidth = 6;
                        this.ctx.beginPath();
                        this.ctx.rect(-12 * pulseScale, -12 * pulseScale, 24 * pulseScale, 24 * pulseScale);
                        this.ctx.stroke();
                        
                        // メインアイコン
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.rect(-8, -8, 16, 16);
                        this.ctx.moveTo(-6, 0);
                        this.ctx.lineTo(6, 0);
                        this.ctx.moveTo(0, -6);
                        this.ctx.lineTo(0, 6);
                        this.ctx.stroke();
                        
                        // 地球アイコンの追加
                        this.ctx.strokeStyle = '#00aaff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 10, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // 回復エフェクトの粒子
                        for (let i = 0; i < 4; i++) {
                            const angle = (powerup.rotation * 2 + i * Math.PI / 2);
                            const particleX = Math.cos(angle) * 15;
                            const particleY = Math.sin(angle) * 15;
                            
                            this.ctx.fillStyle = `rgba(0, 255, 0, ${glowIntensity})`;
                            this.ctx.beginPath();
                            this.ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                });
            }
            

            
            renderGridItems() {
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.gridItems.forEach(item => {
                        const centerX = item.x + item.width / 2;
                        const centerY = item.y + item.height / 2;
                        const pulseScale = 1 + Math.sin(item.pulseTime) * 0.2;
                        
                        this.ctx.save();
                        this.ctx.translate(centerX, centerY);
                        this.ctx.rotate(item.rotation);
                        this.ctx.scale(pulseScale, pulseScale);
                        
                        // 特殊アイテムのアイコン描画
                        this.ctx.lineWidth = 2;
                        
                        switch (item.type) {
                            case 'freeze':
                                this.ctx.strokeStyle = '#00ffff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                // 雪の結晶
                                this.ctx.moveTo(0, -8); this.ctx.lineTo(0, 8);
                                this.ctx.moveTo(-8, 0); this.ctx.lineTo(8, 0);
                                this.ctx.moveTo(-6, -6); this.ctx.lineTo(6, 6);
                                this.ctx.moveTo(-6, 6); this.ctx.lineTo(6, -6);
                                this.ctx.stroke();
                                break;
                            case 'slowTime':
                                this.ctx.strokeStyle = '#ffff00';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                this.ctx.moveTo(0, 0); this.ctx.lineTo(0, -6);
                                this.ctx.moveTo(0, 0); this.ctx.lineTo(4, 0);
                                this.ctx.stroke();
                                break;
                            case 'mapShield':
                                this.ctx.strokeStyle = '#00ffff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 10, 0, Math.PI * 2);
                                this.ctx.moveTo(-6, -6); this.ctx.lineTo(6, 6);
                                this.ctx.moveTo(-6, 6); this.ctx.lineTo(6, -6);
                                this.ctx.stroke();
                                break;
                            case 'doubleScore':
                                this.ctx.strokeStyle = '#ffff00';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.font = '16px monospace';
                                this.ctx.fillStyle = '#ffff00';
                                this.ctx.fillText('2X', -8, 4);
                                this.ctx.stroke();
                                break;
                            case 'rapidFire':
                                this.ctx.strokeStyle = '#ff8800';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                for (let i = 0; i < 3; i++) {
                                    this.ctx.moveTo(-6 + i*6, -8);
                                    this.ctx.lineTo(-6 + i*6, 8);
                                }
                                this.ctx.stroke();
                                break;
                            case 'invincible':
                                this.ctx.strokeStyle = '#ff00ff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.moveTo(0, -10); this.ctx.lineTo(-8, -2);
                                this.ctx.lineTo(-8, 6); this.ctx.lineTo(0, 10);
                                this.ctx.lineTo(8, 6); this.ctx.lineTo(8, -2);
                                this.ctx.closePath();
                                this.ctx.stroke();
                                break;
                            case 'explosion':
                                this.ctx.strokeStyle = '#ff0000';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                this.ctx.moveTo(0, -12); this.ctx.lineTo(0, -8);
                                this.ctx.stroke();
                                break;
                            case 'timeWarp':
                                this.ctx.strokeStyle = '#ff00ff';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.arc(0, 0, 6, 0, Math.PI);
                                this.ctx.arc(0, 0, 6, Math.PI, Math.PI * 2);
                                this.ctx.stroke();
                                break;
                            case 'healEarth':
                                // 地球回復アイテムは特別なハイライト表示（グリッド版）
                                const gridGlowIntensity = Math.sin(item.pulseTime * 2) * 0.5 + 0.5;
                                
                                // 外側のグロー効果
                                this.ctx.strokeStyle = `rgba(0, 255, 0, ${gridGlowIntensity * 0.8})`;
                                this.ctx.lineWidth = 4;
                                this.ctx.beginPath();
                                this.ctx.rect(-15, -15, 30, 30);
                                this.ctx.stroke();
                                
                                // メインアイコン
                                this.ctx.strokeStyle = '#00ff00';
                                this.ctx.lineWidth = 3;
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.moveTo(-6, 0); this.ctx.lineTo(6, 0);
                                this.ctx.moveTo(0, -6); this.ctx.lineTo(0, 6);
                                this.ctx.stroke();
                                
                                // 地球アイコンの追加
                                this.ctx.strokeStyle = '#00aaff';
                                this.ctx.lineWidth = 2;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                this.ctx.stroke();
                                
                                // 回復エフェクトの粒子
                                for (let i = 0; i < 4; i++) {
                                    const angle = (item.rotation * 2 + i * Math.PI / 2);
                                    const particleX = Math.cos(angle) * 12;
                                    const particleY = Math.sin(angle) * 12;
                                    
                                    this.ctx.fillStyle = `rgba(0, 255, 0, ${gridGlowIntensity})`;
                                    this.ctx.beginPath();
                                    this.ctx.arc(particleX, particleY, 1.5, 0, Math.PI * 2);
                                    this.ctx.fill();
                                }
                                break;
                            case 'lightningStrike':
                                this.ctx.strokeStyle = '#ffff00';
                                this.ctx.beginPath();
                                this.ctx.rect(-12, -12, 24, 24);
                                this.ctx.moveTo(-4, -8); this.ctx.lineTo(0, 0);
                                this.ctx.lineTo(-2, 0); this.ctx.lineTo(4, 8);
                                this.ctx.stroke();
                                break;
                            default:
                                // 通常アイテムは既存の描画を使用
                                this.renderPowerupIcon(item.type);
                                break;
                        }
                        
                        this.ctx.restore();
                    });
                }
            }
            
            renderMapEffects() {
                // アクティブなマップ効果の視覚表現
                if (this.mapEffects.freeze.active) {
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                if (this.mapEffects.slowTime.active) {
                    this.ctx.fillStyle = 'rgba(255, 255, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                if (this.mapEffects.shield.active || this.mapEffects.invincible.active) {
                    this.ctx.strokeStyle = this.mapEffects.invincible.active ? '#ff00ff' : '#00ffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([10, 10]);
                    this.ctx.beginPath();
                    this.ctx.rect(5, 5, this.canvas.width - 10, this.canvas.height - 10);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                if (this.mapEffects.energyStorm.active) {
                    // エネルギーストームエフェクト
                    for (let i = 0; i < 5; i++) {
                        this.ctx.strokeStyle = '#ff4400';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(Math.random() * this.canvas.width, 0);
                        this.ctx.lineTo(Math.random() * this.canvas.width, this.canvas.height);
                        this.ctx.stroke();
                    }
                }
            }
            
            renderPowerupIcon(type) {
                // 既存のパワーアップアイコン描画ロジックを再利用
                if (type === 'basicShot') {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.rect(-8, -8, 16, 16);
                    this.ctx.moveTo(0, -6); this.ctx.lineTo(0, 6);
                    this.ctx.stroke();
                } else if (type === 'shield') {
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else if (type === 'life') {
                    this.ctx.strokeStyle = '#ff0080';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -10); this.ctx.lineTo(-8, -2);
                    this.ctx.lineTo(-8, 6); this.ctx.lineTo(0, 10);
                    this.ctx.lineTo(8, 6); this.ctx.lineTo(8, -2);
                    this.ctx.closePath();
                    this.ctx.stroke();
                } else if (type === 'speed') {
                    this.ctx.strokeStyle = '#88ff00';
                    this.ctx.beginPath();
                    this.ctx.moveTo(-6, 0); this.ctx.lineTo(6, 0);
                    this.ctx.moveTo(3, -3); this.ctx.lineTo(6, 0); this.ctx.lineTo(3, 3);
                    this.ctx.stroke();
                }
            }
            
            renderExplosions() {
                this.explosions.forEach(explosion => {
                    if (explosion.type === 'missile') {
                        // ミサイル爆発の描画
                        this.ctx.strokeStyle = '#ff4400';
                        this.ctx.lineWidth = 4;
                        this.ctx.beginPath();
                        this.ctx.arc(explosion.x, explosion.y, explosion.radius * (1 - explosion.time / 30), 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        this.ctx.strokeStyle = '#ffaa00';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(explosion.x, explosion.y, explosion.radius * 0.7 * (1 - explosion.time / 30), 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        // 通常爆発の描画
                        this.ctx.strokeStyle = '#ff8800';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        
                        const segments = 8;
                        for (let i = 0; i < segments; i++) {
                            const angle = (i / segments) * Math.PI * 2;
                            const x = explosion.x + Math.cos(angle) * explosion.radius;
                            const y = explosion.y + Math.sin(angle) * explosion.radius;
                            
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                });
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                
                // 地球防衛モード用UI
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    document.getElementById('earthHp').textContent = this.earthHealth;
                }
                
                // 地球防衛モードまたはストラテジーモードのDAY情報更新
                if (this.gameMode === 'defense' || this.gameMode === 'strategy') {
                    if (this.endlessMode) {
                        document.getElementById('currentDay').textContent = 'エンドレス';
                        document.getElementById('dayTarget').textContent = '∞';
                    } else {
                        document.getElementById('currentDay').textContent = `DAY ${this.currentDay}`;
                        const targetScore = this.dayTargetScores[this.currentDay];
                        document.getElementById('dayTarget').textContent = targetScore ? targetScore.toLocaleString() : '---';
                    }
                }
                
                // ターンベースモード用UI
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    document.getElementById('turnCount').textContent = this.turnCount;
                    this.updateEffectsLog();
                    this.updateInventoryUI();
                }
            }
            
            updateEffectsLog() {
                const effectsList = document.getElementById('effectsList');
                effectsList.innerHTML = '';
                
                const effectNames = {
                    freeze: '敵全体凍結',
                    slowTime: '時間減速',
                    shield: '全体シールド',
                    doubleScore: 'スコア2倍',
                    rapidFire: '連射強化',
                    invincible: '無敵状態',
                    magneticField: '磁力フィールド',
                    energyStorm: 'エネルギーストーム'
                };
                
                const effectColors = {
                    freeze: '#00ffff',
                    slowTime: '#ffff00',
                    shield: '#00ffff',
                    doubleScore: '#ffff00',
                    rapidFire: '#ff8800',
                    invincible: '#ff00ff',
                    magneticField: '#8800ff',
                    energyStorm: '#ff4400'
                };
                
                let hasActiveEffects = false;
                
                Object.keys(this.mapEffects).forEach(effectKey => {
                    const effect = this.mapEffects[effectKey];
                    if (effect.active && effect.duration > 0) {
                        hasActiveEffects = true;
                        
                        const effectItem = document.createElement('div');
                        effectItem.className = 'effect-item';
                        effectItem.style.borderColor = effectColors[effectKey] || '#ffff00';
                        effectItem.style.background = `rgba(${effectColors[effectKey] ? this.hexToRgb(effectColors[effectKey]) : '255,255,0'}, 0.1)`;
                        
                        effectItem.innerHTML = `
                            <span class="effect-name" style="color: ${effectColors[effectKey] || '#ffff00'}">
                                ${effectNames[effectKey] || effectKey}
                            </span>
                            <span class="effect-duration">残り${effect.duration}ターン</span>
                        `;
                        
                        effectsList.appendChild(effectItem);
                    }
                });
                
                if (!hasActiveEffects) {
                    effectsList.innerHTML = '<div style="opacity: 0.5; font-style: italic;">なし</div>';
                }
            }
            
            updateInventoryUI() {
                const inventoryList = document.getElementById('inventoryList');
                inventoryList.innerHTML = '';
                
                const itemNames = {
                    explosion: 'エクスプロージョン'
                };
                
                const itemColors = {
                    explosion: '#ff0000'
                };
                
                const itemHotkeys = {
                    explosion: 'Q'
                };
                
                let hasItems = false;
                
                Object.keys(this.inventory).forEach(itemKey => {
                    const count = this.inventory[itemKey];
                    if (count > 0) {
                        hasItems = true;
                        
                        const inventoryItem = document.createElement('div');
                        inventoryItem.className = 'inventory-item';
                        inventoryItem.style.borderColor = itemColors[itemKey] || '#ff8800';
                        inventoryItem.style.background = `rgba(${itemColors[itemKey] ? this.hexToRgb(itemColors[itemKey]) : '255,136,0'}, 0.1)`;
                        
                        inventoryItem.innerHTML = `
                            <div>
                                <span class="item-name" style="color: ${itemColors[itemKey] || '#ff8800'}">
                                    ${itemNames[itemKey] || itemKey}
                                </span>
                                <span class="item-hotkey">[${itemHotkeys[itemKey] || '?'}]</span>
                            </div>
                            <span class="item-count">x${count}</span>
                        `;
                        
                        // クリックでアイテム使用
                        inventoryItem.addEventListener('click', () => {
                            this.useInventoryItem(itemKey);
                        });
                        
                        inventoryList.appendChild(inventoryItem);
                    }
                });
                
                if (!hasItems) {
                    inventoryList.innerHTML = '<div style="opacity: 0.5; font-style: italic;">なし</div>';
                }
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? 
                    `${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)}` : 
                    '255,255,0';
            }
            
            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                }
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                
                // BGM停止
                this.stopBGM();
                
                document.getElementById('finalScore').textContent = this.score.toLocaleString();
                
                const difficultyNames = {
                    easy: 'EASY',
                    normal: 'NORMAL', 
                    hard: 'HARD',
                    expert: 'EXPERT',
                    nightmare: 'NIGHTMARE'
                };
                document.getElementById('finalDifficulty').textContent = difficultyNames[this.difficulty] || this.difficulty.toUpperCase();
                
                // ランキングに追加（全ゲームモード対応）
                const newRecordIndex = this.addToRanking(this.score, this.difficulty, this.gameMode);
                this.displayRankings(newRecordIndex);
                
                // ゲームモード別のランキングタイトル表示
                const rankingSection = document.getElementById('rankingList');
                const rankingTitle = rankingSection.querySelector('h3');
                const gameModeNames = {
                    classic: 'クラシック',
                    defense: '地球防衛',
                    turnbased: 'ターンベース',
                    strategy: 'ストラテジー'
                };
                const gameModeName = gameModeNames[this.gameMode] || this.gameMode;
                rankingTitle.innerHTML = `🏆 ハイスコア ランキング<br><small style="font-size: 12px; opacity: 0.7;">(${gameModeName}モード)</small>`;
                
                document.getElementById('gameOver').style.display = 'block';
                
                // ゲームオーバー音（下降音階）
                setTimeout(() => this.playBeep(400, 200, 'sine'), 0);
                setTimeout(() => this.playBeep(350, 200, 'sine'), 200);
                setTimeout(() => this.playBeep(300, 400, 'sine'), 400);
            }
            
            restartSameDifficulty() {
                this.gameState = 'playing';
                this.score = 0;
                this.lives = this.difficultySettings.playerLives;
                this.level = 1;
                this.bullets = [];
                this.enemies = [];
                this.explosions = [];
                this.powerups = [];
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height - 100;
                this.player.shield = false;
                this.player.shieldTime = 0;
                this.player.speed = this.isMobile() ? 4 : 5;
                
                // グリッド座標の初期化
                this.player.gridX = Math.floor(this.gridWidth / 2);
                this.player.gridY = this.gridHeight - 3;
                
                // ターンベース・ストラテジーモードでは正確なグリッド位置に配置
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                    this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                }
                
                // ゲームモード固有の初期化
                this.earthHealth = this.maxEarthHealth;
                this.turnCount = 1;
                this.playerMoved = false;
                
                // DAYシステムのリセット
                this.currentDay = 1;
                this.dayCleared = false;
                this.endlessMode = false;
                
                // マップ効果とグリッドアイテムのリセット
                this.mapEffects = {
                    freeze: { active: false, duration: 0 },
                    slowTime: { active: false, duration: 0 },
                    shield: { active: false, duration: 0 },
                    doubleScore: { active: false, duration: 0 },
                    rapidFire: { active: false, duration: 0 },
                    invincible: { active: false, duration: 0 },
                    magneticField: { active: false, duration: 0 },
                    energyStorm: { active: false, duration: 0 }
                };
                this.gridItems = [];
                this.enemyTurnSkip = {};
                
                // インベントリのリセット
                this.inventory = {
                    explosion: 0
                };
                
                // 通信ログのリセット
                this.currentCommMessage = null;
                this.lastCommTime = 0;
                this.commMessageId = 0;
                
                // 武器リセット
                this.weapons = {
                    basicShot: { level: 1, maxLevel: 5, lastShot: 0, cooldown: 150 },
                    spreadShot: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 200 },
                    laser: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 300 },
                    missile: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 800 },
                    orbit: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 100 },
                    piercing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 250 },
                    homing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 400 },
                    barrier: { level: 0, maxLevel: 3, lastShot: 0, cooldown: 1000 }
                };
                
                this.orbitingBullets = [];
                this.barrierBullets = [];
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('endingScreen').style.display = 'none';
                
                // UI表示の更新
                this.updateUIVisibility();
                
                // ターンベース・ストラテジーモードでは初期アイテムを配置
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.spawnInitialGridItems();
                    this.giveInitialInventoryItems();
                }
                
                // 地球防衛モードまたはストラテジーモードの初期メッセージ
                if (this.gameMode === 'defense') {
                    this.addCommMessage('防衛司令部より、地球防衛作戦を開始します', 'normal');
                    this.addCommMessage('DAY 1：敵の侵攻を阻止し、地球を守り抜いてください', 'normal');
                } else if (this.gameMode === 'strategy') {
                    this.addCommMessage('戦略司令部より、ターン制地球防衛作戦を開始します', 'normal');
                    this.addCommMessage('DAY 1：戦略的思考で敵を撃退し、地球を守り抜いてください', 'normal');
                }
                
                // BGM再開
                this.startBGM();
            }
            
            restart() {
                // 後方互換性のため
                this.restartSameDifficulty();
            }
            
            backToTitle() {
                this.gameState = 'title';
                
                // BGM停止
                this.stopBGM();
                
                // 画面表示の切り替え
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('endingScreen').style.display = 'none';
                document.getElementById('returnToBaseScreen').style.display = 'none';
                document.getElementById('titleScreen').style.display = 'flex';
                document.getElementById('difficultyScreen').style.display = 'none';
                document.getElementById('instructionsScreen').style.display = 'none';
                document.getElementById('gameModeScreen').style.display = 'none';
                
                // UI要素を非表示
                document.getElementById('earthHealth').style.display = 'none';
                document.getElementById('dayInfo').style.display = 'none';
                document.getElementById('turnInfo').style.display = 'none';
                document.getElementById('effectsLog').style.display = 'none';
                document.getElementById('inventoryUI').style.display = 'none';
                
                // ゲーム状態をリセット
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.bullets = [];
                this.enemies = [];
                this.explosions = [];
                this.powerups = [];
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height - 100;
                this.player.shield = false;
                this.player.shieldTime = 0;
                this.player.speed = this.isMobile() ? 4 : 5;
                
                // グリッド座標の初期化
                this.player.gridX = Math.floor(this.gridWidth / 2);
                this.player.gridY = this.gridHeight - 3;
                
                // ターンベース・ストラテジーモードでは正確なグリッド位置に配置
                if (this.gameMode === 'turnbased' || this.gameMode === 'strategy') {
                    this.player.x = this.player.gridX * this.gridSize + this.gridSize/2 - this.player.width/2;
                    this.player.y = this.player.gridY * this.gridSize + this.gridSize/2 - this.player.height/2;
                }
                
                // ゲームモード固有の状態をリセット
                this.earthHealth = this.maxEarthHealth;
                this.turnCount = 1;
                this.playerMoved = false;
                this.enemyTurnSkip = {};
                
                // DAYシステムのリセット
                this.currentDay = 1;
                this.dayCleared = false;
                this.endlessMode = false;
                
                // 武器リセット
                this.weapons = {
                    basicShot: { level: 1, maxLevel: 5, lastShot: 0, cooldown: 150 },
                    spreadShot: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 200 },
                    laser: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 300 },
                    missile: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 800 },
                    orbit: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 100 },
                    piercing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 250 },
                    homing: { level: 0, maxLevel: 5, lastShot: 0, cooldown: 400 },
                    barrier: { level: 0, maxLevel: 3, lastShot: 0, cooldown: 1000 }
                };
                
                this.orbitingBullets = [];
                this.barrierBullets = [];
                
                // インベントリのリセット
                this.inventory = {
                    explosion: 0
                };
                
                // デフォルト設定に戻す
                this.gameMode = 'classic';
                this.difficulty = 'normal';
                this.difficultySettings = this.getDifficultySettings('normal');
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // ゲーム開始
        let game;
        window.addEventListener('load', () => {
            game = new WireframeShooter();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'967a1748341dd54b',t:'MTc1MzkzMzQwMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
  <button id="fullscreenBtn" onclick="toggleFullScreen()">⛶ 全画面</button>

  <script>
    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch((err) => {
          alert(`全画面にできませんでした: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    }
  </script>
</body>
</html>
